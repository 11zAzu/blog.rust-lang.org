<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2023-05-09T15:56:14+00:00</updated>

    
    <entry>
        <title>API token scopes</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/05/09/api-token-scopes.html" type="text/html" title="API token scopes" />
        <published>2023-05-09T00:00:00+00:00</published>
        <updated>2023-05-09T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/05/09/api-token-scopes.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/05/09/api-token-scopes.html">&lt;p&gt;Roughly three years ago &lt;a href&#x3D;&quot;https://github.com/pietroalbini&quot;&gt;Pietro Albini&lt;/a&gt; opened an RFC called &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2947&quot;&gt;&amp;quot;crates.io token scopes&amp;quot;&lt;/a&gt;. This RFC described an improvement to the existing API tokens, that everyone is using to publish crates to the &lt;a href&#x3D;&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt; package registry. The proposal was to make it possible to restrict API tokens to 1) certain operations and 2) certain crates.&lt;/p&gt;
&lt;p&gt;Unfortunately, the crates.io team members were quite busy at the time, so it took a while for this proposal to get accepted. To be precise, during the &lt;a href&#x3D;&quot;https://eurorust.eu&quot;&gt;EuroRust&lt;/a&gt; conference in October 2022 we talked about the RFC again and after a few modifications the RFC was moved into FCP status and then finally merged.&lt;/p&gt;
&lt;p&gt;The implementation was started soon after, but was paused again due to other priorities at the time. Fortunately, I was lucky enough to get one of the software engineering jobs at the &lt;a href&#x3D;&quot;https://rustfoundation.org/&quot;&gt;Rust Foundation&lt;/a&gt;, so in early April the development continued, and I am happy to report:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API token scopes on crates.io are now in a public beta testing period!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;For details on what these token scopes are and how they are supposed to work, I recommend reading through the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2947&quot;&gt;RFC&lt;/a&gt;. If you want to try them out, you can go to &lt;a href&#x3D;&quot;https://crates.io/settings/tokens/new&quot;&gt;https://crates.io/settings/tokens/new&lt;/a&gt; and create a new API token scoped to the operations and crates you want:&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;../../../../images/inside-rust/2023-05-09-api-token-scopes/screenshot.png&quot; alt&#x3D;&quot;Screenshot of the &amp;quot;New API Token&amp;quot; page&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Please note that this page is currently not reachable from the regular user interface, you have to access it via URL directly while we test it out.&lt;/p&gt;
&lt;p&gt;Finally, if you notice any issues, or if you have any questions don&#x27;t hesitate to find us on &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/318791-t-crates-io/topic/token.20scopes&quot;&gt;Zulip&lt;/a&gt; or open an issue on &lt;a href&#x3D;&quot;https://github.com/rust-lang/crates.io/issues/new/choose&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Tobias Bieniek</name>
        </author>
    </entry>
    
    <entry>
        <title>Stabilizing async fn in traits in 2023</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/05/03/stabilizing-async-fn-in-trait.html" type="text/html" title="Stabilizing async fn in traits in 2023" />
        <published>2023-05-03T00:00:00+00:00</published>
        <updated>2023-05-03T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/05/03/stabilizing-async-fn-in-trait.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/05/03/stabilizing-async-fn-in-trait.html">&lt;p&gt;The async working group&#x27;s headline goal for 2023 is to stabilize a &amp;quot;minimum viable product&amp;quot; (MVP) version of async functions in traits. We are currently targeting Rust 1.74 for stabilization. This post lays out the features we plan to ship and the status of each one.&lt;/p&gt;
&lt;p&gt;In November, we &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html&quot;&gt;blogged about nightly support for async fn in trait&lt;/a&gt; and identified some key next steps, most importantly &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html#limitation-spawning-from-generics&quot;&gt;support for send bounds to allow spawning in generic functions&lt;/a&gt;. Since then we&#x27;ve done a significant amount of design exploration and collected a set of case studies evaluating how well the current code works in practice.&lt;/p&gt;
&lt;p&gt;As of now, all of the functionality described in this blog post is available on the nightly compiler. Some of this work was implemented using &lt;a href&#x3D;&quot;https://lang-team.rust-lang.org/how_to/experiment.html&quot;&gt;experimental feature gates&lt;/a&gt; so that we could conduct case studies and prove out viability; we are in the process of authoring RFCs for those features now (full details below).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mvp-part-1-core-support-for-async-functions-in-traits&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mvp-part-1-core-support-for-async-functions-in-traits&quot;&gt;&lt;/a&gt;MVP Part 1: Core support for &amp;quot;async functions in traits&amp;quot;&lt;/h2&gt;
&lt;p&gt;The easiest way to explain what we are going to stabilize is to use a code example. To start, we will permit the use of &lt;code&gt;async fn&lt;/code&gt; in trait definitions...&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait HealthCheck {
    async fn check(&amp;amp;mut self) -&amp;gt; bool;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...and you can then use &lt;code&gt;async fn&lt;/code&gt; in the corresponding impl:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl HealthCheck for MyHealthChecker {
    async fn check(&amp;amp;mut self) -&amp;gt; bool {
        do_async_op().await
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Traits with async functions can then be used as you normally would:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_health_check(hc: impl HealthCheck) {
    if !hc.check().await {
        log_health_check_failure().await;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Status:&lt;/strong&gt; This functionality was described in &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/3185-static-async-fn-in-trait.html&quot;&gt;RFC 3185&lt;/a&gt;, merged on Dec 7, 2021, and is available in nightly. It was covered in detail in our &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html&quot;&gt;previous blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;2399715f67d8eb0064efd6c8e47532f7&quot;&gt;Playground&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mvp-part-2-send-bounds-and-associated-return-types&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mvp-part-2-send-bounds-and-associated-return-types&quot;&gt;&lt;/a&gt;MVP Part 2: Send bounds and associated return types&lt;/h2&gt;
&lt;p&gt;There is one complication that arises when using async functions in traits that doesn&#x27;t arise with sync functions. Many async runtimes -- notably including the default configurations of &lt;a href&#x3D;&quot;https://tokio.rs/&quot;&gt;Tokio&lt;/a&gt; and &lt;a href&#x3D;&quot;https://async.rs/&quot;&gt;async-std&lt;/a&gt; -- use a work stealing thread scheduler. This means that futures may move between worker threads dynamically to achieve load balancing. As a result, the future must only capture &lt;code&gt;Send&lt;/code&gt; data.&lt;/p&gt;
&lt;p&gt;If you author a generic async function that spawns tasks on one of those runtimes, however, you will start to get compilation errors (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;c033cf6174ff7d44e5673ecd254e6e69&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_health_check_par(hc: impl HealthCheck) {
    tokio::task::spawn(async move {
        if !hc.check().await {
            log_health_check_failure().await;
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem is that the future returned by &lt;code&gt;hc.check()&lt;/code&gt; isn&#x27;t guaranteed to be &lt;code&gt;Send&lt;/code&gt;. It might access non-Send data. The solution is to add a &lt;code&gt;Send&lt;/code&gt; bound, but given that this is an async function, it&#x27;s not obvious how to do that. How do we talk about the future returned by a call to &lt;code&gt;hc.check()&lt;/code&gt;? Associated return types provide the answer. We can convert the above function to use an explicit type parameter &lt;code&gt;HC&lt;/code&gt; (instead of &lt;code&gt;impl HealthCheck&lt;/code&gt;) and then add a new bound, &lt;code&gt;HC::check(): Send&lt;/code&gt;. This says &amp;quot;the value returned by &lt;code&gt;HC::check&lt;/code&gt; must be of &lt;code&gt;Send&lt;/code&gt; type&amp;quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_health_check_par&amp;lt;HC&amp;gt;(hc: HC)
where
    HC: HealthCheck + Send + &#x27;static,
    HC::check(): Send, // &amp;lt;-- associated return type
{
    tokio::task::spawn(async move {
        if !hc.check().await {
            log_health_check_failure().await;
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, it&#x27;s kind of unfortunate that we had to rewrite from taking an &lt;code&gt;impl HealthCheck&lt;/code&gt; to an explicit &lt;code&gt;HC&lt;/code&gt; type parameter in order to use this notation. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2289&quot;&gt;RFC 2289&lt;/a&gt;, &amp;quot;associated type bounds&amp;quot;, introduced a compact notation to address this problem. That RFC is not part of this MVP, but if it were stabilized, then one could simply write:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_health_check_par(hc: impl HealthCheck&amp;lt;check(): Send&amp;gt; + Send + &#x27;static) {
    //                                            -------------
    tokio::task::spawn(async move {
        if !hc.check().await {
            log_health_check_failure().await;
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html&quot;&gt;previous post&lt;/a&gt;, we &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html#hypothesis-this-is-uncommon&quot;&gt;hypothesized&lt;/a&gt; that this problem might not occur often in practice. However, our case studies found that it comes up quite frequently, and so we decided that a solution is needed. We explored a number of solutions and concluded that associated return types (ARTs) are a flexible and reasonably ergonomic building block, which makes them a great fit for an MVP.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Status:&lt;/strong&gt; Associated return types have an experimental implementation and we are currently drafting an RFC. There are several open bugs that will need to be fixed. We also found that in traits with many methods, ARTs become verbose, and in the future may consider more concise syntax (see below).&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;2066934a05cb9eafc0b47af7bdf8c57f&quot;&gt;Playground&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mvp-part-3-impl-trait-in-traits-return-position&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mvp-part-3-impl-trait-in-traits-return-position&quot;&gt;&lt;/a&gt;MVP Part 3: &amp;quot;impl trait in traits&amp;quot; (return position)&lt;/h2&gt;
&lt;p&gt;In Rust an async function is &amp;quot;syntactic sugar&amp;quot; for a function that returns an &lt;code&gt;impl Future&lt;/code&gt;, and async functions in traits are no exception. As part of the MVP, we plan to stabilize the use of &lt;code&gt;-&amp;gt; impl Trait&lt;/code&gt; notation in traits and trait impls.&lt;/p&gt;
&lt;p&gt;Impl trait in traits has all kinds of uses, but one common one for async programming is to avoid capturing all of the function arguments by doing some amount of sync work and then returning a future for the rest. For example, this &lt;code&gt;LaunchService&lt;/code&gt; trait declares a &lt;code&gt;launch&lt;/code&gt; function that does not capture &lt;code&gt;self&lt;/code&gt; (similar to the existing Tower &lt;a href&#x3D;&quot;https://docs.rs/tower/latest/tower/trait.Service.html&quot;&gt;&lt;code&gt;Service&lt;/code&gt;&lt;/a&gt; trait):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LaunchService {
    fn launch(
        &amp;amp;mut self, 
        request: Request,
    ) -&amp;gt; impl Future&amp;lt;Output &#x3D; u32&amp;gt;;
    //   -------------------------
    //   Does not capture &#x60;self&#x60; as it does
    //   not include a &#x60;+ &#x27;_&#x60;.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since &lt;code&gt;async fn&lt;/code&gt; is sugar for a regular function returning &lt;code&gt;impl Future&lt;/code&gt;, these two syntactic forms will work interchangeably.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait HealthCheck {
    async fn check(&amp;amp;mut self) -&amp;gt; bool;
}

impl HealthCheck for MyType {
    fn check(&amp;amp;mut self) -&amp;gt; impl Future&amp;lt;Output &#x3D; bool&amp;gt; + &#x27;_ { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though the need for &amp;quot;impl trait in traits&amp;quot; comes up a lot in async, they are a general feature that will be useful in many contexts having nothing to do with async (for example, returning iterators from trait methods).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Status:&lt;/strong&gt; Return-position impl trait in traits have an experimental implementation and are described in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3425&quot;&gt;RFC 3425&lt;/a&gt;, which is currently open. This feature can stand on its own, but is an important part of the picture for &lt;code&gt;async fn&lt;/code&gt; in traits.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;75cfc199cc50a111576c2d8e342ae823&quot;&gt;Playground&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#evaluating-the-mvp&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;evaluating-the-mvp&quot;&gt;&lt;/a&gt;Evaluating the MVP&lt;/h2&gt;
&lt;p&gt;To evaluate the utility of this MVP, the working group collected &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies.html&quot;&gt;five case studies&lt;/a&gt; covering the &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/builder-provider-api.html#dynamic-dispatch-behind-the-api&quot;&gt;builder-provider pattern used in the AWS SDK&lt;/a&gt;; the potential use of async function in traits in &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/tower.html&quot;&gt;tower&lt;/a&gt; and the actual use in &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/embassy.html&quot;&gt;embassy&lt;/a&gt;, the &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/socket-handler.html&quot;&gt;Fuchsia networking stack&lt;/a&gt; and &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/microsoft.html&quot;&gt;an internal Microsoft tool&lt;/a&gt;. These studies validated that the above functionality is sufficient to use async function in traits for all kinds of things, though some situations require workarounds (hence the &amp;quot;MVP&amp;quot; title).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-the-mvp-will-not-support-or-wont-support-well&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-the-mvp-will-not-support-or-wont-support-well&quot;&gt;&lt;/a&gt;What the MVP will not support or won&#x27;t support well&lt;/h2&gt;
&lt;p&gt;The case studies revealed two situations that the MVP doesn&#x27;t support very well, but both of them have workarounds available. These workarounds are mechanical and once the MVP is available on stable it will be possible to automate them via a custom derive or other crates on crates.io.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#modeling-dynamic-dispatch&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;modeling-dynamic-dispatch&quot;&gt;&lt;/a&gt;Modeling dynamic dispatch&lt;/h3&gt;
&lt;p&gt;In the MVP, traits that use async functions are not &amp;quot;dyn safe&amp;quot;, meaning that they don&#x27;t support dynamic dispatch. So e.g. given the &lt;code&gt;HealthCheck&lt;/code&gt; trait we saw earlier, one could not write &lt;code&gt;Box&amp;lt;dyn HealthCheck&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;At first, this seems like a crucial limitation, since many of the use cases require dynamic dispatch! But it turns out that there is a workaround. One can define an &amp;quot;erased&amp;quot; trait internally to your crate that enables dynamic dispatch. The process was pioneered by crates like &lt;a href&#x3D;&quot;https://github.com/dtolnay/erased-serde&quot;&gt;erased serde&lt;/a&gt; and is explained in detail in the &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/evaluation/case-studies/builder-provider-api.html#dynamic-dispatch-behind-the-api&quot;&gt;builder-provider case study&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To make this workaround easier in the near term, we plan to provide a proc macro to automate it. In the future, async fn &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/explainer/user_guide_future.html#dynamic-dispatch-and-async-functions&quot;&gt;should work&lt;/a&gt; with &lt;code&gt;dyn Trait&lt;/code&gt; directly.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#send-bounds-are-verbose-especially-for-traits-with-lots-of-methods&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;send-bounds-are-verbose-especially-for-traits-with-lots-of-methods&quot;&gt;&lt;/a&gt;Send bounds are verbose, especially for traits with lots of methods&lt;/h3&gt;
&lt;p&gt;The associated return type proposal works great for traits with a single method, but it can be annoying for traits that have lots of methods. One convenient solution is to use the &amp;quot;trait alias pattern&amp;quot;:&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait SendHealthCheck
where
    Self: HealthCheck + Send,
    Self::check(): Send,
{}

impl&amp;lt;T&amp;gt; SendHealthCheck for T
where
    T: HealthCheck + Send,
    T::check(): Send,
{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using a pattern like this means you can write &lt;code&gt;T: SendHealthCheck&lt;/code&gt;. We plan to provide a proc macro to write these trait aliases for you, so you can write something more like this instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[make_alias(Send &#x3D; &amp;quot;SendHealthCheck&amp;quot;)]
trait HealthCheck {
    async fn check(&amp;amp;mut self) -&amp;gt; bool;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the future, something like &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2023/03/03/trait-transformers-send-bounds-part-3/&quot;&gt;trait transformers&lt;/a&gt; may provide a more concise syntax without a proc macro. But because there are use cases that require the kind of fine-grained control provided by associated return types, we opted to stabilize them first and consider more concise syntaxes after gaining experience.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#timeline-and-roadmap&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;timeline-and-roadmap&quot;&gt;&lt;/a&gt;Timeline and roadmap&lt;/h2&gt;
&lt;p&gt;Our goal is to stabilize the MVP for Rust 1.74, which will be released on 2023-11-16. The branch window for this feature opens on July 14 and closes on August 24. To actually stabilize in 1.74, we want to leave room for bug fixes that may arise before the release branch is cut. The key milestones for this goal are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[x] MVP implementation&lt;/li&gt;
&lt;li&gt;[x] Case study evaluations complete&lt;/li&gt;
&lt;li&gt;[ ] Accepted RFC for return-position impl trait (target: 2023-05-31)&lt;/li&gt;
&lt;li&gt;[ ] Accepted RFC for associated return types (target: 2023-06-15)&lt;/li&gt;
&lt;li&gt;[ ] Evaluation period and bug fixing (target: 2023-06-30)&lt;/li&gt;
&lt;li&gt;[ ] Stabilization report authored (target: 2023-07-01)&lt;/li&gt;
&lt;li&gt;[ ] Stabilization complete for 1.74.0 (target: 2023-07-21)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find the &lt;a href&#x3D;&quot;https://github.com/orgs/rust-lang/projects/28/views/2&quot;&gt;complete timeline in our github project&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-comes-next&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-comes-next&quot;&gt;&lt;/a&gt;What comes next?&lt;/h2&gt;
&lt;p&gt;So, once this MVP is done, what next? Our next immediate goals are to ship &lt;strong&gt;dynamic dispatch&lt;/strong&gt; and &lt;strong&gt;async closures&lt;/strong&gt; support in 2024. Together this will complete a solid foundation to tackle future async problems, such as support for async drop, easy async iterators, or portability across runtimes.&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;If &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/41517&quot;&gt;RFC 1733&lt;/a&gt; were stabilized, this would be easier. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Niko Matsakis and Tyler Mandry</name>
        </author>
    </entry>
    
    <entry>
        <title>Postmortem Analysis in Cargo</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/05/01/cargo-postmortem.html" type="text/html" title="Postmortem Analysis in Cargo" />
        <published>2023-05-01T00:00:00+00:00</published>
        <updated>2023-05-01T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/05/01/cargo-postmortem.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/05/01/cargo-postmortem.html">&lt;p&gt;At 01:52 UTC, 2022-10-28, &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/pull/11183&quot;&gt;rust-lang/cargo#11183&lt;/a&gt; was merged into the Cargo master branch. It introduced a bug that caused Cargo to fail to build packages that use a particular, but very common, dependency setup. The change nearly made its way into the next nightly release. If it had, it would have rendered any of the 30k crates with &lt;code&gt;serde_derive&lt;/code&gt; as a dependency (one of the most popular crate on crates.io) unbuildable for anyone using the resulting nightly release.&lt;/p&gt;
&lt;p&gt;Following this incident, the Cargo team went through a postmortem analysis, as is appropriate for incidents with (a potential for) broad blast-radius or otherwise significant impact. This time around, we followed a particular structured postmortem template in the hopes that it might make the resulting write-up more thorough, insightful, and actionable, and we ultimately found that it gave us a better understanding of the underlying root causes and failing/missing safe-guards. So, we wanted to share our experience with other Rust teams in case they may find it similarly useful, either in part or as a whole.&lt;/p&gt;
&lt;p&gt;The postmortem template consists of four parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;What happened:&lt;/strong&gt; a summary that provides context for the event, including metrics or graphs that illustrate the impact of the event if available. This should include a summary of any user-facing impacts or experience during the event.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How we responded:&lt;/strong&gt; a timeline that describes all the events that occurred during the incident including specific date/time to the extent that they are known, as well as answers to the following four questions:
&lt;ul&gt;
&lt;li&gt;How was the event detected?&lt;/li&gt;
&lt;li&gt;How could time to detection be improved?&lt;/li&gt;
&lt;li&gt;How did you reach the point where you knew how to mitigate the impact?&lt;/li&gt;
&lt;li&gt;How could time to mitigation be improved?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Why the event happened:&lt;/strong&gt; this is the juicy part. Here, we use the &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Five_whys&quot;&gt;Five Whys&lt;/a&gt; approach to dig deeply down until the incident’s root causes are identified. Each answer is meant to spawn one or more why questions, until you’re confident that the left answers are fundamentally root causes. It’s also worth pointing out explicitly that “operator error” is &lt;strong&gt;never&lt;/strong&gt; a root cause, and that this is not a process for assigning blame. Instead, any operator error is a symptom of a missing or broken mechanism, and the answers should focus on identifying those inadequate mechanisms.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;How to fix it:&lt;/strong&gt; The outcome of the Five Whys exercise is a list of root causes that should be addressed to reduce the risk of a similar incident in the future. From these root causes, we produce short- and medium-term “action items” along with specific owners wherever possible. Long-term solutions can be discussed too, although the focus of action items should be on more immediate mitigation steps that will be taken relatively soon. Each action item is assigned a priority, and is then generally turned into a GitHub issue where applicable. Any items identified as urgent we start working on immediately, while other action items usually fall into the categories “soon” or “once feasible”.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Note: to ensure the focus stays on mechanisms and processes, not individuals, individuals should not be named unless absolutely necessary. Use terms like &amp;quot;a contributor&amp;quot;, &amp;quot;the maintainer&amp;quot;, &amp;quot;a libs team member&amp;quot;, etc.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So, without further ado, here is &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/issues/12064&quot;&gt;the postmortem for the aforementioned Cargo incident&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Jon Gjengset and Weihang Lo</name>
        </author>
    </entry>
    
    <entry>
        <title>1.69.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/04/17/1.69.0-prerelease.html" type="text/html" title="1.69.0 pre-release testing" />
        <published>2023-04-17T00:00:00+00:00</published>
        <updated>2023-04-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/04/17/1.69.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/04/17/1.69.0-prerelease.html">&lt;p&gt;The 1.69.0 pre-release is ready for testing. The release is scheduled for
April 20. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1690-2023-04-20&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-04-17/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-04-17/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-69-0-pre-release-testing/18692&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>A note on the Trademark Policy Draft</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html" type="text/html" title="A note on the Trademark Policy Draft" />
        <published>2023-04-12T00:00:00+00:00</published>
        <updated>2023-04-12T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html">&lt;h1&gt;&lt;a href&#x3D;&quot;#a-note-on-the-trademark-policy-draft&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-note-on-the-trademark-policy-draft&quot;&gt;&lt;/a&gt;A note on the Trademark Policy Draft&lt;/h1&gt;
&lt;p&gt;For the past eight months, the Rust Foundation Project Directors have been working with the informal Trademark Working Group and the Foundation staff to draft an updated policy and FAQ for the Rust trademark. We&#x27;d like to provide some context around this work and address the community response to the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt; for the recently circulated draft.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#background&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;
&lt;p&gt;Back when the Rust Foundation was created, one of the first things to happen was Mozilla transferring its ownership of the Rust trademark to the newly created foundation. An update to the &lt;a href&#x3D;&quot;http://web.archive.org/web/20230407100922/https://foundation.rust-lang.org/policies/logo-policy-and-media-guide/&quot;&gt;existing policy&lt;/a&gt; was needed, and project leadership planned for this to be done together with the Foundation.&lt;/p&gt;
&lt;p&gt;Since we wanted to incorporate community input to this policy and make it accessible as possible, the board waited until the Foundation was well-staffed to coordinate the effort. That included things like running a &lt;a href&#x3D;&quot;https://foundation.rust-lang.org/news/2022-08-09-trademark-policy-review-and-survey/&quot;&gt;community-wide survey&lt;/a&gt; and discussing the result with a number of stakeholders, including the board, community members, project leadership, as well as legal counsel. The latest state of this process is the draft that was published late last week.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#our-approach&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;our-approach&quot;&gt;&lt;/a&gt;Our approach&lt;/h2&gt;
&lt;p&gt;Since the draft was announced, we&#x27;ve noticed a widespread impression that this policy was created solely by the Foundation and is being imposed on the Rust Project and community. That is not true. The policy draft was created with the input and consent of each of the co-authors of this post, with the intent to clarify existing policies, incorporate community feedback, and preserve the Rust brand for years to come. The Foundation also cannot – and has no interest in – unilaterally adopting such a policy without the agreement and involvement of its Project Directors.&lt;/p&gt;
&lt;p&gt;There can be wildly differing opinions on how to achieve a particular intent.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; Fundamentally however, the question at hand is whether we want Rust to be a trademark or not. If we want to be able to defend Rust as the brand it is today, trademark law fundamentally constrains how permissible we can be, especially in public guidelines.&lt;/p&gt;
&lt;p&gt;Our answer to the question of whether Rust should be a trademark has been &amp;quot;yes&amp;quot;, just as it has been since before Rust 1.0. Furthermore, our goal is to make a policy that is as permissive as it can be without substantially giving up our right to define what Rust &lt;em&gt;is&lt;/em&gt; and &lt;em&gt;is not&lt;/em&gt; in the future. Not all open source projects have retained that right.&lt;/p&gt;
&lt;p&gt;We aren&#x27;t lawyers and we leave the question of &lt;em&gt;how&lt;/em&gt; to do that to them – and believe us when we say we have gone through &lt;em&gt;many&lt;/em&gt; rounds of questions with ours, who have extensive experience in open source projects.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#feedback&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;feedback&quot;&gt;&lt;/a&gt;Feedback&lt;/h2&gt;
&lt;p&gt;The current proposal is a draft that the Foundation staff, Project Directors, and Trademark Working Group are actively seeking feedback on. We will not ship a trademark policy that Project representatives and the Foundation aren&#x27;t happy with and proud of after reviewing community feedback.&lt;/p&gt;
&lt;p&gt;We genuinely appreciate all the thoughtful input the community has already left, both in public and via the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt;.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; Please continue to utilize this form as the official way of getting feedback back into this process. We know the draft is not perfect, and we&#x27;re committed to fixing any mistakes identified and considering the feedback we get.&lt;/p&gt;
&lt;p&gt;Unfortunately, in addition to the large volume of thoughtful and respectful feedback, we&#x27;re ashamed to say we&#x27;ve seen firsthand examples of significant harassment and abuse directed at the Foundation staff. &lt;strong&gt;We condemn this in the strongest possible terms.&lt;/strong&gt; These folks have been doing their best to navigate an extremely diverse set of interests and viewpoints throughout this process. It&#x27;s unacceptable for anyone in the Rust community to demean, harass or insult anyone, let alone the people we&#x27;ve asked to do this work.&lt;/p&gt;
&lt;p&gt;Please remember that any and all communication with Foundation staff is subject to the Rust project &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/code-of-conduct&quot;&gt;Code of Conduct&lt;/a&gt; and will be enforced accordingly. We don&#x27;t expect this to be an issue for most people participating, but when emotions run high it&#x27;s always a good idea to check your assumptions and remember the person on the other end of the keyboard.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#next-steps&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;next-steps&quot;&gt;&lt;/a&gt;Next steps&lt;/h2&gt;
&lt;p&gt;We want to thank the community for participating in this process, and for your patience as we learn the best way to navigate it. We recognize that the process and communication around it could have been better. Notably, the wider project was insufficiently included in the process. We were  responsible for that and apologize.&lt;/p&gt;
&lt;p&gt;We&#x27;re committed to learning everything we can from this process and your feedback, and to talking as openly as we can about what we&#x27;ve learned. To that end, we will soon conduct and publish a retrospective around how the process unfolded.&lt;/p&gt;
&lt;p&gt;Thank you again to those who have shared their thoughts on the Rust Trademark Policy draft respectfully. A summary of the feedback received will be shared after the consultation period closes. If you have not yet reviewed the draft, we invite you to fill out the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt; by April 16 at 5 PM PDT. We only ask that you treat everyone in this community, including the Rust Foundation team, respectfully when doing so.&lt;/p&gt;
&lt;p&gt;Sincerely,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ryan Levick, Project Director and trademark working group member&lt;/li&gt;
&lt;li&gt;Jane Losare-Lusby, Project Director&lt;/li&gt;
&lt;li&gt;Tyler Mandry, Project Director&lt;/li&gt;
&lt;li&gt;Mark Rousskov, Project Director&lt;/li&gt;
&lt;li&gt;Josh Stone, Project Director and trademark working group member&lt;/li&gt;
&lt;li&gt;Josh Triplett, Lang team lead and trademark working group member&lt;/li&gt;
&lt;/ul&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;This was none more apparent than when the community survey got over 1,000 responses, representing a number of popular but fundamentally incompatible views. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;We know this feedback-via-form exercise is not familiar, and we&#x27;re still getting used to it, too. But it&#x27;s really the best we can do when we&#x27;re asking a heroic staff to read and respond to the feedback, and when it&#x27;s a legal matter where what we say can have substantial consequences down the line. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Ryan Levick, Jane Losare-Lusby, Tyler Mandry, Mark Rousskov, Josh Stone, and Josh Triplett</name>
        </author>
    </entry>
    
    <entry>
        <title>Welcome Arlo and Scott to the Cargo Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html" type="text/html" title="Welcome Arlo and Scott to the Cargo Team" />
        <published>2023-04-06T00:00:00+00:00</published>
        <updated>2023-04-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html">&lt;p&gt;We are excited to welcome &lt;a href&#x3D;&quot;https://github.com/arlosi&quot;&gt;Arlo Siemsen&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/Muscraft&quot;&gt;Scott Schafer&lt;/a&gt; as new members to the Cargo Team!&lt;/p&gt;
&lt;p&gt;Arlo has been instrumental in bringing Cargo&#x27;s new &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html&quot;&gt;sparse registry&lt;/a&gt; support to fruition, which significantly improves registry performance. He has been involved with registry design and authentication discussions, and has been closely working with the team over the past year.&lt;/p&gt;
&lt;p&gt;Scott has been very active in the past year, working on various parts of Cargo, namely implementing &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table&quot;&gt;workspace inheritance&lt;/a&gt;. Since then, he has been helping with maintenance and designing new features.&lt;/p&gt;
&lt;p&gt;With their help we now have capacity to start thinking about how feature development should be done moving forward. We are still in early discussions of processes for matching feature development with reviewer capacity, and will share more in the future. Thanks to Arlo and Scott for their help, and we are very much looking forward to having them as a part of the team!&lt;/p&gt;
</content>

        <author>
            <name>Eric Huss</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.2 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html" type="text/html" title="1.68.2 pre-release testing" />
        <published>2023-03-27T00:00:00+00:00</published>
        <updated>2023-03-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html">&lt;p&gt;The 1.68.2 pre-release is ready for testing. The release is scheduled for
March 28. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1682-2023-03-28&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-27/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-27/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-2-pre-release-testing/18585&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.1 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html" type="text/html" title="1.68.1 pre-release testing" />
        <published>2023-03-20T00:00:00+00:00</published>
        <updated>2023-03-20T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html">&lt;p&gt;The 1.68.1 pre-release is ready for testing. The release is scheduled for
March 23. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1681-2023-03-23&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-20/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-20/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-1-pre-release-testing/18547&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html" type="text/html" title="1.68.0 pre-release testing" />
        <published>2023-03-06T00:00:00+00:00</published>
        <updated>2023-03-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html">&lt;p&gt;The 1.68.0 pre-release is ready for testing. The release is scheduled for
March 09. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1680-2023-03-09&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-06/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-06/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-0-pre-release-testing/18481&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Keyword Generics Progress Report: February 2023</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html" type="text/html" title="Keyword Generics Progress Report: February 2023" />
        <published>2023-02-23T00:00:00+00:00</published>
        <updated>2023-02-23T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#introduction&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;
&lt;p&gt;About 9 months ago &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html&quot;&gt;we announced&lt;/a&gt; the creation of the Keyword Generics
Initiative; a group working under the lang team with the intent to solve the
&lt;a href&#x3D;&quot;https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/&quot;&gt;function coloring problem&lt;/a&gt; &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; through the type system not just for
&lt;code&gt;async&lt;/code&gt;, but for &lt;code&gt;const&lt;/code&gt; and all current and future function modifier keywords
as well.&lt;/p&gt;
&lt;p&gt;We&#x27;re happy to share that we&#x27;ve made a lot of progress over these last several
months, and we&#x27;re finally ready to start putting some of our designs forward through
RFCs. Because it&#x27;s been a while since our last update, and because we&#x27;re excited
to share what we&#x27;ve been working on, in this post we&#x27;ll be going over some of the things
we&#x27;re planning to propose.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#an-async-example&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;an-async-example&quot;&gt;&lt;/a&gt;An async example&lt;/h2&gt;
&lt;p&gt;In our &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html&quot;&gt;previous post&lt;/a&gt; we introduced the placeholder &lt;code&gt;async&amp;lt;A&amp;gt;&lt;/code&gt; syntax to describe the
concept of a &amp;quot;function which is generic over its asyncness&amp;quot;. We always knew we
wanted something that felt lighter weight than that, so in for our current design
we&#x27;ve chosen to drop the notion of a generic parameter for the end-user syntax,
and instead picked the &lt;code&gt;?async&lt;/code&gt; notation. We&#x27;ve borrowed this from the trait
system, where for example &lt;code&gt;+ ?Sized&lt;/code&gt; indicates that something may or may not
implement the &lt;code&gt;Sized&lt;/code&gt; trait. Similarly &lt;code&gt;?async&lt;/code&gt; means a function may or may not be
async. We also refer to these as &amp;quot;maybe-async&amp;quot; functions.&lt;/p&gt;
&lt;p&gt;Time for an example. Say we took the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/io/trait.Read.html&quot;&gt;&lt;code&gt;Read&lt;/code&gt; trait&lt;/a&gt; and the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/io/fn.read_to_string.html&quot;&gt;read_to_string_methods&lt;/a&gt;. In the stdlib their implementations look somewhat
like this today:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Read {
    fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { ... }
}

/// Read from a reader into a string.
fn read_to_string(reader: &amp;amp;mut impl Read) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string)?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, what if we wanted to make these async in the future? Using &lt;code&gt;?async&lt;/code&gt;
notation we could change them to look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait ?async Read {
    ?async fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    ?async fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { ... }
}

/// Read from a reader into a string.
?async fn read_to_string(reader: &amp;amp;mut impl ?async Read) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).await?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The way this would work is that &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; would become generic over
their &amp;quot;asyncness&amp;quot;. When compiled for an &lt;code&gt;async&lt;/code&gt; context, they will behave
asynchronously. When compiled in a non-async context, they will behave
synchronously. The &lt;code&gt;.await&lt;/code&gt; in the &lt;code&gt;read_to_string&lt;/code&gt; function body is necessary
to mark the cancellation point in case the function is compiled as async; but
when not async would essentially become a no-op &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// &#x60;read_to_string&#x60; is inferred to be &#x60;!async&#x60; because
// we didn&#x27;t &#x60;.await&#x60; it, nor expected a future of any kind.
#[test]
fn sync_call() {
    let _string &#x3D; read_to_string(&amp;quot;file.txt&amp;quot;)?;
}

// &#x60;read_to_string&#x60; is inferred to be &#x60;async&#x60; because
// we &#x60;.await&#x60;ed it.
#[async_std::test]
async fn async_call() {
    let _string &#x3D; read_to_string(&amp;quot;file.txt&amp;quot;).await?;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We expect &lt;code&gt;?async&lt;/code&gt; notation would be most useful for library code which doesn&#x27;t
do anything particularly specific to async Rust. Think: most of the stdlib, and
ecosystem libraries such as parsers, encoders, and drivers. We expect most
applications to choose to be compiled either as async or non-async, making them
mostly a consumer of &lt;code&gt;?async&lt;/code&gt; APIs.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-const-example&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-const-example&quot;&gt;&lt;/a&gt;A const example&lt;/h2&gt;
&lt;p&gt;A main driver of the keywords generics initiative has been our desire to make the
different modifier keywords in Rust feel consistent with one another. Both the
const WG and the async WG were thinking about introducing keyword-traits at the
same time, and we figured we should probably start talking with each other to make
sure that what we were going to introduce felt like it was part of the same
language - and could be extended to support more keywords in the future.&lt;/p&gt;
&lt;p&gt;So with that in mind, it may be unsurprising that for the maybe-&lt;code&gt;const&lt;/code&gt; trait
bounds and declarations we&#x27;re going to propose using the &lt;code&gt;?const&lt;/code&gt; notation.
A common source of confusion with &lt;code&gt;const fn&lt;/code&gt; is that it actually doesn&#x27;t
guarantee compile-time execution; it only means that it&#x27;s &lt;em&gt;possible&lt;/em&gt; to evaluate
in a &lt;code&gt;const&lt;/code&gt; compile-time context. So in a way &lt;code&gt;const fn&lt;/code&gt; has always been a way
of declaring a &amp;quot;maybe-const&amp;quot; function, and there isn&#x27;t a way to declare an
&amp;quot;always-const&amp;quot; function. More on that later in this post.&lt;/p&gt;
&lt;p&gt;Taking the &lt;code&gt;Read&lt;/code&gt; example we used earlier, we could imagine a &amp;quot;maybe-const&amp;quot; version
of the &lt;code&gt;Read&lt;/code&gt; trait to look very similar:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait ?const Read {
    ?const fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    ?const fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which we could then use use as a bound in the const &lt;code&gt;read_to_string&lt;/code&gt; function,
like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;const fn read_to_string(reader: &amp;amp;mut impl ?const Read) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string)?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just like with &lt;code&gt;?async&lt;/code&gt; traits, &lt;code&gt;?const&lt;/code&gt; traits would also need to be labeled as
&lt;code&gt;?const&lt;/code&gt; when used as a bound. This is important to surface at the trait level,
because it&#x27;s allowed to pass non-const bounds to maybe-const functions, as long
as no trait methods are called in the function body. This means we need to
distinguish between &amp;quot;never-const&amp;quot; and &amp;quot;maybe-const&amp;quot;.&lt;/p&gt;
&lt;p&gt;You may have noticed the &lt;code&gt;?const&lt;/code&gt; on the trait declaration and the extra
&lt;code&gt;?const&lt;/code&gt; on the trait methods. This is on purpose: it keeps the path open to
potentially add support for &amp;quot;always-const&amp;quot; or &amp;quot;never-const&amp;quot; methods on traits as
well. In &lt;code&gt;?async&lt;/code&gt; we know that even if the entire trait is &lt;code&gt;?async&lt;/code&gt;, some
methods (such as &lt;code&gt;Iterator::size_hint&lt;/code&gt;) will never be async. And this would
make &lt;code&gt;?const&lt;/code&gt; and &lt;code&gt;?async&lt;/code&gt; traits behave similarly using the same rules.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#combining-const-and-async&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;combining-const-and-async&quot;&gt;&lt;/a&gt;Combining const and async&lt;/h2&gt;
&lt;p&gt;We&#x27;ve covered &lt;code&gt;?async&lt;/code&gt;, and we&#x27;ve covered &lt;code&gt;?const&lt;/code&gt;. Now what happens if we were
to use them together? Let&#x27;s take a look at what the &lt;code&gt;Read&lt;/code&gt; trait would look like
when if we extended it using our designs for &lt;code&gt;?const&lt;/code&gt; and &lt;code&gt;?async&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait ?const ?async Read {
    ?const ?async fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    ?const ?async fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { .. }
}

/// Read from a reader into a string.
const ?async fn read_to_string(reader: &amp;amp;mut impl ?const ?async Read) -&amp;gt; io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).await?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That&#x27;s sure starting to feel like a lot of keywords, right? We&#x27;ve accurately
described exactly what&#x27;s going on, but there&#x27;s a lot of repetition. We know that
if we&#x27;re dealing with a &lt;code&gt;const ?async fn&lt;/code&gt;, most arguments probably will
want to be &lt;code&gt;?const ?async&lt;/code&gt;. But under the syntax rules we&#x27;ve proposed so far,
you&#x27;d end up repeating that everywhere. And it probably gets worse once we start
adding in more keywords. Not ideal!&lt;/p&gt;
&lt;p&gt;So we&#x27;re very eager to make sure that we find a solution to this. And we&#x27;ve been
thinking about a way we could get out of this, which we&#x27;ve been calling
&lt;code&gt;effect/.do&lt;/code&gt;-notation. This would allow you to mark a function as &amp;quot;generic over
all modifier keywords&amp;quot; by annotating it as &lt;code&gt;effect fn&lt;/code&gt;, and it would allow the
compiler to insert all the right &lt;code&gt;.await&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;yield&lt;/code&gt; keywords in the
function body by suffixing function calls with &lt;code&gt;.do&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Just to set some expectations: this is the least developed part of our proposal,
and we don&#x27;t intend to formally propose this until after we&#x27;re done with some of
the other proposals. But we think it&#x27;s an important part of the entire vision,
so we wanted to make sure we shared it here. And with that out of the way,
here&#x27;s the same example we had above, but this time using the &lt;code&gt;effect/.do&lt;/code&gt;-notation:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait ?effect Read {
    ?effect fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    ?effect fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { .. }
}

/// Read from a reader into a string.
?effect fn read_to_string(reader: &amp;amp;mut impl ?effect Read) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).do;  // note the singular &#x60;.do&#x60; here
    string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the things we would like to figure out as part of &lt;code&gt;effect/.do&lt;/code&gt; is a way
to enable writing conditional effect-bounds. For example: there may be a
function which is always async, may never panic, and is generic over the
remainder of the effects. Or like we&#x27;re seeing with APIs such as
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;Vec::reserve&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve&quot;&gt;&lt;code&gt;Vec::try_reserve&lt;/code&gt;&lt;/a&gt;: the ability to panic xor return an
error. This will take more time and research to figure out, but we believe it
is something which can be solved.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#adding-support-for-types&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;adding-support-for-types&quot;&gt;&lt;/a&gt;Adding support for types&lt;/h2&gt;
&lt;p&gt;Something we&#x27;re keen on doing is not just adding support for &lt;code&gt;?async&lt;/code&gt; and to
apply to functions, traits, and trait bounds. We would like &lt;code&gt;?async&lt;/code&gt; to be
possible to use with types as well. This would enable the ecosystem to stop
having to provide both sync and async versions of crates. It would also enable
the stdlib to gradually &amp;quot;asyncify&amp;quot; just like we have been with const.&lt;/p&gt;
&lt;p&gt;The challenge with async types, especially in the stdlib, is that their behavior
will often have to be different when used in async and non-async contexts. At
the very lowest level async system calls work a bit differently from non-async
system calls. But we think we may have a solution for that too in the form of
the &lt;code&gt;is_async&lt;/code&gt; compiler built-in method.&lt;/p&gt;
&lt;p&gt;Say we wanted to implement &lt;code&gt;?async File&lt;/code&gt; with a single &lt;code&gt;?async open&lt;/code&gt; method. The
way we expect this to look will be something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;/// A file which may or may not be async
struct ?async File {
    file_descriptor: std::os::RawFd,  // shared field in all contexts
    async waker: Waker,               // field only available in async contexts
    !async meta: Metadata,            // field only available in non-async contexts
}

impl ?async File {
    /// Attempts to open a file in read-only mode.
    ?async fn open(path: Path) -&amp;gt; io::Result&amp;lt;Self&amp;gt; {
        if is_async() {   // compiler built-in function
            // create an async &#x60;File&#x60; here; can use &#x60;.await&#x60;
        } else {
            // create a non-async &#x60;File&#x60; here
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would enable authors to use different fields depending on whether they&#x27;re
compiling for async or not, while still sharing a common core. And within
function bodies it would be possible to provide different behaviors depending on
the context as well. The function body notation would work as a generalization
of the currently unstable &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/intrinsics/fn.const_eval_select.html&quot;&gt;&lt;code&gt;const_eval_select&lt;/code&gt;&lt;/a&gt; intrinsic, and at
least for the function bodies we expect a similar &lt;code&gt;is_const()&lt;/code&gt; compiler built-in
to be made available as well.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#consistent-syntax&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;consistent-syntax&quot;&gt;&lt;/a&gt;Consistent syntax&lt;/h2&gt;
&lt;p&gt;As we alluded to earlier in the post: one of the biggest challenges we see in
language design is adding features in a way that makes them feel like they&#x27;re in
harmony with the rest of the language - and not something which stands out as
noticably different. And because we&#x27;re touching on something core to Rust, the
way we do keywords, we have to pay extra close attention here to make sure Rust
keeps feeling like a single language.&lt;/p&gt;
&lt;p&gt;Luckily Rust has the ability to make surface-level changes to the
language through the edition system. There are many things this doesn&#x27;t let us
do, but it does allow us to require syntax changes. A possibility we&#x27;re
exploring is leveraging the edition system to make some minor changes to &lt;code&gt;const&lt;/code&gt;
and &lt;code&gt;async&lt;/code&gt; so they feel more consistent with one another, and with &lt;code&gt;?const&lt;/code&gt; and
&lt;code&gt;?async&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;const&lt;/code&gt; this means there should be a syntactic distinction between &lt;code&gt;const&lt;/code&gt;
declarations and &lt;code&gt;const&lt;/code&gt; uses. Like we mentioned earlier in the post, when you
write &lt;code&gt;const fn&lt;/code&gt; you get a function which can be evaluated both at runtime and
during compilation. But when you write &lt;code&gt;const FOO: () &#x3D; ..;&lt;/code&gt; the meaning of
&lt;code&gt;const&lt;/code&gt; there guarantees compile-time evaluation. One keyword, different
meanings. So for that reason we&#x27;re wondering whether perhaps it would make more
sense if we changed &lt;code&gt;const fn&lt;/code&gt; to &lt;code&gt;?const fn&lt;/code&gt;.  This would make it clear that
it&#x27;s a function which &lt;em&gt;may&lt;/em&gt; be const-evaluated, but doesn&#x27;t necessarily have to -
and can also be called from non-&lt;code&gt;const&lt;/code&gt; contexts.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;//! Define a function which may be evaluated both at runtime and during
//! compilation.

// Current
const fn meow() -&amp;gt; String { .. }

// Proposed
?const fn meow() -&amp;gt; String { .. }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For &lt;code&gt;async&lt;/code&gt; we&#x27;re considering some similar surface-level changes.  The Async WG
is in the process of expanding the &amp;quot;async functions in traits&amp;quot; design into an
design covering &amp;quot;async traits&amp;quot; entirely, largely motivated by the desire to be
able to add &lt;code&gt;+ Send&lt;/code&gt; bound to anonymous futures. There are more details about
this in &lt;a href&#x3D;&quot;https://blog.theincredibleholk.org/blog/2023/02/16/lightweight-predictable-async-send-bounds/&quot;&gt;&amp;quot;Lightweight, Predictable Async Send Bounds&amp;quot;&lt;/a&gt; by Eric
Holk. But it would roughly become the following notation:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct File { .. }
impl async Read for File {                                                // async trait declaration
    async fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;usize&amp;gt; { .. }  // async method
}

async fn read_to_string(reader: &amp;amp;mut impl async Read) -&amp;gt; io::Result&amp;lt;String&amp;gt; { // async trait bound
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).await?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would make &lt;code&gt;impl ?async Read&lt;/code&gt; and &lt;code&gt;impl async Read&lt;/code&gt; consistent with each
other. And it would open the door for &lt;code&gt;trait ?async&lt;/code&gt; traits to be passed to
&lt;code&gt;impl async Read&lt;/code&gt; and be guaranteed to be always interpreted as &lt;code&gt;trait async&lt;/code&gt;.
Which is another nice consistency gain.&lt;/p&gt;
&lt;p&gt;The final thing we&#x27;re looking at is &lt;code&gt;async&lt;/code&gt;-notation for types. To implement
inherent &lt;code&gt;?async&lt;/code&gt; methods on types, our current design requires the type to also
be marked as &lt;code&gt;?async&lt;/code&gt;. In order to bring &lt;code&gt;?async&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt; closer together,
we&#x27;re exploring whether it might also make sense to require types to be marked
as &lt;code&gt;async&lt;/code&gt; as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;//! Proposed: define a method on a maybe-async type
struct ?async File { .. }
impl ?async File {
    ?async fn open(path: PathBuf) -&amp;gt; io::Result&amp;lt;Self&amp;gt; { .. }
}

//! Current: define a method on an always-async type
struct File { .. }
impl File {
    async fn open(path: PathBuf) -&amp;gt; io::Result&amp;lt;Self&amp;gt; { .. }
}

//! Proposed: define a method on an always-async type
struct async File { .. }
impl async File {
    async fn open(path: PathBuf) -&amp;gt; io::Result&amp;lt;Self&amp;gt; { .. }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We already have something similar going on for &amp;quot;always-const&amp;quot; arguments via the
const-generics system. These look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn foo&amp;lt;const N: usize&amp;gt;() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every &amp;quot;always-const&amp;quot; argument to the function must always be marked by &lt;code&gt;const&lt;/code&gt;,
so it wouldn&#x27;t be entirely without precedent for every &amp;quot;always-async&amp;quot; type to
always require to be marked using &lt;code&gt;async&lt;/code&gt;. So we&#x27;re exploring some of what might
be possible here.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-tentative-plan&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-tentative-plan&quot;&gt;&lt;/a&gt;The tentative plan&lt;/h2&gt;
&lt;p&gt;We plan to initially focus our efforts on the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords only.
We&#x27;re feeling ready to start converting some of our designs into RFCs, and start
putting them out for review. In the coming months we expect to start writing
the following proposals (in no particular order):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?async fn&lt;/code&gt; notation without trait bounds, including an &lt;code&gt;is_async&lt;/code&gt; mechanism.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trait async&lt;/code&gt;  declarations and bounds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trait ?async&lt;/code&gt; declarations and bounds, &lt;code&gt;trait ?const&lt;/code&gt; declarations and bounds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?const fn&lt;/code&gt; notation without trait bounds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct async&lt;/code&gt; notation and &lt;code&gt;struct ?const&lt;/code&gt; notation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&#x27;ll be working closely with the Lang Team, Const WG, and Async WG on these
proposals, and in some cases (such as &lt;code&gt;trait async&lt;/code&gt;) we may even take an
advising role with a WG directly driving the RFC. As usual, these will be going
through the RFC-nightly-stabilization cycle. And only once we&#x27;re fully confident
in them will they become available on stable Rust.&lt;/p&gt;
&lt;p&gt;We&#x27;re intentionally not yet including &lt;code&gt;effect/.do&lt;/code&gt; notation on this roadmap. We
expect to only be able to start this work once we have &lt;code&gt;?async&lt;/code&gt; on nightly,
which we don&#x27;t yet have. So for now we&#x27;ll continue work on designing it within
the initiative, and hold off on making plans to introduce it quiet yet.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;And that concludes the 9-month progress report of the Keyword Generics
Initiative. We hope to be able to provide more exact details about things such
as desugarings, semantics, and alternatives in the RFCs. We&#x27;re pretty stoked with the
progress we&#x27;ve made in these past few months! Something which I don&#x27;t think
we&#x27;ve mentioned yet, but is probably good to share: we&#x27;ve actually prototyped
much of the work in this post already; so we&#x27;re feeling fairly confident all of
this may actually &lt;em&gt;actually&lt;/em&gt; work. And that is something we&#x27;re
incredibly excited for!&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;To briefly recap this problem: you can&#x27;t call an &lt;code&gt;async fn&lt;/code&gt; from a
non-async fn. This makes the &amp;quot;async&amp;quot; notation go viral, as every function that
calls it also needs to be async. But we believe possibly more importantly: it
requires a duplication of most stdlib types and ecosystem libraries. Instead we
suspected we might be able to overcome this issue by introducing a new kind of
generic which would enable functions and types to be &amp;quot;generic&amp;quot; over whether
they&#x27;re async or not, const or not, etc. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;One restriction &lt;code&gt;?async&lt;/code&gt; contexts have is that they can
only call other &lt;code&gt;?async&lt;/code&gt; and non-&lt;code&gt;async&lt;/code&gt; functions. Because if we could call an
always-&lt;code&gt;async&lt;/code&gt; function, there would be no clear right thing to do when compiled
in non-async mode. So things like async concurrency operations won&#x27;t directly
work in always-async contexts. But we have a way out of this we talk about later
in the post: &lt;code&gt;if is_async() .. else ..&lt;/code&gt;. This allows you to branch the body of a
&lt;code&gt;?async fn&lt;/code&gt; based on which mode it&#x27;s being compiled in, and will allow you to
write different logic for async and non-async modes. This means you can choose
to use async concurrency in the async version, but keep things sequential in the
non-async version. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Yoshua Wuyts</name>
        </author>
    </entry>
    
</feed>

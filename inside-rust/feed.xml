<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2020-07-21T14:17:44+00:00</updated>

    
    <entry>
        <title>Traits working group 2020 sprint 3 summary</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/07/17/traits-sprint-3.html" type="text/html" title="Traits working group 2020 sprint 3 summary" />
        <published>2020-07-17T00:00:00+00:00</published>
        <updated>2020-07-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/07/17/traits-sprint-3.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/07/17/traits-sprint-3.html">&lt;p&gt;Again? It feels like we just had one of these...6 weeks ago ðŸ˜‰. Anyways, much of this sprint was a continuation of the previous two: working towards making Chalk feature-complete and eventually using it in rustc for trait solving.&lt;/p&gt;
&lt;p&gt;For those who haven't seen one of these before, if you're curious about the traits working group, you can find a summary &lt;a href=&quot;https://rust-lang.github.io/wg-traits/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#credit-where-credit-is-due&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;credit-where-credit-is-due&quot;&gt;&lt;/a&gt;Credit where credit is due&lt;/h3&gt;
&lt;p&gt;As always, a big thanks to everyone who participated in this sprint:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/detrumi&quot;&gt;Wilco Kusee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/flodiebold&quot;&gt;Florian Diebold&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jackh726&quot;&gt;Jack Huey&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/crlf0710&quot;&gt;Charles Lew&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nikomatsakis&quot;&gt;Niko Matsakis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nathanwhit&quot;&gt;Nathan Whitaker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/adamrk&quot;&gt;Adam Bratschi-Kaye&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/super-tuple&quot;&gt;super-tuple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/daboross&quot;&gt;David Ross&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zaharidichev&quot;&gt;Zahari Dichev&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Areredify&quot;&gt;Mikhail Babenko&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Mcat12&quot;&gt;Mark Drobnak&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Aaron1011&quot;&gt;Aaron Hill&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pksunkara&quot;&gt;Pavan Kumar Sunkara&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/doctorn&quot;&gt;Nathan Corbyn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/matthewjasper&quot;&gt;Matthew Jasper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lcnr&quot;&gt;Bastian Kauschke&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#chalk-crate-cleanups-and-weekly-publish&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;chalk-crate-cleanups-and-weekly-publish&quot;&gt;&lt;/a&gt;Chalk crate cleanups and weekly publish&lt;/h3&gt;
&lt;p&gt;Since its inception, Chalk has undergone a fair number of changes in regards to the structure of its crates, as any reasonably sized project might. During this sprint, we took the time to clean up the crate structure a bit. It's probably easiest to just give a brief overview of what we ended up with. A more comprehensive overview can be found in the &lt;a href=&quot;http://rust-lang.github.io/chalk/book/what_is_chalk/crates.html&quot;&gt;Chalk book&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chalk-derive&lt;/code&gt; - Defines the derive proc macros&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chalk-ir&lt;/code&gt; - A basic &amp;quot;type library&amp;quot;, which might someday be shared between rustc, Chalk, and rust-analyzer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chalk-solve&lt;/code&gt; - Defines the Rust semantics of the types from &lt;code&gt;chalk-ir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chalk-engine&lt;/code&gt; - Implements the SLG solver&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chalk-recursive&lt;/code&gt; - Implements the recursive solver&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chalk-parse&lt;/code&gt; - Used for testing, parses a Rust-like syntax into &lt;code&gt;chalk-ir&lt;/code&gt; and &lt;code&gt;chalk-solve&lt;/code&gt; types&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chalk-integration&lt;/code&gt; - Used for testing, provides types useful for testing&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chalk&lt;/code&gt; - Used for testing, provides a REPL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Also during this sprint, we set up regular weekly releases of the Chalk crates. While at the moment these are all &lt;code&gt;0.*.0&lt;/code&gt; patch releases, it sets up the infrastructure for future stable releases and provides published crates to be used in rustc and rust-analyzer. In the future, when Chalk development is more stable, we want to switch this to be manual. We also plan to set up bors to ensure that &lt;code&gt;master&lt;/code&gt; always builds and passes tests.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#work-towards-gat-support-in-rustc&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;work-towards-gat-support-in-rustc&quot;&gt;&lt;/a&gt;Work towards GAT support in rustc&lt;/h3&gt;
&lt;p&gt;Chalk has had support for GATs for &lt;a href=&quot;https://github.com/rust-lang/chalk/pull/145&quot;&gt;a while now&lt;/a&gt;; in Chalk terms, GATs are a natural extension of everything else. &lt;a href=&quot;https://github.com/rust-lang/rust/issues/44265&quot;&gt;GATs in rustc&lt;/a&gt;, however, are a bit more difficult, and have been fairly stagnant over the past couple of years, with the primary focus going towards getting Chalk ready. Recently, however, some work has been done in rustc to get GATs working under the current rustc trait system.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#extracting-a-shared-library-representing-types&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;extracting-a-shared-library-representing-types&quot;&gt;&lt;/a&gt;Extracting a shared library representing types&lt;/h3&gt;
&lt;p&gt;As a long term goal, we hope to one day have a shared type library between Chalk and rustc. Moreover, this type library could be used for other projects, such as rust-analyzer. On the Chalk side, more types â€” such as closures and enums â€” and more traits â€” such as the &lt;code&gt;Fn&lt;/code&gt; family and &lt;code&gt;Unsize&lt;/code&gt; â€” were added. Additionally, some work has been done to go the &lt;em&gt;other direction&lt;/em&gt;: to move rustc closer to Chalk, such as &lt;a href=&quot;https://github.com/rust-lang/rust/pull/72055&quot;&gt;interning &lt;code&gt;Predicate&lt;/code&gt;s&lt;/a&gt;, and &lt;a href=&quot;https://github.com/rust-lang/rust/pull/73503&quot;&gt;introducing &lt;code&gt;ForAll&lt;/code&gt; predicates&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#writing-a-chalk-file-for-debugging&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;writing-a-chalk-file-for-debugging&quot;&gt;&lt;/a&gt;Writing a &lt;code&gt;.chalk&lt;/code&gt; file for debugging&lt;/h3&gt;
&lt;p&gt;As part of Chalk tests, we can write Rust-like &amp;quot;programs&amp;quot; that get parsed into Chalk types. Importantly, these programs are much more succint than the types they get lowered to. As part of an effort to better enable debugging, we implemented a system to go in the opposite direction: to be able to generate the Rust-like programs from the underlying types. This is extremely useful to, for example, debug a bug for a given bit of code that rustc tries to compile. Additionally, this could be used to generate programs for cases with performance problems.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#improving-impl-trait-support&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;improving-impl-trait-support&quot;&gt;&lt;/a&gt;Improving &lt;code&gt;impl Trait&lt;/code&gt; support&lt;/h3&gt;
&lt;p&gt;In the last sprint, we landed initial &lt;code&gt;impl Trait&lt;/code&gt; support, to handle the simple case of something like &lt;code&gt;type Foo&amp;lt;T&amp;gt; = impl Bar&lt;/code&gt;. During this sprint, we began work on adding more support for more complex cases such as &lt;code&gt;type Foo&amp;lt;T&amp;gt;: Debug = impl Bar where T: Debug&lt;/code&gt;. Additionally, some design work was done to support checking that these are well-formed.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#extend-chalk-to-support-rust-semantics&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;extend-chalk-to-support-rust-semantics&quot;&gt;&lt;/a&gt;Extend Chalk to support Rust semantics&lt;/h3&gt;
&lt;p&gt;This goal overlaps a bit with &amp;quot;extracting a shared type library&amp;quot;, but is less about representing types themselves and more about expressing the semantics of those types. For example, consider the following program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;trait Foo: Sized {
    fn foo(self) {}
}
impl Foo for u32 {}
impl Foo for String {}

fn main() {
  let x = 0;
  x.foo();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Prior to the current sprint, Chalk wouldn't be able to handle this properly; it wouldn't know that you can call &lt;code&gt;foo&lt;/code&gt; on &lt;code&gt;0&lt;/code&gt;. In fact, to be able to compile this program correctly, the compiler has to know that &lt;code&gt;0&lt;/code&gt; can never be a &lt;code&gt;String&lt;/code&gt;. Consider what would happen if you changed to impl for &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;u64&lt;/code&gt;: rustc wouldn't know if you wanted &lt;code&gt;0&lt;/code&gt; to be a &lt;code&gt;u32&lt;/code&gt; or an &lt;code&gt;u64&lt;/code&gt;. That's essentially how Chalk would have seen this program prior to this sprint. However, Chalk now correctly handles this situation.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#handle-lifetime-constraints-in-rustc-integration&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;handle-lifetime-constraints-in-rustc-integration&quot;&gt;&lt;/a&gt;Handle lifetime constraints in rustc integration&lt;/h3&gt;
&lt;p&gt;So, as part of trait solving Chalk and rustc may sometimes find one lifetime needs to outlive another, or that a type must outlive a lifetime. For example,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;trait Foo&amp;lt;'a, 'b, T&amp;gt; where 'a: 'b, T: 'a  {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Chalk doesn't solve these lifetime constraints on its own, instead it passes them back to rustc. During this sprint, we added the ability to express these where clauses in Chalk.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#other-work&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;other-work&quot;&gt;&lt;/a&gt;Other work&lt;/h3&gt;
&lt;p&gt;There was a bunch of smaller stuff done during this sprint that doesn't really fit into separate goals. Chalk got a little bit smarter in its suggestions. We introduced &lt;code&gt;tracing&lt;/code&gt; for logging. We did some design work for the recursive solver. And of course, a fair amount of internal refactoring and cleanup. And of course, the rustc integration has been kept up with and updated for newer Chalk features.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#summer-vacation&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;summer-vacation&quot;&gt;&lt;/a&gt;Summer vacation&lt;/h2&gt;
&lt;p&gt;It's been a busy year so far! Since the first sprint started in early February, we've made tons of progress. However, unlike the past couple sprints, we aren't going to immediately jump into our next one. Instead, we're taking a couple months for vacation, and we'll start back up in September. Until then, we won't have have weekly meetings on &lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits&quot;&gt;Zulip&lt;/a&gt; nor will we have any defined goals. This is in part since some members might be taking a vacation. But also, code burnout is very real and a break every now and then can be helpful. In the meantime, there are a few items left to finish/cleanup.&lt;/p&gt;
&lt;p&gt;If you're interested in helping, don't be discouraged! Zulip should still be fairly active, so feel free to drop by!&lt;/p&gt;
</content>

        <author>
            <name>Jack Huey</name>
        </author>
    </entry>
    
    <entry>
        <title>Lang team design meeting: path to membership</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/07/09/lang-team-path-to-membership.html" type="text/html" title="Lang team design meeting: path to membership" />
        <published>2020-07-09T00:00:00+00:00</published>
        <updated>2020-07-09T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/07/09/lang-team-path-to-membership.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/07/09/lang-team-path-to-membership.html">&lt;p&gt;This week the &lt;a href=&quot;https://www.rust-lang.org/governance/teams/lang&quot;&gt;lang team&lt;/a&gt; design meeting was on the topic of the &amp;quot;path to
membership&amp;quot;. This blog post gives a brief summary; you can also read
the &lt;a href=&quot;https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2020-07-08-lang-team-path-to-membership.md&quot;&gt;minutes&lt;/a&gt; or view the &lt;a href=&quot;https://youtu.be/SeH-hZgDG1Y&quot;&gt;recording&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The premise of the meeting was that the lang team has never had a
particularly clear &lt;em&gt;path to membership&lt;/em&gt; -- i.e., it's been hard to say
exactly what are the kinds of steps that one should be taking if you
would like to become a member of the lang team. However, with the
shift to &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2936/&quot;&gt;major change proposals&lt;/a&gt; and in particular &lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2856&quot;&gt;project groups&lt;/a&gt;,
we're starting to see what such a path looks like.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#expectations-for-a-team-member&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;expectations-for-a-team-member&quot;&gt;&lt;/a&gt;Expectations for a team member&lt;/h3&gt;
&lt;p&gt;As part of our discussion, we came up with a relatively complete list of
what we see as the &amp;quot;expectations for a lang-team member&amp;quot;. To be clear,
this is the full set of possible expectations: many members only have the
time to do some subset of these things at any given time.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lead project groups, where appropriate&lt;/li&gt;
&lt;li&gt;Liaison for projects, where appropriate&lt;/li&gt;
&lt;li&gt;Participate in triage meetings&lt;/li&gt;
&lt;li&gt;Participate in design meetings&lt;/li&gt;
&lt;li&gt;Respond to rfcbot fcp requests in a timely fashion&lt;/li&gt;
&lt;li&gt;Participate constructively in, and help facilitate, RFC discussion, issues, PRs, and other GitHub-based discussions
&lt;ul&gt;
&lt;li&gt;Provide important technical points&lt;/li&gt;
&lt;li&gt;Help to drive discussions towards common understanding&lt;/li&gt;
&lt;li&gt;Understanding and documenting the positions and points being raised&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Monitor and respond to communication in Zulip&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#a-sketch-for-a-path-to-membership&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;a-sketch-for-a-path-to-membership&quot;&gt;&lt;/a&gt;A sketch for a path to membership&lt;/h3&gt;
&lt;p&gt;The core idea for a path to membership is that we want some set of
steps that let us see people doing the things and demonstrating the
qualities we expect from lang-team members, so that we can tell how it
is working (and so that people can experience what it's like).&lt;/p&gt;
&lt;p&gt;This suggests that a &amp;quot;path to membership&amp;quot; might look something like this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lead or be heavily involved in one or more project groups&lt;/li&gt;
&lt;li&gt;Serve as a liaison for one or more project groups&lt;/li&gt;
&lt;li&gt;Participate in meetings, where possible&lt;/li&gt;
&lt;li&gt;Participate in discussions and in particular help to create summaries or otherwise resolve technical disputes in a productive way&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We realize that we can identify people who are doing some of those
things already and approach to see if they are interested in lang-team
membership.  If so, we can look for opportunities to complete some of
the other bullets.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#a-bit-of-background-project-groups&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;a-bit-of-background-project-groups&quot;&gt;&lt;/a&gt;A bit of background: project groups&lt;/h2&gt;
&lt;p&gt;We've not been blogging a lot about the idea of project groups and the
like so let me give just a bit of background. In short, the idea is
that we are trying to &amp;quot;intercept&amp;quot; the RFC process earlier by
introducing a &amp;quot;pre-step&amp;quot; called a Major Change Proposal
(MCP). (Terminology still subject to change as we experiment here.)&lt;/p&gt;
&lt;p&gt;The idea is that if you have an idea you'd like to pursue, you can
file an MCP issue and describe the high-level details. If the idea
catches the eye of somebody within the team, we will create a
&lt;strong&gt;project group&lt;/strong&gt; to pursue the idea, with that member serving as the
&lt;strong&gt;lang team liaison&lt;/strong&gt; and you (or others) serving as the &lt;strong&gt;group
lead&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;project group&lt;/strong&gt; doesn't have to be a huge group of people. It
might even just be one or two people and a dedicated Zulip stream.
The idea is that the group will work out the design space and author
RFCs; once the RFCs are accepted, the group can also pursue the
implementation (though the set of people involved may shift at that
point), and hopefully see the idea all the way through to
stabilization.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#growing-the-set-of-folks-who-can-serve-as-liaison&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;growing-the-set-of-folks-who-can-serve-as-liaison&quot;&gt;&lt;/a&gt;Growing the set of folks who can serve as liaison&lt;/h3&gt;
&lt;p&gt;One of the things we talked about was the proper role for a project
group liaison. As described in the previous paragraph, a liaison was
basically a member of the team who would follow along with the design
and help to keep the rest of the team up to date.&lt;/p&gt;
&lt;p&gt;But we realized that if we limit liaisons to team members, then this
is incompatible with this idea of a &amp;quot;path to membership&amp;quot; where people
can &amp;quot;trial run&amp;quot; lang-team activities.  It's also somewhat incompatible
with a core goal, which is that the experience of someone who is &lt;em&gt;not&lt;/em&gt;
on a team and someone who &lt;em&gt;is&lt;/em&gt; on a team ought to be awfully close,
and that we should be careful when creating distinctions.&lt;/p&gt;
&lt;p&gt;Therefore, we discussed the idea of saying that liaisons don't have to
be team members, they just have to be people who are heavily involved
in the project and who can be trusted to create regular updates for
the lang-team and keep the rest of the team in the loop.&lt;/p&gt;
&lt;p&gt;In particular, this can also be a useful stepping stone towards full
lang-team membership -- although it doesn't have to be. It's useful to
have people serve as liaisons even if they don't really have time or
interest in being on the lang team.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#conclusion&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;We concluded that we'll start experimenting with &amp;quot;non-team-member
liaisons&amp;quot;, and that people who are maybe interested in that role can
reach out privately to Josh Triplett or myself
(nikomatsakis). Further, we'll work to write up the &amp;quot;path to
membership&amp;quot; as well as the expectations for team membership.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Lang team design meeting update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/07/08/lang-team-design-meeting-update.html" type="text/html" title="Lang team design meeting update" />
        <published>2020-07-08T00:00:00+00:00</published>
        <updated>2020-07-08T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/07/08/lang-team-design-meeting-update.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/07/08/lang-team-design-meeting-update.html">&lt;p&gt;Hello! Did you know that the &lt;a href=&quot;https://www.rust-lang.org/governance/teams/lang&quot;&gt;lang team&lt;/a&gt; now has regular design
meetings? We use these meetings to dig deeper into the output of
active project groups. After the meeting, we typically post a
recording to &lt;a href=&quot;https://www.youtube.com/playlist?list=PL85XCvVPmGQg-gYy7R6a_Y91oQLdsbSpa&quot;&gt;YouTube&lt;/a&gt; as well as some &lt;a href=&quot;https://lang-team.rust-lang.org/minutes.html&quot;&gt;minutes into the lang-team
repository&lt;/a&gt;. I wanted to write a quick update listing out some of
the meetings we've had recently as well as some of our upcoming
meetings.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#recent-lang-team-design-meetings&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;recent-lang-team-design-meetings&quot;&gt;&lt;/a&gt;Recent lang-team design meetings&lt;/h3&gt;
&lt;p&gt;We recently held two lang-team design meetings:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;const evaluation project group&lt;/strong&gt; discussed the overall state
of const evaluation and a &lt;a href=&quot;https://github.com/nikomatsakis/skill-tree#what-is-a-skill-tree&quot;&gt;&amp;quot;skill tree&amp;quot;&lt;/a&gt; that they've been
developing to show &lt;strong&gt;what some of the next steps are&lt;/strong&gt; and how they
relate to one another.  We also discussed &lt;strong&gt;what &amp;quot;unsafe&amp;quot; might mean
in a const evaluation context&lt;/strong&gt; and in particular &lt;a href=&quot;https://www.ralfj.de/blog/2018/07/19/const.html&quot;&gt;Ralf's proposal to
consider &amp;quot;things that may not be const-evaluable&amp;quot; as &amp;quot;unsafe&amp;quot; in a
const fn&lt;/a&gt;.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2020-06-24-const-eval-unsafe-and-skill-tree.md&quot;&gt;Minutes&lt;/a&gt;, &lt;a href=&quot;https://youtu.be/b3p2vX8wZ_c&quot;&gt;recording&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Safe transmute project group&lt;/strong&gt;: We discussed the approaches explored
by the safe transmute group, and in particular did a bit of a &lt;strong&gt;deep
dive into the &lt;a href=&quot;https://github.com/jswrenn/typic&quot;&gt;exciting &lt;code&gt;typic&lt;/code&gt; crate&lt;/a&gt;&lt;/strong&gt; being developed by
&lt;a href=&quot;https://github.com/jswrenn&quot;&gt;jswrenn&lt;/a&gt;. We looked at what it might make sense to pursue as an
&lt;strong&gt;immediate RFC&lt;/strong&gt; and what ought to stay in the realm of library experimentation
for the time being.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2020-07-01-safe-transmute-typic.md&quot;&gt;Minutes&lt;/a&gt;, &lt;a href=&quot;https://youtu.be/3aw-5Fcyo7s&quot;&gt;recording&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#how-lang-team-design-meeting-proposals-work&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;how-lang-team-design-meeting-proposals-work&quot;&gt;&lt;/a&gt;How lang-team design meeting proposals work&lt;/h3&gt;
&lt;p&gt;Every proposed meeting begins with an issue on the lang-team
repository. If you're curious, you can take a look at the &lt;a href=&quot;https://github.com/rust-lang/lang-team/issues?q=label%3Ameeting-proposal&quot;&gt;open issues
with the &lt;code&gt;meeting proposal&lt;/code&gt; label&lt;/a&gt; to get an idea of what
meetings are being considered; if a meeting has been scheduled, it
will also be tagged with &lt;a href=&quot;https://github.com/rust-lang/lang-team/issues?q=label%3Ameeting-scheduled&quot;&gt;&lt;code&gt;meeting scheduled&lt;/code&gt;&lt;/a&gt; and have some comments as
to the current date.&lt;/p&gt;
&lt;p&gt;We currently schedule meetings in a rather ad-hoc fashion, basically
hammering it out over Zulip. I'd probably like to move us to a more
&amp;quot;regularly scheduled&amp;quot; scheduling meeting, like the compiler team, but
we haven't adopted such a scheme yet.&lt;/p&gt;
&lt;p&gt;Anyone can propose a design meeting, though they are meant to be
proposed mostly in conjunction with active project groups or other
ongoing discussions, and not just out of the blue. Moreover, anyone is
welcome to listen in on a design meeting, though you should be aware
that the meeting is typically being recorded. Zoom links are available
upon request.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#upcoming-lang-team-meeting-proposals&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;upcoming-lang-team-meeting-proposals&quot;&gt;&lt;/a&gt;Upcoming lang-team meeting proposals&lt;/h3&gt;
&lt;p&gt;We currently have two pending lang-team meeting proposals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A proposal to discuss the path to lang-team membership (&lt;a href=&quot;https://github.com/rust-lang/lang-team/issues/32&quot;&gt;rust-lang/lang-team#32&lt;/a&gt;).&lt;/li&gt;
&lt;li&gt;A proposal to discuss enforcing bounds on type aliases and how we
might phase that in (&lt;a href=&quot;https://github.com/rust-lang/lang-team/issues/25&quot;&gt;rust-lang/lang-team#25&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We expect to be scheduling those soon, and we'll update the issues
with dates when they are available.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Ownership of the standard library implementation</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/07/02/Ownership-Std-Implementation.html" type="text/html" title="Ownership of the standard library implementation" />
        <published>2020-07-02T00:00:00+00:00</published>
        <updated>2020-07-02T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/07/02/Ownership-Std-Implementation.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/07/02/Ownership-Std-Implementation.html">&lt;p&gt;Our Rust project is a large and diverse one. Its activities are broadly coordinated by teams that give the community space to find and contribute to the things that matter to them.
Weâ€™re trialing a reorganization of standard library activities between the Libs and Compiler teams.
Going forward, the Libs team will own just the public API of the standard library, and the Compiler team will own its implementation.
The goal of this separation of concerns is to better suit the interests of both teams to better support the needs of the standard library.
It's a lot like the existing relationship between the Lang and Compiler teams, where the Lang team owns the Rust language design and the Compiler team owns the code that implements it.
We'll re-evaluate how the trial is going later in the year and decide whether or not to make the change permanent.&lt;/p&gt;
&lt;p&gt;The Libs team traditionally selects members who like to design APIs.
A lot of bandwidth is spent supporting libraries in the wider Rust ecosystem and working to consolidate idioms into standard APIs.
This leaves little room for development of the standard library itself, which takes a lot of consistent and dedicated attention.&lt;/p&gt;
&lt;p&gt;As a codebase, the standard library is paradoxically specialized.
It has privileged access to compiler internals, deep domain knowledge baked into algorithms (have you ever wondered what it takes to efficiently format a float as text for instance?), platform-specific integration, and a lot of tricky unsafe code.&lt;/p&gt;
&lt;p&gt;The Compiler team is used to giving consistent and dedicated attention to big projects.
The standard library is exactly the kind of codebase the Compiler team already has years of experience working on.&lt;/p&gt;
&lt;p&gt;Teams arenâ€™t bubbles though, and in practice API design and implementation are going to influence each other.
This is just a shared understanding between the Libs and Compiler teams to make standard library activities more focused.&lt;/p&gt;
&lt;p&gt;Do any of those activities appeal to you?
Maybe youâ€™re interested in identifying and capturing idioms as standard APIs.
If so, you can find the Libs team &lt;a href=&quot;https://forge.rust-lang.org/libs/index.html&quot;&gt;here&lt;/a&gt;.
Maybe youâ€™d like to work on a big codebase used by almost every Rust developer.
If so, you can find the Compiler team &lt;a href=&quot;https://forge.rust-lang.org/compiler/index.html&quot;&gt;here&lt;/a&gt;.
Maybe you like the sound of both and anything in-between! Whatever the case, the standard library has something for you.&lt;/p&gt;
</content>

        <author>
            <name>Ashley Mannix</name>
        </author>
    </entry>
    
    <entry>
        <title>Disk space and LTO improvements</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/06/29/lto-improvements.html" type="text/html" title="Disk space and LTO improvements" />
        <published>2020-06-29T00:00:00+00:00</published>
        <updated>2020-06-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/06/29/lto-improvements.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/06/29/lto-improvements.html">&lt;p&gt;Thanks to the work of &lt;a href=&quot;https://github.com/nnethercote&quot;&gt;Nicholas Nethercote&lt;/a&gt; and &lt;a href=&quot;https://github.com/alexcrichton/&quot;&gt;Alex Crichton&lt;/a&gt;, there have been some recent improvements that reduce the size of compiled libraries, and improves the compile-time performance, particularly when using LTO. This post dives into some of the details of what changed, and an estimation of the benefits.&lt;/p&gt;
&lt;p&gt;These changes have been added incrementally over the past three months, with the latest changes landing just a few days ago on the nightly channel. The bulk of the improvements will be found in the 1.46 stable release (available on 2020-08-27). It would be great for any projects that use LTO to test it out on the nightly channel (starting from the 2020-06-13 release) and report any issues that arise.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#background&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;
&lt;p&gt;When compiling a library, &lt;code&gt;rustc&lt;/code&gt; saves the output in an &lt;code&gt;rlib&lt;/code&gt; file which is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Ar_(Unix)&quot;&gt;archive file&lt;/a&gt;. This has historically contained the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Object code, which is the result of code generation. This is used during regular linking.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://llvm.org/docs/BitCodeFormat.html&quot;&gt;LLVM bitcode&lt;/a&gt;, which is a binary representation of LLVM's intermediate representation. This can be used for &lt;a href=&quot;https://llvm.org/docs/LinkTimeOptimization.html&quot;&gt;Link Time Optimization&lt;/a&gt; (LTO).&lt;/li&gt;
&lt;li&gt;Rust-specific metadata, which covers &lt;a href=&quot;https://github.com/rust-lang/rust/blob/0b66a89735305ebac93894461559576495ab920e/src/librustc_metadata/rmeta/mod.rs#L172-L214&quot;&gt;a wide range of data&lt;/a&gt; about the crate.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LTO is an optimization technique that can perform whole-program analysis. It analyzes all of the bitcode from every library at once, and performs optimizations and code generation. &lt;code&gt;rustc&lt;/code&gt; supports several forms of LTO:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fat LTO. This performs &amp;quot;full&amp;quot; LTO, which can take a long time to complete and may require a significant amount of memory.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html&quot;&gt;Thin LTO&lt;/a&gt;. This LTO variant supports much better parallelism than fat LTO. It can achieve similar performance improvements as fat LTO (sometimes even better!), while taking much less total time by taking advantage of more CPUs.&lt;/li&gt;
&lt;li&gt;Thin-local LTO. By default, &lt;code&gt;rustc&lt;/code&gt; will split a crate into multiple &amp;quot;codegen units&amp;quot; so that they can be processed in parallel by LLVM. But this prevents some optimizations as code is separated into different codegen units, and is handled independently. Thin-local LTO will perform thin LTO across the codegen units within a single crate, bringing back some optimizations that would otherwise be lost by the separation. This is &lt;code&gt;rustc&lt;/code&gt;'s default behavior if opt-level is greater than 0.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#what-has-changed&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;what-has-changed&quot;&gt;&lt;/a&gt;What has changed&lt;/h2&gt;
&lt;p&gt;Changes have been made to both &lt;code&gt;rustc&lt;/code&gt; and Cargo to control which libraries should include object code and which should include bitcode based on the project's &lt;a href=&quot;https://doc.rust-lang.org/cargo/reference/profiles.html&quot;&gt;profile&lt;/a&gt; LTO settings. If the project is not using LTO, then Cargo will instruct &lt;code&gt;rustc&lt;/code&gt; to not place bitcode in the rlib files, which should reduce the amount of disk space used. This may have a small improvement in performance since &lt;code&gt;rustc&lt;/code&gt; no longer needs to compress and write out the bitcode.&lt;/p&gt;
&lt;p&gt;If the project is using LTO, then Cargo will instruct &lt;code&gt;rustc&lt;/code&gt; to not place object code in the rlib files, avoiding the expensive code generation step. This should improve the build time when building from scratch, and reduce the amount of disk space used.&lt;/p&gt;
&lt;p&gt;Two &lt;code&gt;rustc&lt;/code&gt; flags are now available to control how the rlib is constructed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/rustc/codegen-options/#linker-plugin-lto&quot;&gt;&lt;code&gt;-C linker-plugin-lto&lt;/code&gt;&lt;/a&gt; causes &lt;code&gt;rustc&lt;/code&gt; to only place bitcode in the &lt;code&gt;.o&lt;/code&gt; files, and skips code generation. This flag was &lt;a href=&quot;https://github.com/rust-lang/rust/issues/49879&quot;&gt;originally added&lt;/a&gt; to support cross-language LTO. Cargo now uses this when the rlib is only intended for use with LTO.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://doc.rust-lang.org/nightly/rustc/codegen-options/#embed-bitcode&quot;&gt;&lt;code&gt;-C embed-bitcode=no&lt;/code&gt;&lt;/a&gt; causes &lt;code&gt;rustc&lt;/code&gt; to avoid placing bitcode in the rlib altogether. Cargo uses this when LTO is not being used, which reduces some disk space usage.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additionally, the method in which bitcode is embedded in the rlib has changed. Previously, &lt;code&gt;rustc&lt;/code&gt; would place compressed bitcode as a &lt;code&gt;.bc.z&lt;/code&gt; file in the rlib archive. Now, the bitcode is placed as an uncompressed section within each &lt;code&gt;.o&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_file&quot;&gt;object file&lt;/a&gt; in the rlib archive. This can sometimes be a small performance benefit, because it avoids cost of compressing the bitcode, and sometimes can be slower due to needing to write more data to disk. This change helped simplify the implementation, and also matches the behavior of clang's &lt;code&gt;-fembed-bitcode&lt;/code&gt; option (typically used with Apple's iOS-based operating systems).&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#improvements&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;improvements&quot;&gt;&lt;/a&gt;Improvements&lt;/h2&gt;
&lt;p&gt;The following is a summary of improvements observed on a small number of real-world projects of small and medium size. Improvements of a project will depend heavily on the code, optimization settings, operating system, environment, and hardware. These were recorded with the 2020-06-21 nightly release on Linux with parallel job settings between 2 and 32.&lt;/p&gt;
&lt;p&gt;The performance wins for debug builds were anywhere from 0% to 4.7% faster. Larger binary crates tended to fare better than smaller library crates.&lt;/p&gt;
&lt;p&gt;LTO builds were recorded anywhere from 4% to 20% faster. Thin LTO fared consistently better than fat LTO.&lt;/p&gt;
&lt;p&gt;The number of parallel jobs also had a large impact on the amount of improvement. Lower parallel job counts saw substantially more benefit than higher ones. A project built with &lt;code&gt;-j2&lt;/code&gt; can be 20% faster, whereas the same project at &lt;code&gt;-j32&lt;/code&gt; would only be 1% faster. Presumably this is because the code-generation phase benefits from higher concurrency, so it was taking a relatively smaller total percentage of time.&lt;/p&gt;
&lt;p&gt;The overall target directory size is typically 20% to 30% smaller for debug builds. LTO builds did not see as much of an improvement, ranging from 11% to 19% smaller.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#more-details&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;more-details&quot;&gt;&lt;/a&gt;More details&lt;/h2&gt;
&lt;p&gt;Nicholas Nethercote wrote about the journey to implement these changes at &lt;a href=&quot;https://blog.mozilla.org/nnethercote/2020/04/24/how-to-speed-up-the-rust-compiler-in-2020/&quot;&gt;https://blog.mozilla.org/nnethercote/2020/04/24/how-to-speed-up-the-rust-compiler-in-2020/&lt;/a&gt;. It took several PRs across &lt;code&gt;rustc&lt;/code&gt; and Cargo to make this happen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/66598&quot;&gt;#66598&lt;/a&gt; â€”Â The original approach, that was decided to be too simplistic.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/issues/66961&quot;&gt;#66961&lt;/a&gt; â€”Â The issue outlining the strategy that was employed.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/70289&quot;&gt;#70289&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/70297&quot;&gt;#70297&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/70345&quot;&gt;#70345&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/70384&quot;&gt;#70384&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/70644&quot;&gt;#70644&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/70729&quot;&gt;#70729&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/71374&quot;&gt;#71374&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/71716&quot;&gt;#71716&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/rust/pull/71754&quot;&gt;#71754&lt;/a&gt; â€”Â A series of refactorings to prepare for the new behavior and do some cleanup.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/71323&quot;&gt;#71323&lt;/a&gt; â€”Â Introduced a new flag to control whether or not bitcode is embedded.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/70458&quot;&gt;#70458&lt;/a&gt; &lt;a href=&quot;https://github.com/rust-lang/rust/pull/71528&quot;&gt;#71528&lt;/a&gt; â€”Â Switched how LLVM bitcode is embedded.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/8066&quot;&gt;#8066&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/8192&quot;&gt;#8192&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/8204&quot;&gt;#8204&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/8226&quot;&gt;#8226&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/8254&quot;&gt;#8254&lt;/a&gt;
&lt;a href=&quot;https://github.com/rust-lang/cargo/pull/8349&quot;&gt;#8349&lt;/a&gt; â€”Â The series of Cargo changes to implement the new functionality.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href=&quot;#conclusion&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Although this is a conceptually simple change (LTO=bitcode, non-LTO=object code), it took quite a bit of preparation and work to make it happen. There were many edge cases and platform-specific behaviors to consider, and testing to perform. And, of course, the obligatory bike-shedding over the names of new command-line flags. This resulted in quite a substantial improvement in performance, particularly for LTO builds, and a huge improvement in disk space usage. Thanks to all of those that helped to make this happen!&lt;/p&gt;
</content>

        <author>
            <name>Eric Huss</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Windows and ARM notification groups</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/06/09/windows-notification-group.html" type="text/html" title="Announcing the Windows and ARM notification groups" />
        <published>2020-06-09T00:00:00+00:00</published>
        <updated>2020-06-09T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/06/09/windows-notification-group.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/06/09/windows-notification-group.html">&lt;p&gt;We are forming two new groups in the compiler team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Windows group, for helping us to diagnose and resolve Windows-related issues.&lt;/li&gt;
&lt;li&gt;An ARM group, for helping us to resolve issues specific to the ARM architectures&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of these groups are &amp;quot;notification groups&amp;quot;, which means that anyone can add their own name to the list -- if you do, you'll receive pings when Windows- or ARM-related bugs arise.&lt;/p&gt;
&lt;p&gt;Each group also has an associated Zulip stream ([&lt;code&gt;#t-compiler/windows&lt;/code&gt;], [&lt;code&gt;#t-compiler/arm&lt;/code&gt;]) where people can go to pose questions and discuss topics specific to that target.&lt;/p&gt;
&lt;p&gt;To get a better idea for what the groups will do, here are some examples of the kinds of questions where we would have reached out to the Windows group for advice in determining the best course of action:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Should we remove the legacy InnoSetup GUI installer? &lt;a href=&quot;https://github.com/rust-lang/rust/pull/72569&quot;&gt;#72569&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;What names should we use for static libraries on Windows? &lt;a href=&quot;https://github.com/rust-lang/rust/pull/29520&quot;&gt;#29520&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, if you are interested in participating, please sign up for the Windows or aarch64 groups! To do so, you open a PR against the &lt;a href=&quot;https://github.com/rust-lang/team&quot;&gt;rust-lang/team&lt;/a&gt; repository. Just follow these examples (but change the username to your own):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/team/pull/348&quot;&gt;Windows example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/team/pull/358&quot;&gt;ARM example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Upcoming compiler-team design meetings</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/06/08/upcoming-compiler-team-design-meeting.html" type="text/html" title="Upcoming compiler-team design meetings" />
        <published>2020-06-08T00:00:00+00:00</published>
        <updated>2020-06-08T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/06/08/upcoming-compiler-team-design-meeting.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/06/08/upcoming-compiler-team-design-meeting.html">&lt;p&gt;In our &lt;a href=&quot;https://zulip-archive.rust-lang.org/238009tcompilermeetings/16428planningmeeting20200605.html&quot;&gt;planning meeting today&lt;/a&gt;, the &lt;a href=&quot;https://www.rust-lang.org/governance/teams/compiler&quot;&gt;compiler team&lt;/a&gt; has scheduled our
next batch of upcoming design meetings. You can find the exact times
on the compiler team's &lt;a href=&quot;https://rust-lang.github.io/compiler-team/#meeting-calendar&quot;&gt;meeting calendar&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On June 19th (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=NGhzYXBkZm12ZzVmbzEzb2VpMzlsYzN0dnEgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will
have a follow-up discussion of our internal survey results.
See &lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/302&quot;&gt;rust-lang/compiler-team#302&lt;/a&gt; for more details.&lt;/li&gt;
&lt;li&gt;On June 26th (&lt;a href=&quot;https://calendar.google.com/event?action=TEMPLATE&amp;tmeid=NmVjcTNibm03Ym5jamc2Z2NnaGNzaHFtMHYgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc=6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss
restructuring our current team organization
to reflect &amp;quot;areas of the compiler&amp;quot;.
See &lt;a href=&quot;https://github.com/rust-lang/compiler-team/issues/288&quot;&gt;rust-lang/compiler-team#288&lt;/a&gt; for more details.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href=&quot;#did-you-know&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;did-you-know&quot;&gt;&lt;/a&gt;Did you know?&lt;/h3&gt;
&lt;p&gt;Most weeks, the compiler team has some sort of design meeting. These
meetings take place on Zulip and are open to all. Every 4 weeks, we do
a planning meeting to pick the next few meetings from the list of open
proposals. You can find &lt;a href=&quot;https://rust-lang.github.io/compiler-team/about/steering-meeting/&quot;&gt;more details about how the compiler-team
steering meeting process here&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
    <entry>
        <title>New inline assembly syntax available in nightly</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html" type="text/html" title="New inline assembly syntax available in nightly" />
        <published>2020-06-08T00:00:00+00:00</published>
        <updated>2020-06-08T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/06/08/new-inline-asm.html">&lt;p&gt;In the course of optimization, OS or embedded development, or other kinds of
low-level programming, you may sometimes need to write native assembly code for
the processor you're running on. &amp;quot;Inline assembly&amp;quot; provides a simple way to
integrate some assembly instructions into a Rust program, feeding Rust
expressions in as input registers, and getting output directly into Rust
variables. We've introduced a new syntax for inline assembly in nightly Rust,
and we're seeking feedback on it; we believe this new syntax has a path to
stabilization in the future.&lt;/p&gt;
&lt;p&gt;Nightly Rust has had a syntax for &amp;quot;inline assembly&amp;quot; (&lt;code&gt;asm!&lt;/code&gt;) for a long time;
however, this syntax just exposed a very raw version of LLVM's assembly
construct, with no safeguards to help developers use it. Getting any detail of
this syntax even slightly wrong tended to produce an Internal Compiler Error
(ICE) rather than the kind of friendly error message you've come to expect from
rustc. This syntax was also error-prone for another reason: it looks similar to
GCC's inline assembly syntax, but has subtle differences (such as the names in
register constraints). This syntax also had little to no hope of being
supported on any non-LLVM backend. As a result of all these limitations, the
&lt;code&gt;asm!&lt;/code&gt; syntax was highly unlikely to ever graduate from nightly to stable Rust,
despite being one of the most requested features.&lt;/p&gt;
&lt;p&gt;In an effort to improve &lt;code&gt;asm!&lt;/code&gt; and bring it to more users, &lt;a href=&quot;https://github.com/Amanieu&quot;&gt;Amanieu
d'Antras&lt;/a&gt; designed and implemented a new,
friendlier syntax for &lt;code&gt;asm!&lt;/code&gt;. This syntax has had a long road from concept to
compiler implementation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The proposal first started as a &lt;a href=&quot;https://internals.rust-lang.org/t/pre-rfc-2-inline-assembly/11310&quot;&gt;pre-RFC on
internals&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Inline assembly became one of the language team's first &lt;a href=&quot;https://github.com/rust-lang/rfcs/blob/master/text/2836-project-asm.md&quot;&gt;project
groups&lt;/a&gt;,
and iteratively designed RFCs in &lt;a href=&quot;https://github.com/rust-lang/project-inline-asm/&quot;&gt;the project group
repository&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/2873&quot;&gt;RFC 2873&lt;/a&gt; (still under
discussion) provides a specification for the syntax and its interaction with
the Rust language.&lt;/li&gt;
&lt;li&gt;We &lt;a href=&quot;https://github.com/rust-lang/rust/pull/68404&quot;&gt;renamed the existing &lt;code&gt;asm!&lt;/code&gt; to
&lt;code&gt;llvm_asm!&lt;/code&gt;&lt;/a&gt;, so that people
currently using inline assembly on nightly can continue to use the existing
syntax for now. (We plan to remove this syntax eventually, given its fragile
ICE-happy nature, but while evaluating the new syntax we want the old syntax
available for comparison and alternatives.)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rust-lang/rust/pull/69171&quot;&gt;PR 69171&lt;/a&gt; (also by Amanieu)
implemented the new &lt;code&gt;asm!&lt;/code&gt; syntax in nightly.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here's an example of using the new inline assembly syntax, to print a message
to standard output using a direct &lt;a href=&quot;https://man7.org/linux/man-pages/man2/write.2.html&quot;&gt;&lt;code&gt;write&lt;/code&gt;
syscall&lt;/a&gt; on x86-64 Linux:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#![feature(asm)]

fn main() {
    let buf = &amp;quot;Hello from asm!\n&amp;quot;;
    let ret: i32;
    unsafe {
        asm!(
            &amp;quot;syscall&amp;quot;,
            in(&amp;quot;rax&amp;quot;) 1, // syscall number
            in(&amp;quot;rdi&amp;quot;) 1, // fd (stdout)
            in(&amp;quot;rsi&amp;quot;) buf.as_ptr(),
            in(&amp;quot;rdx&amp;quot;) buf.len(),
            out(&amp;quot;rcx&amp;quot;) _, // clobbered by syscalls
            out(&amp;quot;r11&amp;quot;) _, // clobbered by syscalls
            lateout(&amp;quot;rax&amp;quot;) ret,
        );
    }
    println!(&amp;quot;write returned: {}&amp;quot;, ret);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(You can &lt;a href=&quot;https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=e983a5f5cffa51f4320f1176465d3a56&quot;&gt;try this example on the
playground&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;The example above specifies the exact inputs, outputs, and clobbers required by
the Linux syscall calling convention. You can also provide inputs and outputs
via arbitrary registers, and the compiler will select appropriate registers for
you. The following example uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets&quot;&gt;bit manipulation
instructions&lt;/a&gt;
to compute the bit numbers of all set bits in a value, and stores them in a
slice of memory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;#![feature(asm)]

fn main() {
    let mut bits = [0u8; 64];
    for value in 0..=1024u64 {
        let popcnt;
        unsafe {
            asm!(
                &amp;quot;popcnt {popcnt}, {v}&amp;quot;,
                &amp;quot;2:&amp;quot;,
                &amp;quot;blsi rax, {v}&amp;quot;,
                &amp;quot;jz 1f&amp;quot;,
                &amp;quot;xor {v}, rax&amp;quot;,
                &amp;quot;tzcnt rax, rax&amp;quot;,
                &amp;quot;stosb&amp;quot;,
                &amp;quot;jmp 2b&amp;quot;,
                &amp;quot;1:&amp;quot;,
                v = inout(reg) value =&amp;gt; _,
                popcnt = out(reg) popcnt,
                out(&amp;quot;rax&amp;quot;) _, // scratch
                inout(&amp;quot;rdi&amp;quot;) bits.as_mut_ptr() =&amp;gt; _,
            );
        }
        println!(&amp;quot;bits of {}: {:?}&amp;quot;, value, &amp;amp;bits[0..popcnt]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(You can &lt;a href=&quot;https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=894a407f0fe858559aa378edf6ec4801&quot;&gt;try this example on the
playground&lt;/a&gt;.
Note that this code serves to demonstrate inline assembly, not to demonstrate
an efficient implementation of any particular algorithm.)&lt;/p&gt;
&lt;p&gt;Notice that &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;popcnt&lt;/code&gt; have registers selected for them, while
&lt;code&gt;bits.as_mut_ptr()&lt;/code&gt; must go in the &lt;code&gt;rdi&lt;/code&gt; register for use with the &lt;code&gt;stosb&lt;/code&gt;
instruction.&lt;/p&gt;
&lt;p&gt;Also, note that on x86 platforms, &lt;code&gt;asm!&lt;/code&gt; uses Intel syntax by default; however,
you can use AT&amp;amp;T syntax with &lt;code&gt;option(att_syntax)&lt;/code&gt;. You may find this useful
when translating existing inline assembly code to the new &lt;code&gt;asm!&lt;/code&gt; syntax.&lt;/p&gt;
&lt;p&gt;For full details on the new &lt;code&gt;asm!&lt;/code&gt; syntax, see &lt;a href=&quot;https://github.com/Amanieu/rfcs/blob/inline-asm/text/0000-inline-asm.md&quot;&gt;RFC
2873&lt;/a&gt;.
Please try it out (including translating existing inline assembly to the new
syntax), and &lt;a href=&quot;https://github.com/rust-lang/rust/issues/&quot;&gt;report any bugs via the rust issue
tracker&lt;/a&gt; with the tag &lt;code&gt;F-asm&lt;/code&gt;. You
can also discuss inline assembly by creating a topic on &lt;a href=&quot;https://rust-lang.zulipchat.com/#narrow/stream/216763-project-inline-asm&quot;&gt;the project-inline-asm
stream in
Zulip&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Josh Triplett</name>
        </author>
    </entry>
    
    <entry>
        <title>2020 Contributor Survey</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/05/27/contributor-survey.html" type="text/html" title="2020 Contributor Survey" />
        <published>2020-05-27T00:00:00+00:00</published>
        <updated>2020-05-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/05/27/contributor-survey.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/05/27/contributor-survey.html">&lt;p&gt;You may be aware that &lt;a href=&quot;https://blog.rust-lang.org/2020/05/15/five-years-of-rust.html&quot;&gt;Rust recently turned 5&lt;/a&gt;! If you read this blog,
then you probably already know that the Rust project thrives because of its
many contributors, and that we're always looking for ways to make it easier for
people to get involved.&lt;/p&gt;
&lt;p&gt;Today we are pleased to announce the &lt;a href=&quot;https://forms.gle/G1jKM1ppGunft6j29&quot;&gt;Rust contributor survey&lt;/a&gt;. This
short, anonymous survey should only take a few minutes to fill out, but it will
really help us in understanding what kinds of problems people experience when
contributing to Rust so that we can try to address them. We value many
different kinds of contributions, such as reporting problems, triaging issues,
organizing meetups, etc, but this survey's purpose is to identify and eliminate
barriers to entry for code contributions.&lt;/p&gt;
&lt;p&gt;The survey is targeting current, past, and future contributors to Rust. We're
particularly interested in hearing from &lt;em&gt;new or prospective code contributors&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So whether you're a frequent contributor already or someone who has only
thought about contributing, please take a few minutes to &lt;a href=&quot;https://forms.gle/G1jKM1ppGunft6j29&quot;&gt;fill out the
survey&lt;/a&gt; before &lt;strong&gt;June 10, 2020&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;We plan to share and discuss summary data. We may quote free-form responses
unless you ask us not to. All information is collected anonymously. Only team
members or people specifically helping administer the survey will be able to
view full results.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis and @mark-i-m</name>
        </author>
    </entry>
    
    <entry>
        <title>A retrospective on the 2018 rust-lang.org redesign</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/05/26/website-retrospective.html" type="text/html" title="A retrospective on the 2018 rust-lang.org redesign" />
        <published>2020-05-26T00:00:00+00:00</published>
        <updated>2020-05-26T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/05/26/website-retrospective.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/05/26/website-retrospective.html">&lt;p&gt;We released our second 'edition' of Rust at the end of 2018. Part of that release was a revamp of the &lt;a href=&quot;https://www.rust-lang.org&quot;&gt;Rust website&lt;/a&gt;. That work was completed on time, but there was some controversy when it was released, and the project itself was difficult and draining for those involved. This retrospective is an attempt to record the lessons learned from the project, and to put the project into context for those interested but not directly involved.&lt;/p&gt;
&lt;p&gt;This retrospective aims to be &lt;a href=&quot;https://blog.newrelic.com/technology/blameless-retrospectives/&quot;&gt;blameless&lt;/a&gt; and forward-looking. There is no benefit in re-litigating what happened, and we are interested here in the planning, project management, and community aspects, rather than critiquing the design or implementation.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#lessons-learned&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;lessons-learned&quot;&gt;&lt;/a&gt;Lessons learned&lt;/h2&gt;
&lt;p&gt;What have we learned for the next time we take on a similar project?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;People first: people are more valuable than schedules; keeping people healthy, happy, and productive is the most important aspect of managing a project.&lt;/li&gt;
&lt;li&gt;Open communication: we should be as open as possible as early as possible with communication about projects, even when the nature of the project means we can't be open with all development.&lt;/li&gt;
&lt;li&gt;Get feedback early and set expectations about the kind of feedback which is useful. We have ongoing problems in the Rust community where (mostly) well-intentioned feedback from the community becomes overwhelming to the point of harassment; we do not have a solution to this.&lt;/li&gt;
&lt;li&gt;Be prepared to manage feedback, in particular by having enough people available to respond.&lt;/li&gt;
&lt;li&gt;Recognize the complexity of projects and ensure appropriate project management.&lt;/li&gt;
&lt;li&gt;Projects should have clear ownership.&lt;/li&gt;
&lt;li&gt;Large projects should not be scheduled to finish at the same time.&lt;/li&gt;
&lt;li&gt;Work iteratively, rather than going for 'big bang' releases.&lt;/li&gt;
&lt;li&gt;Consider ongoing maintenance: how much is there to do? Who will do it? Failing to consider this means there is more pressure on the initial release.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A lot of these points seem obvious with hindsight. However, every decision is a trade-off, and despite best intentions, it is easy to mis-weight factors in these trade-offs. The above are factors that, with hindsight, should have had more weight.&lt;/p&gt;
&lt;p&gt;In the next sections, I'll expand on some lessons from the summary and then give some context by describing the project.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#communication&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;communication&quot;&gt;&lt;/a&gt;Communication&lt;/h3&gt;
&lt;p&gt;Projects which have a primary focus on design have different dynamics to most other software projects. For example, there is the risk of 'design by committee'. When trying to do open development, this risk is magnified since the 'committee' is effectively the entire world. However, in retrospect we overshot and were not open enough with the website project.&lt;/p&gt;
&lt;p&gt;We could have better communicated the motivation and constraints of the project. By the time of the beta release, the community did not share the project team's conceptualization of the website's requirements. In the future, we might create a pre-RFC to discuss and communicate requirements without starting design work. Once a high-level design is made, it should be actively evangelized to the community.&lt;/p&gt;
&lt;p&gt;As well as asking for feedback (see below), we should communicate project progress and share opportunities for contribution. When looking back at a repository on GitHub, it is not obvious how much iteration has taken place, or what issues have been discussed. But, if the repository is followed from the start, these things are clear.&lt;/p&gt;
&lt;p&gt;In general, communication should be a conversation. Unfortunately, due to other ongoing projects, we did not have enough people with enough time to have that conversation. We think an important lesson here is not to schedule large projects concurrently.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#project-management&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;project-management&quot;&gt;&lt;/a&gt;Project management&lt;/h3&gt;
&lt;p&gt;We underestimated the scale of the project, both in terms of the work to be done and the number of people who would need to be coordinated. As a result, several good people were burnt-out by the project. Errors in software estimation are common; we should have reacted by putting people first - no project is worth losing good people for. One reason that did not happen is that nobody felt empowered to step back and re-evaluate the project. In general, ownership of the project was unclear and this led to poor leadership. Furthermore, the ownership which did exist was not communicated well to the wider community.&lt;/p&gt;
&lt;p&gt;The project as a whole highlighted not just our relative inexperience (with this kind of project), but also our process debt. We had not (and to a great extent still have not) created processes and structures to support projects and people when things start to go wrong. This lets small issues snowball into large ones. For the website project this was compounded by not having enough people involved - they became over-worked and stressed, and that meant they did not have the bandwidth to implement good project management, even when we knew the right thing to do.&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#feedback&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;feedback&quot;&gt;&lt;/a&gt;Feedback&lt;/h3&gt;
&lt;p&gt;As mentioned earlier, we think that community feedback would have been easier to manage if it had been collected during the whole project, rather than being compressed into the final two weeks. Beyond that, we needed much better staffing for the feedback period. Handling feedback was an extremely stressful and difficult experience. In the future, we should ensure there are more people and that we structure feedback as much as possible to ensure that it is useful rather than overwhelming.&lt;/p&gt;
&lt;p&gt;A minority of the community went beyond what was acceptable as feedback. Coupled with the 'pile on' effect of discussions on the internet, this became harassment of the website developers. This is unacceptable behavior, and we expect better from the community. Some of the effect was unintentional, and this is a problem that affects controversial RFC discussions too. It is not clear how to solve this, but is something we should investigate.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#context&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;context&quot;&gt;&lt;/a&gt;Context&lt;/h2&gt;
&lt;p&gt;The website revamp was part of the 2018 edition. The edition was an awesome achievement, but an incredible amount of work. The new website was planned from near the beginning of the year, in the early stages of edition planning. We considered it important for the new website to be ready in time for the edition for maximum impact and because the previous website was unfit for our goals (more below). Because of the timing, there were fewer people available to work on the website than might have been the case, there was less time and energy for leadership and oversight, and there were many competing projects for those involved.&lt;/p&gt;
&lt;p&gt;The previous website had been incrementally added to, but there had never been major work on either content or design (other than the initial release). Essentially, the website rewrite was a completely new project in a domain where we had no organizational experience (there were individuals who had experience in web development, but there had not been opportunity for that experience to become institutional knowledge).&lt;/p&gt;
&lt;p&gt;The initial website was well-suited to its purpose and audience: presenting a small research project to interested hackers. However, as the project and website have grown, the website became less and less appropriate.&lt;/p&gt;
&lt;p&gt;There was consensus among the core team that the old website needed replacing. Although many in the community have fond memories of it (after all, it was most people's very first contact with Rust), there were several ways in which the old website was objectively inadequate: it was difficult to find information, much of the content was out of date, pages were crowded and poorly organized, it was hard to update and to localize (which resulted in missing and out of date information), and it was missing many parts of the community and ecosystem (e.g., any mention of using Rust in embedded systems).&lt;/p&gt;
&lt;p&gt;Design-wise, the previous website was simple and tidy, but it had problems - it was hard to emphasize text, there was little contrast between sections (making it hard to read), and it lacked the vibrancy of Rust's ecosystem and community. It was designed for the audience which built it, and our ambitions for Rust, and the audience for the website, had since grown larger.&lt;/p&gt;
&lt;p&gt;One of the goals of the 2018 edition was to appeal to a wider audience. The website was a key tool for achieving that goal. However, it was clear the design and most of the content needed a complete overhaul.&lt;/p&gt;
&lt;p&gt;This sounded like a relatively standard website project to produce a relatively small website. However, in retrospect, the constraints were difficult - there is a lot of information that needed to be made accessible, without making the website overwhelming; we needed to serve newcomers with different backgrounds, as well as existing Rust users looking to find information; the previous 'small' website had grown large, and there was a lot of content to update or replace.&lt;/p&gt;
&lt;p&gt;Work was slow to start and progress was slow, in part due to staffing issues. Content was sought from the teams in mid-2018. We vastly underestimated the complexity of producing and collecting content. Content was slow to produce and slow to review; there were many unrecognized dependencies. We needed lots of iteration. Essentially, the website became a project with 50-ish people, but was managed as if it were a project with one or two people. We were building a website before most content was ready, which is a well-known web development anti-pattern.&lt;/p&gt;
&lt;p&gt;Despite this, and largely due to heroic efforts, the website was finished on time. All planned content was present and polished. We had a striking and vibrant new design, and an implementation that made the website much easier to keep up to date and to translate. Essential information was easy to find, and the website was accessible to a wider audience, in particular developers who knew nothing about Rust, engineering management, and a wider section of potential contributors.&lt;/p&gt;
&lt;p&gt;Unfortunately, it was only just in time. As well as meaning that the last phase of work was stressful and rushed, it meant we didn't have as much time as we should have had for testing and feedback: only two weeks to gather and address feedback on the beta release. Because of this and an earlier lack of communication, there was a flood of commentary, some of which was vocally negative and some which was trolling or harassment. The team did not have the resources or time to respond well.&lt;/p&gt;
&lt;p&gt;Of course, being a software project, there were some bugs (most of which were quickly resolved), and some missing features (notably, localization, which made the website a worse experience for many visitors who did not speak English natively).&lt;/p&gt;
&lt;p&gt;Post-release, content and design was polished, bugs were addressed, and we attempted to create a team to maintain the website. Unfortunately, some of the poor behavior from the community continued. Several people involved with the edition and specifically the website were left burnt out and left Rust or cut back work significantly.&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;#conclusion&quot; aria-hidden=&quot;true&quot; class=&quot;anchor&quot; id=&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In summary, we regard the website as a successful (but imperfect) product, but delivered in a sub-optimal manner. A lot of the things that went wrong were fairly common project management issues. We believe the highest-level lesson to take away is that the Rust organization should improve its project and product management. (To be clear, we think this is an organizational issue, not a comment on any individuals' skills in the domain). Our usual development style is iterative and incremental; when working on larger, less incremental projects, we need to put in more resources, management, and coordination to ensure success. The project was under-staffed and, beyond the obvious problems, that meant that even when we knew the right thing to do, we did not have the people, time, or energy to do it.&lt;/p&gt;
&lt;p&gt;Finally, thank you to everyone who built the website and who helped with this retrospective.&lt;/p&gt;
</content>

        <author>
            <name>Nick Cameron</name>
        </author>
    </entry>
    
</feed>

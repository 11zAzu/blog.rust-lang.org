<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2023-02-06T11:03:58+00:00</updated>

    
    <entry>
        <title>Help test Cargo&#x27;s new index protocol</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html" type="text/html" title="Help test Cargo&#x27;s new index protocol" />
        <published>2023-01-30T00:00:00+00:00</published>
        <updated>2023-01-30T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html">&lt;p&gt;Cargo&#x27;s new index protocol will be available starting in Rust 1.68, which will be released on 2023-03-09.
This new &amp;quot;sparse&amp;quot; protocol should usually provide a significant performance improvement when accessing &lt;a href&#x3D;&quot;https://crates.io&quot;&gt;crates.io&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We would like your help in testing this new feature and infrastructure.
If you use beta (1.68) or nightly-2023-01-21 or newer, set the environment variable &lt;code&gt;CARGO_REGISTRIES_CRATES_IO_PROTOCOL&#x3D;sparse&lt;/code&gt;, or edit your &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/config.html&quot;&gt;&lt;code&gt;.cargo/config.toml&lt;/code&gt; file&lt;/a&gt; to add:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[registries.crates-io]
protocol &#x3D; &amp;quot;sparse&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We would like to hear reports on your experience.
If you run into a problem, please &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/issues/new?assignees&#x3D;&amp;amp;labels&#x3D;C-bug&amp;amp;template&#x3D;bug_report.yml&quot;&gt;open an issue&lt;/a&gt;.
If you would like to post general feedback, feel free to leave a message on &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/cargo-sparse-protocol-feedback-thread/18234&quot;&gt;this internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Along with fetching crates and running &lt;code&gt;cargo update&lt;/code&gt;, we&#x27;d also like to hear if you have any issues when running &lt;code&gt;cargo publish&lt;/code&gt;.
Another data point that may be helpful is to gauge how many users are behind a restrictive firewall, proxy, or other network environment that prevents access to the index.&lt;/p&gt;
&lt;p&gt;This new service will be opt-in as we roll it out and gather information about how it performs.
In the near future we intend to switch to this as the default.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#background&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;
&lt;p&gt;In order for Cargo to determine which crates exist on &lt;a href&#x3D;&quot;https://crates.io&quot;&gt;crates.io&lt;/a&gt;, it downloads and reads an &amp;quot;index&amp;quot; which lists all versions of all crates.
The index lives in a &lt;a href&#x3D;&quot;https://github.com/rust-lang/crates.io-index/&quot;&gt;git repository&lt;/a&gt; hosted on GitHub.
Cargo fetches and stores the index in Cargo&#x27;s home directory.
This system lets GitHub handle the server-side processing, and provides a convenient way to incrementally fetch new updates.&lt;/p&gt;
&lt;p&gt;However, as the index has grown considerably over time, this system has started to hit scaling limitations, and initial fetches and updates continue to slow down. You may have noticed a pause when Cargo displays &lt;code&gt;Updating crates.io index&lt;/code&gt; or while going through the &amp;quot;resolving deltas&amp;quot; phase:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Updating crates.io index
    Fetch [&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&amp;gt;       ]  74.01%, (64415/95919) resolving deltas
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2789-sparse-index.html&quot;&gt;RFC 2789&lt;/a&gt;, we introduced a new protocol to improve the way Cargo accesses the index.
Instead of using git, it fetches files from the index directly over HTTPS.
Cargo will only download information about the specific crate dependencies in your project.&lt;/p&gt;
&lt;p&gt;We have introduced a new service at &lt;code&gt;https://index.crates.io/&lt;/code&gt; for hosting the &lt;a href&#x3D;&quot;https://crates.io&quot;&gt;crates.io&lt;/a&gt; index.
If you are behind a restrictive firewall or proxy, you may need to explicitly allow Cargo to access this site.&lt;/p&gt;
&lt;p&gt;More information about how the index and this new sparse protocol works can be found in &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/cargo/reference/registry-index.html#index-protocols&quot;&gt;the documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href&#x3D;&quot;https://crates.io&quot;&gt;crates.io&lt;/a&gt; git repository will continue to be the source of truth for the index, and Cargo will continue to support git indexes indefinitely.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;We would like to give a huge show of gratitude to &lt;a href&#x3D;&quot;https://github.com/arlosi&quot;&gt;Arlo Siemsen&lt;/a&gt; who implemented this feature and went to great lengths to bring it to completion.
We would also like to thank the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/crates-io&quot;&gt;crates.io team&lt;/a&gt; and the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/infra&quot;&gt;infrastructure team&lt;/a&gt; for implementing, reviewing, and supporting this endeavor.
We would also like to acknowledge the generosity of &lt;a href&#x3D;&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; for hosting the crates.io index over the past 8 years.&lt;/p&gt;
</content>

        <author>
            <name>Eric Huss</name>
        </author>
    </entry>
    
    <entry>
        <title>1.67.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/01/25/1.67.0-prerelease.html" type="text/html" title="1.67.0 pre-release testing" />
        <published>2023-01-25T00:00:00+00:00</published>
        <updated>2023-01-25T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/01/25/1.67.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/01/25/1.67.0-prerelease.html">&lt;p&gt;The 1.67.0 pre-release is ready for testing. The release is scheduled for
January 26. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1670-2023-01-26&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-01-25/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-01-25/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-67-0-pre-release-testing/18203&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Diversifying our Content Delivery Networks</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/01/24/content-delivery-networks.html" type="text/html" title="Diversifying our Content Delivery Networks" />
        <published>2023-01-24T00:00:00+00:00</published>
        <updated>2023-01-24T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/01/24/content-delivery-networks.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/01/24/content-delivery-networks.html">&lt;p&gt;Over the past few weeks, the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/infra&quot;&gt;Infrastructure Team&lt;/a&gt; has been working on setting
up a second &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Content_delivery_network&quot;&gt;Content Delivery Network&lt;/a&gt; (CDN) for releases and crates.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-changing&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-changing&quot;&gt;&lt;/a&gt;What is changing&lt;/h2&gt;
&lt;p&gt;Rust releases (&lt;code&gt;static.rust-lang.org&lt;/code&gt;) and crates (&lt;code&gt;static.crates.io&lt;/code&gt;) will be
served through both &lt;a href&#x3D;&quot;https://aws.amazon.com/cloudfront/&quot;&gt;AWS CloudFront&lt;/a&gt; and
&lt;a href&#x3D;&quot;https://www.fastly.com&quot;&gt;Fastly&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is a transparent change to the infrastructure that doesn&#x27;t require users or
developers to take any action. We expect no downtime for Rust users as part of
the migration.&lt;/p&gt;
&lt;p&gt;This also covers only the CDNs for releases (&lt;code&gt;static.rust-lang.org&lt;/code&gt;) and
crates.io (&lt;code&gt;static.crates.io&lt;/code&gt;), no changes are planned for the rest of Rust&#x27;s
domains.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#timeline&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;timeline&quot;&gt;&lt;/a&gt;Timeline&lt;/h2&gt;
&lt;p&gt;We are starting the rollout of the new CDN tomorrow, on January 25th, with
&lt;code&gt;static.crates.io&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The rollout will happen very gradually over a period of time. We will start to
send a small percentage of traffic through &lt;a href&#x3D;&quot;https://www.fastly.com/&quot;&gt;Fastly&lt;/a&gt;,
while observing the performance and reliability of the new network. As we gain
confidence, we will slowly increase the amount of traffic.&lt;/p&gt;
&lt;p&gt;Once &lt;code&gt;static.crates.io&lt;/code&gt; has been deployed, we will start working on
&lt;code&gt;static.rust-lang.org&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#report-issues&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;report-issues&quot;&gt;&lt;/a&gt;Report issues&lt;/h2&gt;
&lt;p&gt;If something &lt;em&gt;does&lt;/em&gt; break, please let the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/infra&quot;&gt;Infrastructure Team&lt;/a&gt; know on
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/t-infra&quot;&gt;#t-infra on Zulip&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Jan David Nose</name>
        </author>
    </entry>
    
    <entry>
        <title>1.66.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/12/12/1.66.0-prerelease.html" type="text/html" title="1.66.0 pre-release testing" />
        <published>2022-12-12T00:00:00+00:00</published>
        <updated>2022-12-12T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/12/12/1.66.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/12/12/1.66.0-prerelease.html">&lt;p&gt;The 1.66.0 pre-release is ready for testing. The release is scheduled for
December 15. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1660-2022-12-15&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2022-12-12/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2022-12-12/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-66-0-pre-release-testing/17966&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Please welcome The 8472 to the Library team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/11/29/libs-member.html" type="text/html" title="Please welcome The 8472 to the Library team" />
        <published>2022-11-29T00:00:00+00:00</published>
        <updated>2022-11-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/11/29/libs-member.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/11/29/libs-member.html">&lt;p&gt;We&#x27;re very excited to announce that &lt;a href&#x3D;&quot;https://github.com/the8472&quot;&gt;The 8472&lt;/a&gt;
has joined &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/library&quot;&gt;the Library team&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;The 8472 has been working on &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pulls?q&#x3D;is%3Apr+author%3Athe8472&quot;&gt;many optimizations and other improvements&lt;/a&gt; to the standard library,
is &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pulls?q&#x3D;involves%3Athe8472&quot;&gt;involved in many library-related changes and discussions&lt;/a&gt;,
and regularly &lt;a href&#x3D;&quot;https://github.com/search?q&#x3D;repo%3Arust-lang%2Frust+%22r%3Dthe8472%22&amp;amp;type&#x3D;commits&amp;amp;s&#x3D;committer-date&amp;amp;o&#x3D;desc&quot;&gt;reviews&lt;/a&gt; pull requests.&lt;/p&gt;
&lt;p&gt;Congratulations The 8472, and thanks for everything you do!&lt;/p&gt;
</content>

        <author>
            <name>Mara Bos</name>
        </author>
    </entry>
    
    <entry>
        <title>Async fn in trait MVP comes to nightly</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html" type="text/html" title="Async fn in trait MVP comes to nightly" />
        <published>2022-11-17T00:00:00+00:00</published>
        <updated>2022-11-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/11/17/async-fn-in-trait-nightly.html">&lt;p&gt;The async working group is excited to announce that &lt;code&gt;async fn&lt;/code&gt; can now be used in traits in the nightly compiler. You can now write code like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(async_fn_in_trait)]

trait Database {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String;
}

impl Database for MyDb {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A full working example is available in the &lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;6ffde69ba43c6c5094b7fbdae11774a9&quot;&gt;playground&lt;/a&gt;. There are some limitations we&#x27;ll cover, as well as a few known bugs to be worked out, but we think it is ready for some users to try. Read on for the specifics.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#recap-how-asyncawait-works-in-rust&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;recap-how-asyncawait-works-in-rust&quot;&gt;&lt;/a&gt;Recap: How async/await works in Rust&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; and &lt;code&gt;.await&lt;/code&gt; were a major improvement in the ergonomics of writing async code in Rust. In Rust, an &lt;code&gt;async fn&lt;/code&gt; returns a &lt;code&gt;Future&lt;/code&gt;, which is some object that represents an ongoing asynchronous computation.&lt;/p&gt;
&lt;p&gt;The type of the future does not actually appear in the signature of an &lt;code&gt;async fn&lt;/code&gt;. When you write an async function like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn fetch_data(db: &amp;amp;MyDb) -&amp;gt; String { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler rewrites it to something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn fetch_data&amp;lt;&#x27;a&amp;gt;(db: &amp;amp;&#x27;a MyDb) -&amp;gt; impl Future&amp;lt;Output &#x3D; String&amp;gt; + &#x27;a {
    async move { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &amp;quot;desugared&amp;quot; signature is something you can write yourself, and it&#x27;s useful for examining what goes on under the hood. The &lt;code&gt;impl Future&lt;/code&gt; syntax here represents some &lt;em&gt;opaque type&lt;/em&gt; that implements &lt;code&gt;Future&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The future is a state machine responsible for knowing how to continue making progress the next time it wakes up. When you write code in an &lt;code&gt;async&lt;/code&gt; block, the compiler generates a future type specific to that async block for you. This future type does not have a name, so we must instead use an opaque type in the function signature.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-historic-problem-of-async-fn-in-trait&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-historic-problem-of-async-fn-in-trait&quot;&gt;&lt;/a&gt;The historic problem of &lt;code&gt;async fn&lt;/code&gt; in trait&lt;/h2&gt;
&lt;p&gt;Traits are the fundamental mechanism of abstraction in Rust. So what happens if you want to put an async method in a trait? Each &lt;code&gt;async&lt;/code&gt; block or function creates a unique type, so you would want to express that each implementation can have a different Future for the return type. Thankfully, we have associated types for this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Database {
    type FetchData&amp;lt;&#x27;a&amp;gt;: Future&amp;lt;Output &#x3D; String&amp;gt; + &#x27;a where Self: &#x27;a;
    fn fetch_data&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a self) -&amp;gt; FetchData&amp;lt;&#x27;a&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that this associated type is generic. Generic associated types haven&#x27;t been supported in the language... &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;until now&lt;/a&gt;! Unfortunately though, even with GATs, you still can&#x27;t write a trait &lt;em&gt;implementation&lt;/em&gt; that uses &lt;code&gt;async&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl Database for MyDb {
    type FetchData&amp;lt;&#x27;a&amp;gt; &#x3D; /* what type goes here??? */;
    fn fetch_data&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a self) -&amp;gt; FetchData&amp;lt;&#x27;a&amp;gt; { async move { ... } }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since you can&#x27;t name the type constructed by an async block, the only option is to use an opaque type (the &lt;code&gt;impl Future&lt;/code&gt; we saw earlier). But those are not supported in associated types!&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#workarounds-available-in-the-stable-compiler&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;workarounds-available-in-the-stable-compiler&quot;&gt;&lt;/a&gt;Workarounds available in the stable compiler&lt;/h3&gt;
&lt;p&gt;So to write an &lt;code&gt;async fn&lt;/code&gt; in a trait we need a concrete type to specify in our impl. There are a couple ways of achieving this today.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#runtime-type-erasure&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;runtime-type-erasure&quot;&gt;&lt;/a&gt;Runtime type erasure&lt;/h4&gt;
&lt;p&gt;First, we can avoid writing the future type by erasing it with &lt;code&gt;dyn&lt;/code&gt;. Taking our example from above, you would write your trait like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Database {
    fn fetch_data(&amp;amp;self)
    -&amp;gt; Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output &#x3D; String&amp;gt; + Send + &#x27;_&amp;gt;&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is significantly more verbose, but it achieves the goal of combining async with traits. What&#x27;s more, the &lt;a href&#x3D;&quot;https://crates.io/crates/async-trait&quot;&gt;async-trait&lt;/a&gt; proc macro crate rewrites your code for you, allowing you to simply write&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[async_trait]
trait Database {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String;
}

#[async_trait]
impl Database for MyDb {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is an excellent solution for the people who can use it!&lt;/p&gt;
&lt;p&gt;Unfortunately, not everyone can. You can&#x27;t use &lt;code&gt;Box&lt;/code&gt; in no_std contexts. Dynamic dispatch and allocation come with overhead that can be &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_benchmarks_async_trait.html&quot;&gt;overwhelming&lt;/a&gt; for highly performance-sensitive code. Finally, it bakes a lot of assumptions into the trait itself: allocation with &lt;code&gt;Box&lt;/code&gt;, dynamic dispatch, and the &lt;code&gt;Send&lt;/code&gt;-ness of the futures. This makes it unsuitable for many libraries.&lt;/p&gt;
&lt;p&gt;Besides, users &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/alan_needs_async_in_traits.html&quot;&gt;expect&lt;/a&gt; to be able to write &lt;code&gt;async fn&lt;/code&gt; in traits, and the experience of adding an external crate dependency is a papercut that gives async Rust a reputation for being difficult to use.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#manual-poll-implementations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;manual-poll-implementations&quot;&gt;&lt;/a&gt;Manual &lt;code&gt;poll&lt;/code&gt; implementations&lt;/h4&gt;
&lt;p&gt;Traits that need to work with zero overhead or in no_std contexts have another option: they can take the concept of polling from the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/future/trait.Future.html&quot;&gt;&lt;code&gt;Future&lt;/code&gt; trait&lt;/a&gt; and build it directly into their interface. The &lt;code&gt;Future::poll&lt;/code&gt; method returns &lt;code&gt;Poll::Ready(Output)&lt;/code&gt; if the future is complete and &lt;code&gt;Poll::Pending&lt;/code&gt; if the future is waiting on some other event.&lt;/p&gt;
&lt;p&gt;You can see this pattern, for example, in the current version of the unstable &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/async_iter/trait.AsyncIterator.html&quot;&gt;AsyncIterator&lt;/a&gt; trait. The signature of &lt;code&gt;AsyncIterator::poll_next&lt;/code&gt; is a cross between &lt;code&gt;Future::poll&lt;/code&gt; and &lt;code&gt;Iterator::next&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub trait AsyncIterator {
    type Item;

    fn poll_next(
        self: Pin&amp;lt;&amp;amp;mut Self&amp;gt;,
        cx: &amp;amp;mut Context&amp;lt;&#x27;_&amp;gt;
    ) -&amp;gt; Poll&amp;lt;Option&amp;lt;Self::Item&amp;gt;&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before async/await, it was very common to write manual &lt;code&gt;poll&lt;/code&gt; implementations. Unfortunately, they proved challenging to write correctly. In the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/03/18/async-vision-doc.html&quot;&gt;vision document&lt;/a&gt; process we underwent last year, we received a number of reports on how this was &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/alan_hates_writing_a_stream.html&quot;&gt;extremely difficult&lt;/a&gt; and a &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/submitted_stories/status_quo/barbara_polls_a_mutex.html&quot;&gt;source of bugs&lt;/a&gt; for Rust users.&lt;/p&gt;
&lt;p&gt;In fact, the difficulty of writing manual poll implementations was a primary reason for adding async/await to the core language in the first place.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-supported-in-nightly&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-supported-in-nightly&quot;&gt;&lt;/a&gt;What&#x27;s supported in nightly&lt;/h2&gt;
&lt;p&gt;We&#x27;ve been working to support &lt;code&gt;async fn&lt;/code&gt; directly in traits, and an implementation &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/101224&quot;&gt;recently landed&lt;/a&gt; in nightly! The feature still has some rough edges, but let&#x27;s take a look at what you can do with it.&lt;/p&gt;
&lt;p&gt;First, as you might expect, you can write and implement traits just like the above.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(async_fn_in_trait)]

trait Database {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String;
}

impl Database for MyDb {
    async fn fetch_data(&amp;amp;self) -&amp;gt; String { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One thing this will allow us to do is standardize new traits we&#x27;ve been waiting on this feature for. For example, the &lt;code&gt;AsyncIterator&lt;/code&gt; trait from above is significantly more complicated than its analogue, &lt;code&gt;Iterator&lt;/code&gt;. With the new support, we can simply write this instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(async_fn_in_trait)]

trait AsyncIterator {
    type Item;
    async fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There&#x27;s a decent chance that the trait in the standard library will end up exactly like this! For now, you can also use the one in the &lt;a href&#x3D;&quot;https://docs.rs/async-iterator/latest/async_iterator/&quot;&gt;&lt;code&gt;async_iterator&lt;/code&gt; crate&lt;/a&gt; and write generic code with it, just like you would normally.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn print_all&amp;lt;I: AsyncIterator&amp;gt;(mut count: I)
where
    I::Item: Display,
{
    while let Some(x) &#x3D; count.next().await {
        println!(&amp;quot;{x}&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#limitation-spawning-from-generics&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;limitation-spawning-from-generics&quot;&gt;&lt;/a&gt;Limitation: Spawning from generics&lt;/h3&gt;
&lt;p&gt;There is a catch! If you try to &lt;em&gt;spawn&lt;/em&gt; from a generic function like &lt;code&gt;print_all&lt;/code&gt;, and (like the majority of async users) you use a work stealing executor that requires spawned tasks to be &lt;code&gt;Send&lt;/code&gt;, you&#x27;ll hit an error which is not easily resolved.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn spawn_print_all&amp;lt;I: AsyncIterator + Send + &#x27;static&amp;gt;(mut count: I)
where
    I::Item: Display,
{
    tokio::spawn(async move {
        //       ^^^^^^^^^^^^
        // ERROR: future cannot be sent between threads safely
        while let Some(x) &#x3D; count.next().await {
            //              ^^^^^^^^^^^^
            // note: future is not &#x60;Send&#x60; as it awaits another future which is not &#x60;Send&#x60;
            println!(&amp;quot;{x}&amp;quot;);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that we added an &lt;code&gt;I: Send&lt;/code&gt; bound in the function signature, but that was not enough. To satisfy this error we need to say that the &lt;em&gt;future returned by &lt;code&gt;next()&lt;/code&gt;&lt;/em&gt; is &lt;code&gt;Send&lt;/code&gt;. But as we saw at the beginning of this post, async functions return anonymous types. There&#x27;s no way to express bounds on those types.&lt;/p&gt;
&lt;p&gt;There are potential solutions to this problem that we&#x27;ll be exploring in a follow-up post. But for now, there are a couple things you can do to get out of a situation like this.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#hypothesis-this-is-uncommon&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;hypothesis-this-is-uncommon&quot;&gt;&lt;/a&gt;Hypothesis: This is uncommon&lt;/h4&gt;
&lt;p&gt;First, you &lt;em&gt;may&lt;/em&gt; be surprised to find that this situation just doesn&#x27;t occur that often in practice. For example, we can spawn a task that invokes the above &lt;code&gt;print_all&lt;/code&gt; function &lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;nightly&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;6ffde69ba43c6c5094b7fbdae11774a9&quot;&gt;without any problem&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async fn do_something() {
    let iter &#x3D; Countdown::new(10);
    executor::spawn(print_all(iter));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works without any &lt;code&gt;Send&lt;/code&gt; bounds whatsoever! This works because &lt;code&gt;do_something&lt;/code&gt; knows the concrete type of our iterator, &lt;code&gt;Countdown&lt;/code&gt;. The compiler knows that this type is &lt;code&gt;Send&lt;/code&gt;, and that &lt;code&gt;print_all(iter)&lt;/code&gt; therefore produces a future that is &lt;code&gt;Send&lt;/code&gt;.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn3&quot; id&#x3D;&quot;fnref3&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;One hypothesis is that while people will hit this problem, they will encounter it relatively infrequently, because most of the time &lt;code&gt;spawn&lt;/code&gt; won&#x27;t be called in code that&#x27;s generic over a trait with async functions.&lt;/p&gt;
&lt;p&gt;We would like to start gathering data on people&#x27;s actual experiences with this. If you have relevant experience to share, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/103854&quot;&gt;please comment on this issue&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#when-it-does-happen&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;when-it-does-happen&quot;&gt;&lt;/a&gt;When it does happen&lt;/h4&gt;
&lt;p&gt;Eventually you probably &lt;em&gt;will&lt;/em&gt; want to spawn from a context that&#x27;s generic over an async trait that you call. What then!?&lt;/p&gt;
&lt;p&gt;For now it&#x27;s possible to use another new nightly-only feature, &lt;code&gt;return_position_impl_trait_in_trait&lt;/code&gt;, to express the bound you need directly in your trait:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(return_position_impl_trait_in_trait)]

trait SpawnAsyncIterator: Send + &#x27;static {
    type Item;
    fn next(&amp;amp;mut self) -&amp;gt; impl Future&amp;lt;Output &#x3D; Option&amp;lt;Self::Item&amp;gt;&amp;gt; + Send + &#x27;_;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we&#x27;ve &lt;em&gt;desugared&lt;/em&gt; our &lt;code&gt;async fn&lt;/code&gt; to a regular function returning &lt;code&gt;impl Future + &#x27;_&lt;/code&gt;, which works just like normal &lt;code&gt;async fn&lt;/code&gt;s do. It&#x27;s more verbose, but it gives us a place to put a &lt;code&gt;+ Send&lt;/code&gt; bound! What&#x27;s more, you can continue to use &lt;code&gt;async fn&lt;/code&gt; in an &lt;code&gt;impl&lt;/code&gt; of this trait.&lt;/p&gt;
&lt;p&gt;The downside of this approach is that the trait becomes less generic, making it less suitable for library code. If you want to maintain two separate versions of a trait, you can do that, and (perhaps) provide macros to make it easier to implement both.&lt;/p&gt;
&lt;p&gt;This solution is intended to be temporary. We&#x27;d like to implement a better solution in the language itself, but since this is a nightly-only feature we prefer to get more people trying it out as soon as possible.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#limitation-dynamic-dispatch&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;limitation-dynamic-dispatch&quot;&gt;&lt;/a&gt;Limitation: Dynamic dispatch&lt;/h3&gt;
&lt;p&gt;There&#x27;s one final limitation: You can&#x27;t call an &lt;code&gt;async fn&lt;/code&gt; with a &lt;code&gt;dyn Trait&lt;/code&gt;. Designs to support this exist&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn4&quot; id&#x3D;&quot;fnref4&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;, but are in the earlier stages. If you need dynamic dispatch from a trait, you&#x27;re better off using the &lt;code&gt;async_trait&lt;/code&gt; macro for now.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#path-to-stabilization&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;path-to-stabilization&quot;&gt;&lt;/a&gt;Path to stabilization&lt;/h2&gt;
&lt;p&gt;The async working group would like to get something useful in the hands of Rust users, even if it doesn&#x27;t do &lt;em&gt;everything&lt;/em&gt; they might want. That&#x27;s why despite having some limitations, the current version of &lt;code&gt;async fn&lt;/code&gt; in traits might not be far off from stabilization.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn5&quot; id&#x3D;&quot;fnref5&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; You can follow progress by watching the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/91611&quot;&gt;tracking issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There are two big questions to answer first:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Do we need to solve the &amp;quot;spawning from generics&amp;quot; (&lt;code&gt;Send&lt;/code&gt; bound) problem first?&lt;/strong&gt; Please leave feedback on &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/103854&quot;&gt;this issue&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;What other bugs and quality issues exist?&lt;/strong&gt; Please file &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;new issues&lt;/a&gt; for these. You can view &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/labels/F-async_fn_in_trait&quot;&gt;known issues here&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&#x27;re an async Rust enthusiast and are willing to try experimental new features, we&#x27;d very much appreciate it if you gave it a spin!&lt;/p&gt;
&lt;p&gt;If you use &lt;code&gt;#[async_trait]&lt;/code&gt;, you can try removing it from some traits (and their impls) where you don&#x27;t use dynamic dispatch. Or if you&#x27;re writing new async code, try using it there. Either way, you can tell us about your experience at the links above.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This work was made possible thanks to the efforts of many people, including&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Michael Goulet&lt;/li&gt;
&lt;li&gt;Santiago Pastorino&lt;/li&gt;
&lt;li&gt;Oli Scherer&lt;/li&gt;
&lt;li&gt;Eric Holk&lt;/li&gt;
&lt;li&gt;Dan Johnson&lt;/li&gt;
&lt;li&gt;Bryan Garza&lt;/li&gt;
&lt;li&gt;Niko Matsakis&lt;/li&gt;
&lt;li&gt;Tyler Mandry&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition it was built on top of years of compiler work that enabled us to ship &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;GATs&lt;/a&gt; as well as other fundamental type system improvements. We&#x27;re deeply grateful to all those who contributed; this work would not be possible without you. Thank you!&lt;/p&gt;
&lt;p&gt;To learn more about this feature and the challenges behind it, check out the &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/3185-static-async-fn-in-trait.html&quot;&gt;Static async fn in traits RFC&lt;/a&gt; and &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2019/10/26/async-fn-in-traits-are-hard/&quot;&gt;why async fn in traits are hard&lt;/a&gt;. Also stay tuned for a follow-up post where we explore language extensions that make it possible to express &lt;code&gt;Send&lt;/code&gt; bounds without a special trait.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to Yoshua Wuyts, Nick Cameron, Dan Johnson, Santiago Pastorino, Eric Holk, and Niko Matsakis for reviewing a draft of this post.&lt;/em&gt;&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;This feature is called &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2515-type_alias_impl_trait.html&quot;&gt;&amp;quot;type alias impl trait&amp;quot;&lt;/a&gt;. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;The actual error message produced by the compiler is a bit noisier than this, but that will be improved. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn3&quot;&gt;
&lt;p&gt;Auto traits such as &lt;code&gt;Send&lt;/code&gt; and &lt;code&gt;Sync&lt;/code&gt; are special in this way. The compiler knows that the return type of &lt;code&gt;print_all&lt;/code&gt; is &lt;code&gt;Send&lt;/code&gt; if and only if the type of its argument &lt;code&gt;Send&lt;/code&gt;, and unlike with regular traits, it is allowed to use this knowledge when type checking your program. &lt;a href&#x3D;&quot;#fnref3&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn4&quot;&gt;
&lt;p&gt;See &lt;a href&#x3D;&quot;https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_dyn_trait.html&quot;&gt;Async fn in dyn trait&lt;/a&gt; on the initiative website, as well as posts 8 and 9 in &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2022/09/21/dyn-async-traits-part-9-callee-site-selection/&quot;&gt;this series&lt;/a&gt;. &lt;a href&#x3D;&quot;#fnref4&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn5&quot;&gt;
&lt;p&gt;When? Possibly sometime in the next six months or so. But don&#x27;t hold me to it :) &lt;a href&#x3D;&quot;#fnref5&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Tyler Mandry</name>
        </author>
    </entry>
    
    <entry>
        <title>1.65.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/10/31/1.65.0-prerelease.html" type="text/html" title="1.65.0 pre-release testing" />
        <published>2022-10-31T00:00:00+00:00</published>
        <updated>2022-10-31T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/10/31/1.65.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/10/31/1.65.0-prerelease.html">&lt;p&gt;The 1.65.0 pre-release is ready for testing. The release is scheduled for
November 03. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1650-2022-11-03&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2022-10-31/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2022-10-31/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-65-0-pre-release-testing/17660&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance Update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/10/06/governance-update.html" type="text/html" title="Governance Update" />
        <published>2022-10-06T00:00:00+00:00</published>
        <updated>2022-10-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/10/06/governance-update.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/10/06/governance-update.html">&lt;p&gt;As part of ongoing work on governance, Rust leadership jointly established a group, &amp;quot;leadership chat&amp;quot;, consisting of the Core team, leads of all teams on the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance&quot;&gt;governance page&lt;/a&gt;, the Moderation team, and the project directors on the Rust Foundation board. This group has been serving as an interim governing body while efforts to establish the next evolution of Rust project-wide governance are underway.&lt;/p&gt;
&lt;p&gt;We previously posted &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html&quot;&gt;an update on the future of Rust project-wide governance&lt;/a&gt;. In that post, we promised that the next steps would be to &amp;quot;take the findings we have so far and begin crafting proposals for how the Rust project will be governed in the future.&amp;quot; In this post, we&#x27;d like to provide an update on the status of this work.&lt;/p&gt;
&lt;p&gt;Late in July, the interim leadership team established an informal working group to conduct further research and draft an RFC for the establishment of a new project-wide governing body. This RFC relies on the requirements document&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; that was compiled as a result of in-depth interviews conducted by Ryan Levick and Mara Bos with team members from across the Rust project. Currently, there are seven people involved in this working group: Ryan Levick (Core Project Director), JT (Core), Mark Rousskov (Core Project Director, Release Lead), Jane Losare-Lusby (Collaboration Project Director), Josh Triplett (Lang Team Lead), Josh Gould (Moderation), and Khionu Sybiern (Moderation).&lt;/p&gt;
&lt;p&gt;The working group&#x27;s objective is not to completely re-engineer every aspect of Rust&#x27;s governance model — that would require the participation and consent of all the other teams working in the project — but rather to lay the foundation for dynamic project-wide governance by introducing policies and procedures for constraining, monitoring, and adjusting the governance model in response to the project&#x27;s evolving needs. As part of this work, not only is explicit attention being paid to the issues that led to the resignation of the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2021/11/25/in-response-to-the-moderation-team-resignation.html&quot;&gt;former mod team&lt;/a&gt; last November but also additional governance shortfalls identified through Ryan&#x27;s and Mara&#x27;s research. At the same time, we&#x27;re deliberately keeping the scope small in the hope of getting out of the way as soon as possible to let the work continue under the new more representative and accountable governance body.&lt;/p&gt;
&lt;p&gt;According to our current projections, we are roughly halfway through drafting this RFC since the process began at the end of August. We&#x27;re still making steady progress, and when we have a full draft, we&#x27;ll post it for project-wide review. In the interest of transparency, we will continue to publish updates until the RFC is made available. The goal of keeping the initial discussions private is not to exclude people, but rather to keep the size of the group discussions manageable&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; during the early stages of the RFC drafting process. We are completely open to sharing early drafts and discussing current plans outside of our weekly meetings. Any project participants with questions or concerns are encouraged to get in touch with the working group&#x27;s members.&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;Which can be found in the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html&quot;&gt;previous governance update post&lt;/a&gt; &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;Even with &amp;quot;only&amp;quot; seven people, having discussions of this magnitude is difficult. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Ryan Levick</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Rust Style Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/09/29/announcing-the-rust-style-team.html" type="text/html" title="Announcing the Rust Style Team" />
        <published>2022-09-29T00:00:00+00:00</published>
        <updated>2022-09-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/09/29/announcing-the-rust-style-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/09/29/announcing-the-rust-style-team.html">&lt;p&gt;Rust has a standardized style, and an implementation of that style in the
&lt;code&gt;rustfmt&lt;/code&gt; tool. The standardized style helps Rust developers feel comfortable
and at home in many different projects, and the tooling support from &lt;code&gt;rustfmt&lt;/code&gt;
makes it easy to maintain and to incorporate in continuous integration.
&lt;code&gt;rustfmt&lt;/code&gt; also provides many options to customize the style, but the style
guide defines the defaults, and most projects use those defaults.&lt;/p&gt;
&lt;p&gt;The standard Rust style resulted from development and discussion within the
Rust style team, between 2016 and 2018. After publishing the style guide, the
Rust style team concluded its active work, by design.&lt;/p&gt;
&lt;p&gt;However, as the Rust language develops, we have a regular need for improvements
to the style guide, such as to support new language constructs. This includes
minor language changes, as well as highly anticipated new features such as
&lt;code&gt;let&lt;/code&gt;-chaining (RFC 2497) and &lt;code&gt;let&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; (RFC 3137). New constructs like
these, by default, get ignored and not formatted by rustfmt, and subsequently
need formatting added. Some of this work has fallen to the rustfmt team in
recent years, but the rustfmt team would prefer to implement style
determinations made by another team rather than making such determinations
itself.&lt;/p&gt;
&lt;p&gt;In addition, rustfmt maintains backwards compatibility guarantees: code that
has been correctly formatted with rustfmt won&#x27;t get formatted differently with
a future version of rustfmt. This avoids churn, and avoids creating CI failures
when people use rustfmt to check style in CI. However, this also prevents
evolving the Rust style to take community desires into account and improve
formatting over time. rustfmt provides various configuration options to change
its default formatting, and many of those options represent changes that many
people in the community would like enabled by default.&lt;/p&gt;
&lt;p&gt;For instance, many people prefer to format their &lt;code&gt;use&lt;/code&gt; lines in three blocks:
imports from the standard library, imports from external crates, and then
imports from modules within the same project. &lt;code&gt;rustfmt&lt;/code&gt; supports this via the
option &lt;code&gt;group_imports &#x3D; StdExternalCrate&lt;/code&gt;, but cannot make this the default
without causing CI failures in existing projects. We need a way to evolve the
default Rust style compatibly, similar in spirit to the mechanisms we use for
Rust editions: allowing existing style to continue working, and allowing people
to opt into new style.&lt;/p&gt;
&lt;p&gt;To solve both of these problems, &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/3309-style-team.html&quot;&gt;RFC
3309&lt;/a&gt; has revived the
Rust style team, with three goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Making determinations about styling for new Rust constructs&lt;/li&gt;
&lt;li&gt;Evolving the existing Rust style&lt;/li&gt;
&lt;li&gt;Defining mechanisms to evolve the Rust style while taking backwards
compatibility into account&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We don&#x27;t plan to make any earth-shattering style changes; the look and feel of
Rust will remain largely the same. Evolutions to the default Rust style will
largely consist of established &lt;code&gt;rustfmt&lt;/code&gt; options people already widely enable,
or would enable if they were stable.&lt;/p&gt;
&lt;p&gt;We expect that the initial work of the style team will focus on clearing a
backlog of new language constructs that lack formatting guidance. Afterwards,
we will look towards defining and implementing the mechanisms to evolve the
default Rust style, and then begin introducing style improvements.&lt;/p&gt;
</content>

        <author>
            <name>Josh Triplett</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Compiler Early October 2022 Steering Cycle</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/09/23/compiler-team-sep-oct-steering-cycle.html" type="text/html" title="Rust Compiler Early October 2022 Steering Cycle" />
        <published>2022-09-23T00:00:00+00:00</published>
        <updated>2022-09-23T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/09/23/compiler-team-sep-oct-steering-cycle.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/09/23/compiler-team-sep-oct-steering-cycle.html">&lt;p&gt;On &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bplanning.20meeting.5D.202022-09-23/near/300372578&quot;&gt;Friday, September 23rd&lt;/a&gt;, the Rust Compiler team had a planning meeting for the September/October 2022 steering cycle.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#t-compiler-june-steering-schedule&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;t-compiler-june-steering-schedule&quot;&gt;&lt;/a&gt;T-compiler June Steering Schedule&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Meeting Id&lt;/th&gt;
&lt;th&gt;Meeting Topic&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;Mm9tM2VzOWszaWw0Z3RudWlhNzF0ZHMwbzMgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2022-09-30&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/559&quot;&gt;compiler-team#559&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2022 Q3 P-high review&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;NnA2bWtoaGQ5NnVudGkwdnM5aWZ1YmpqNG0gNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2022-10-07&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/544&quot;&gt;compiler-team#544&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Survey retrospective&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;NW52ZGNhYzVrbWJxdG0yOTBpN2Q2ZmExaXIgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2022-10-14&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/540&quot;&gt;compiler-team#540&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dealing with disabled tests&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;MDJyYnJ1cGFtdWR1c2lnNjFmcHJ2b3JlODFfMjAyMjEwMjFUMTQwMDAwWiA2dTVycnRjZTZscnR2MDdwZmkzZGFtZ2p1c0Bn&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&amp;amp;scp&#x3D;ALL&quot;&gt;2022-10-21&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;(planning for October/November cycle)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#details&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;details&quot;&gt;&lt;/a&gt;Details&lt;/h3&gt;
&lt;p&gt;Every fourth Friday, the Rust compiler team decides how
it is going to use its scheduled steering and design meeting time over the next
three Fridays.&lt;/p&gt;
&lt;p&gt;On Friday, 30 September, we will do a quarterly &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/559&quot;&gt;review of the open P-high issues&lt;/a&gt;.
pnkfelix will do some ahead of time work &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/reviewing.20P-high.20issues.202022.20.28Q3.29/near/300390068&quot;&gt;in zulip&lt;/a&gt;
triaging
some of the issues, and potentially prepare a meeting document summarizing the
remainder, to maximize the quality of our synchronous in-meeting time.&lt;/p&gt;
&lt;p&gt;On Friday, 7 October, we will do a &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/544&quot;&gt;retrospective&lt;/a&gt; on the 2022 T-compiler surveys
that were used to drive the February ambitions post and the midyear update post.
We will talk about the questions that were asked, what we wish had been asked,
what value we got from the survey as it went, and what to do the same and/or
differently in the future. (In principle, this meeting should inform the way
that we drive the retrospective on how the year as a whole went for the compiler
team.)&lt;/p&gt;
&lt;p&gt;On Friday, 14 October, we will discuss how to &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/540&quot;&gt;deal with &amp;quot;disabled tests&amp;quot;&lt;/a&gt;:
tests that are turned off at some point (e.g. due to failures in a component we
do not control). We do not currently have any protocols in place to review such
tests or decide when to try to re-enabling them.&lt;/p&gt;
&lt;p&gt;On Friday, 21 October, we will hold our planning meeting for the next steering
cycle in October and November.&lt;/p&gt;
&lt;p&gt;Each meeting will run from 2pm to 3pm GMT, and will take place on the
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings&quot;&gt;T-compiler/meetings zulip stream&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
</feed>

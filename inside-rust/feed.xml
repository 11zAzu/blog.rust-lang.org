<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2020-10-23T15:00:36+00:00</updated>

    
    <entry>
        <title>Core team membership changes</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/10/23/Core-team-membership.html" type="text/html" title="Core team membership changes" />
        <published>2020-10-23T00:00:00+00:00</published>
        <updated>2020-10-23T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/10/23/Core-team-membership.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/10/23/Core-team-membership.html">&lt;p&gt;The core team has had a few membership updates in the last month, and we wanted to provide an update.&lt;/p&gt;
&lt;p&gt;To start, Florian Gilcher is joining the Core team as a full member. Florian has been attending meetings as an observer since March 2019. He is the lead of the Community Events team, and has done a lot of work in the open source world, with plenty of insight to offer especially as we look to form a Rust Foundation.&lt;/p&gt;
&lt;p&gt;There are also two folks stepping back from the team. Carol Nichols has been a member of the team for three years, and she is stepping back to make more time for other projects in the community, including crates.io and her continued work on the Rust book. Nick Cameron &lt;a href&#x3D;&quot;https://www.ncameron.org/blog/leaving-the-rust-core-team/&quot;&gt;has recently welcomed a second child&lt;/a&gt; (congratulations!) and is leaving the core team to be able to focus more on his family and his work at PingCAP. He will continue to be around in the Rust community. Thanks to both Carol and Nick for their hard work over the years — we’ll miss you!&lt;/p&gt;
</content>

        <author>
            <name>Mark Rousskov</name>
        </author>
    </entry>
    
    <entry>
        <title>Lang team Backlog Bonanza and Project Proposals</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/10/16/Backlog-Bonanza.html" type="text/html" title="Lang team Backlog Bonanza and Project Proposals" />
        <published>2020-10-16T00:00:00+00:00</published>
        <updated>2020-10-16T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/10/16/Backlog-Bonanza.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/10/16/Backlog-Bonanza.html">&lt;p&gt;A month or two back, the lang team embarked on a new initiative that
we call the &amp;quot;Backlog Bonanza&amp;quot;. The idea is simple: we are holding a
series of meetings in which we go through every pending RFC, one by
one, and try to reach some sort of determination about what to do with
it.  Once we&#x27;ve finished that, we can start in on categorizing other
forms of backlog, such as tracking issues.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#possible-outcomes-for-each-rfc&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;possible-outcomes-for-each-rfc&quot;&gt;&lt;/a&gt;Possible outcomes for each RFC&lt;/h3&gt;
&lt;p&gt;When we look at an RFC, we&#x27;re typically deciding between one of the following outcomes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Close&lt;/strong&gt; the RFC, if the problem doesn&#x27;t seem like high priority at the moment, or the solution seems quite far from what we would want.&lt;/li&gt;
&lt;li&gt;Close, but &lt;strong&gt;suggest a &lt;a href&#x3D;&quot;https://lang-team.rust-lang.org/proposing_a_project.html&quot;&gt;project proposal&lt;/a&gt;&lt;/strong&gt;, if we think that the we might like to see the problem solved, but we aren&#x27;t sure if the RFC has the design right, or we&#x27;re not sure who would be a good liaison.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Merge&lt;/strong&gt; the RFC, if we think the RFC basically nailed it and we have a lang team liaison in mind.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#wait-what-is-a-project-proposal&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;wait-what-is-a-project-proposal&quot;&gt;&lt;/a&gt;Wait, what is a project proposal?&lt;/h3&gt;
&lt;p&gt;I&#x27;m so glad you asked! The lang team is experimenting with a new
process for extending the language. Instead of starting out by writing
an RFC, the idea is to start with a &lt;strong&gt;&lt;a href&#x3D;&quot;https://lang-team.rust-lang.org/proposing_a_project.html&quot;&gt;project proposal&lt;/a&gt;&lt;/strong&gt;. This is a
lightweight description that you do by &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/issues/new/choose&quot;&gt;opening an issue&lt;/a&gt; on the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/&quot;&gt;lang-team repository&lt;/a&gt; using the &amp;quot;Project proposal&amp;quot; template. That
will create an issue and a corresponding stream on Zulip.&lt;/p&gt;
&lt;p&gt;In our &lt;a href&#x3D;&quot;https://lang-team.rust-lang.org/meetings.html&quot;&gt;weekly triage meetings&lt;/a&gt;, we go over each new project proposal
and try to provide feedback. Project proposals generally result in one
of a few possible outcomes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Close&lt;/strong&gt;, if we feel like the idea isn&#x27;t a good fit right now.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Suggest implementing&lt;/strong&gt;, if we feel like the idea is simple or obvious enough that an RFC isn&#x27;t really needed. In that case, folks can just write a PR and we can use the fcp process to approve the PR.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Charter a project group&lt;/strong&gt;, if we feel like the idea is good, but we&#x27;d like to see the design spelled out. To do this, there has to be some lang-team liaison who wants to help see it through (though that liaison doesn&#x27;t have to be a member of the team; &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2020/07/09/lang-team-path-to-membership.html&quot;&gt;serving as a liaison is a good way to get more involved in the lang team&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#chartering-a-project-group&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;chartering-a-project-group&quot;&gt;&lt;/a&gt;Chartering a project group&lt;/h3&gt;
&lt;p&gt;A &amp;quot;project group&amp;quot; is basically just a group of people working together
completing some idea. Project groups are often pretty small, just 1 or 2
people, though they can get significantly larger.&lt;/p&gt;
&lt;p&gt;Creating a smaller project group is meant to be lightweight. We
basically convert the project proposal into a charter that states the
general goals and create an associated zulip stream where folks can
chat. Each project also gets a tracking issue that shows up on our
&lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/projects/2&quot;&gt;lang team project board&lt;/a&gt;. (For larger project groups, we can make a
dedicated repo and an entry in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/team&quot;&gt;Rust team repo&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;In the early stages of an idea, project groups work to draft an
RFC. This RFC is then taken to the lang-team for feedback. Once the
lang-team is basically happy on the direction things are going, we&#x27;ll
encourage the group to open the RFC on the main RFC repository, where
it&#x27;ll get feedback from a broader audience.&lt;/p&gt;
&lt;p&gt;Once the RFC is &lt;strong&gt;accepted&lt;/strong&gt;, the hope is that project groups stick
around. If desired, the same folks can try to implement the feature
(in collaboration with the compiler team) or we can find new people.
But this way, as those people try to implement, they&#x27;ll become a part
of the same group that was designing the feature so that we can
iterate more readily. The same logic applies to the other aspects of
shipping a feature, most notably writing documentation.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#tracking-projects-the-lang-team-project-board&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;tracking-projects-the-lang-team-project-board&quot;&gt;&lt;/a&gt;Tracking projects: the lang team project board&lt;/h3&gt;
&lt;p&gt;I mentioned the &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/projects/2&quot;&gt;lang team project board&lt;/a&gt; off-hand in the previous
paragraph. This is our attempt to track the ongoing efforts. It breaks
down the various projects into stages, with the things that are closest
to shipping coming first:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Stabilization&lt;/strong&gt; -- projects that we are ready to stabilize, or in
the process of stabilizing.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Evaluation&lt;/strong&gt; -- projects that are fully implemented but where we are
seeking feedback on how well the design works.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Implementation&lt;/strong&gt; -- projects that are currently working on implementation
(and sometimes concurrent design iteration).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pending RFC&lt;/strong&gt; -- projects with an RFC that is pending public comment&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Design&lt;/strong&gt; -- projects actively iterating towards an RFC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shortlisted&lt;/strong&gt; -- project ideas that we might want to take up once we
find a suitable liaison or people have enough bandwidth&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#ways-to-get-involved&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;ways-to-get-involved&quot;&gt;&lt;/a&gt;Ways to get involved&lt;/h3&gt;
&lt;p&gt;If you like, you are welcome to attend backlog bonanza meetings. They
are open for anyone and take place during our &lt;a href&#x3D;&quot;https://lang-team.rust-lang.org/meetings.html&quot;&gt;design meeting&lt;/a&gt;
most weeks. We haven&#x27;t setup a very good process for announcing our
design meeting schedule, though, that&#x27;s something that we need to get
better at.&lt;/p&gt;
&lt;p&gt;Alternatively, if you have ideas you&#x27;d like to float, please feel free
to open a &lt;a href&#x3D;&quot;https://lang-team.rust-lang.org/proposing_a_project.html&quot;&gt;project proposal&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Nicholas Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>1.47.0 second pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/10/07/1.47.0-prerelease-2.html" type="text/html" title="1.47.0 second pre-release testing" />
        <published>2020-10-07T00:00:00+00:00</published>
        <updated>2020-10-07T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/10/07/1.47.0-prerelease-2.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/10/07/1.47.0-prerelease-2.html">&lt;p&gt;The second pre-release for 1.47.0 is ready for testing. The release is
scheduled for this Thursday, October 8th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1470-2020-10-08&quot;&gt;Release notes can be found
here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2020-10-07/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2020-10-07/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/1-47-0-pre-release-testing/&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Compared to the first pre-release, this one contains a fix for issue &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/76980&quot;&gt;#76980&lt;/a&gt;,
the last known regression of 1.47.0. We&#x27;re interested in additional testing of
this pre-release, as it includes that last-minute change.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>1.47.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/10/06/1.47.0-prerelease.html" type="text/html" title="1.47.0 pre-release testing" />
        <published>2020-10-06T00:00:00+00:00</published>
        <updated>2020-10-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/10/06/1.47.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/10/06/1.47.0-prerelease.html">&lt;p&gt;The 1.47.0 pre-release is ready for testing. The release is scheduled for this
Thursday, October 8th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1470-2020-10-08&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2020-10-06/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2020-10-06/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/1-47-0-pre-release-testing/&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Additionally, the release team is still investigating a regression in procedural
macros which include C++ code, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/76980&quot;&gt;#76980&lt;/a&gt;, and are interested in feedback and help
from the community in figuring out a resolution to that bug.&lt;/p&gt;
</content>

        <author>
            <name>Mark Rousskov</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Portable SIMD Project Group</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/09/29/Portable-SIMD-PG.html" type="text/html" title="Announcing the Portable SIMD Project Group" />
        <published>2020-09-29T00:00:00+00:00</published>
        <updated>2020-09-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/09/29/Portable-SIMD-PG.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/09/29/Portable-SIMD-PG.html">&lt;p&gt;We&#x27;re announcing the start of the &lt;em&gt;Portable SIMD Project Group&lt;/em&gt; within the Libs team. This group is dedicated to making a portable SIMD API available to stable Rust users.&lt;/p&gt;
&lt;p&gt;The Portable SIMD Project Group is lead by &lt;a href&#x3D;&quot;https://github.com/calebzulawski&quot;&gt;@calebzulawski&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/Lokathor&quot;&gt;@Lokathor&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/workingjubilee&quot;&gt;@workingjubilee&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-are-project-groups&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-are-project-groups&quot;&gt;&lt;/a&gt;What are project groups?&lt;/h2&gt;
&lt;p&gt;Rust uses &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2856-project-groups.html&quot;&gt;project groups&lt;/a&gt; to help coordinate work.
They&#x27;re a place for people to get involved in helping shape the parts of Rust that matter to them.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-simd&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-simd&quot;&gt;&lt;/a&gt;What is SIMD?&lt;/h2&gt;
&lt;p&gt;SIMD stands for Single Instruction, Multiple Data.
It lets the CPU apply a single instruction to a &amp;quot;vector&amp;quot; of data.
The vector is a single extra-wide CPU register made of multiple &amp;quot;lanes&amp;quot; of the same data type.
You can think of it as being &lt;em&gt;similar&lt;/em&gt; to an array.
Instead of processing each lane individually, all lanes have the same operation applied &lt;em&gt;simultaneously&lt;/em&gt;.
This lets you transform data much faster than with standard code.
Not every problem can be accelerated with &amp;quot;vectorized&amp;quot; code, but for multimedia and list-processing applications there can be significant gains.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#why-do-you-need-to-make-it-portable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-do-you-need-to-make-it-portable&quot;&gt;&lt;/a&gt;Why do you need to make it portable?&lt;/h2&gt;
&lt;p&gt;Different chip vendors offer different SIMD instructions.
Some of these are available in Rust&#x27;s &lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/arch/index.html&quot;&gt;&lt;code&gt;std::arch&lt;/code&gt;&lt;/a&gt; module.
You &lt;em&gt;can&lt;/em&gt; build vectorized functions using that, but at the cost of maintaining a different version for each CPU you want to support.
You can also &lt;em&gt;not&lt;/em&gt; write vectorized operations and hope that LLVM&#x27;s optimizations will &amp;quot;auto-vectorize&amp;quot; your code.
However, the auto-vectorizer is easily confused and can fail to optimize &amp;quot;obvious&amp;quot; vector tasks.&lt;/p&gt;
&lt;p&gt;The portable SIMD API will enable writing SIMD code just once using a high-level API.
By explicitly communicating your intent to the compiler, it&#x27;s better able to generate the best possible final code.
This is still only a best-effort process.
If your target doesn&#x27;t support a desired operation in SIMD, the compiler will fall back to using scalar code, processing one lane at a time.
The details of what&#x27;s available depend on the build target.&lt;/p&gt;
&lt;p&gt;We intend to release the Portable SIMD API as &lt;code&gt;std::simd&lt;/code&gt;.
We will cover as many use cases as we can, but it might still be appropriate for you to use &lt;code&gt;std::arch&lt;/code&gt; directly.
For that reason the &lt;code&gt;std::simd&lt;/code&gt; types will also be easily convertable to &lt;code&gt;std::arch&lt;/code&gt; types where needed.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#how-can-i-get-involved&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-can-i-get-involved&quot;&gt;&lt;/a&gt;How can I get involved?&lt;/h2&gt;
&lt;p&gt;Everyone can get involved!
No previous experience necessary.
If you&#x27;d like to help make portable SIMD a reality you can visit our &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-portable-simd&quot;&gt;GitHub repository&lt;/a&gt; or reach out on &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd&quot;&gt;Zulip&lt;/a&gt; and say hi! :wave:&lt;/p&gt;
</content>

        <author>
            <name>Jubilee and Lokathor</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Error Handling Project Group</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/09/18/error-handling-wg-announcement.html" type="text/html" title="Announcing the Error Handling Project Group" />
        <published>2020-09-18T00:00:00+00:00</published>
        <updated>2020-09-18T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/09/18/error-handling-wg-announcement.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/09/18/error-handling-wg-announcement.html">&lt;p&gt;Today we are announcing the formation of a new project group under
the libs team, focused on error handling!&lt;/p&gt;
&lt;p&gt;Some of the goals this project group will be working on include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Defining and codifying common error handling terminology.&lt;/li&gt;
&lt;li&gt;Generating consensus on current error handling best practices.&lt;/li&gt;
&lt;li&gt;Identifying pain points that exist in Rust’s error handling story.&lt;/li&gt;
&lt;li&gt;Communicating current error handling best practices.&lt;/li&gt;
&lt;li&gt;Consolidating the Rust error handling ecosystem.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This new project group is being shepherded by Jane Lusby
(&lt;a href&#x3D;&quot;https://github.com/yaahc&quot;&gt;@yaahc&lt;/a&gt;) and Sean Chen
(&lt;a href&#x3D;&quot;https://github.com/seanchen1991&quot;&gt;@seanchen1991&lt;/a&gt;), with Andrew
Gallant (&lt;a href&#x3D;&quot;https://github.com/burntsushi&quot;&gt;@BurntSushi&lt;/a&gt;) acting in
an advisory capacity and Ashley Mannix
(&lt;a href&#x3D;&quot;https://github.com/KodrAus&quot;&gt;@KodrAus&lt;/a&gt;) acting as the library team
liaison.&lt;/p&gt;
&lt;p&gt;Anyone interested in helping out with the above goals is invited to
come say hi in the group’s  &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/257204-project-error-handling&quot;&gt;Zulip stream&lt;/a&gt;. Feel free to also check
out the group’s &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling&quot;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Sean Chen</name>
        </author>
    </entry>
    
    <entry>
        <title>Intra-doc links close to stabilization</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/09/17/stabilizing-intra-doc-links.html" type="text/html" title="Intra-doc links close to stabilization" />
        <published>2020-09-17T00:00:00+00:00</published>
        <updated>2020-09-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/09/17/stabilizing-intra-doc-links.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/09/17/stabilizing-intra-doc-links.html">&lt;p&gt;We&#x27;re excited to share that intra-doc links are stabilizing soon!&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/rustdoc/unstable-features.html#linking-to-items-by-name&quot;&gt;Intra-doc links&lt;/a&gt; are a feature of &lt;code&gt;rustdoc&lt;/code&gt; that allow you to link to &#x27;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/reference/items.html&quot;&gt;items&lt;/a&gt;&#x27; - functions, types, and more - by their name, instead of a hard-coded URL. This lets you have accurate links even if your types are &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/32129&quot;&gt;re-exported in a different module or crate&lt;/a&gt;. Here is a simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;/// Link to [&#x60;f()&#x60;]
pub struct S;

pub fn f() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Intra-doc links have been around for a while, all the way back &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/43466&quot;&gt;since 2017&lt;/a&gt;! They have been available on &lt;code&gt;nightly&lt;/code&gt; without flags (and thus, on &lt;a href&#x3D;&quot;https://docs.rs&quot;&gt;docs.rs&lt;/a&gt;), so you may be surprised to hear that they weren&#x27;t yet stable. What&#x27;s changing now is that they will be available on stable Rust, which also means we are more confident in the implementation and would strongly encourage their use. We recommend that you switch your libraries to use intra-doc links, which will fix broken links for re-exported types and links to different crates. We hope to add support for automating this process with &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/75805&quot;&gt;&lt;code&gt;cargo fix&lt;/code&gt;&lt;/a&gt; in the future.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-history-of-intra-doc-links&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-history-of-intra-doc-links&quot;&gt;&lt;/a&gt;The history of intra-doc links&lt;/h2&gt;
&lt;p&gt;I (Manish) and &lt;a href&#x3D;&quot;https://github.com/QuietMisdreavus&quot;&gt;QuietMisdreavus&lt;/a&gt; started working on them in December 2017. Mozilla had given the whole company a couple weeks off after the release of &lt;a href&#x3D;&quot;https://blog.mozilla.org/blog/2017/11/14/introducing-firefox-quantum/&quot;&gt;Firefox Quantum&lt;/a&gt;, and I was visiting family in Mumbai. This meant that I had a fair amount of free time, and we were in diametrically opposite timezones. QuietMisdreavus had been working on the feature for a while but was less familiar with rustc&#x27;s path resolution code, so I decided to help. We ended up pairing for those few weeks: during the day I&#x27;d write some code, discuss with QuietMisdreavus in the evening, and then hand it over for her to continue overnight. It was a great experience, pairing in open source can be really fun! This ended up in a &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/47046/commits&quot;&gt;46-commit pull request&lt;/a&gt; with commits from both of us.&lt;/p&gt;
&lt;p&gt;Unfortunately, we were not able to stabilize the feature at the time. The main blocker was &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/65983&quot;&gt;cross-crate re-exports&lt;/a&gt;, things like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// Crate &#x60;inner&#x60;
/// Link to [&#x60;f()&#x60;]
pub struct S;
pub fn f() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// outer crate
pub use inner::S;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The way &lt;code&gt;rustdoc&lt;/code&gt; handles reexports is that it renders the reexport in-situ, parsing and rendering all of the markdown. The issue here is that &lt;code&gt;rustdoc&lt;/code&gt;, when documenting &lt;code&gt;outer&lt;/code&gt;, does not have access to the local scope information of &lt;code&gt;inner::S&lt;/code&gt; and cannot resolve &lt;code&gt;f()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;These links were the original motivation for intra-doc links, so if we couldn&#x27;t get them working, there wasn&#x27;t much point in stabilizing! They also had the downside that they could &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/43466#issuecomment-570100948&quot;&gt;silently break&lt;/a&gt; - the documentation would work when you built it, but any user of your API could re-export your types and cause the links to be broken.&lt;/p&gt;
&lt;p&gt;At the time, persisting local scope information so that &lt;code&gt;rustdoc&lt;/code&gt; invocations on downstream crates could access them would involve a significant amount of work on the compiler. It was work the compiler team wanted to be done anyway, but it was a lot, and neither of us had the bandwidth to do it, so we &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/65983&quot;&gt;filed a bug&lt;/a&gt; and went on our way.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-changed&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-changed&quot;&gt;&lt;/a&gt;What changed?&lt;/h2&gt;
&lt;p&gt;Early in June, I (Joshua) got tired of not being able to use intra-doc links. I started investigating the issue to see if there was a fix. It was marked as &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/labels/E-hard&quot;&gt;&lt;code&gt;E-hard&lt;/code&gt;&lt;/a&gt;, so I wasn&#x27;t expecting miracles, but I thought I might at least make a start on it.&lt;/p&gt;
&lt;p&gt;It turns out there was a simple problem with the implementation - it assumed
all items were in the current crate! Clearly, that&#x27;s not always the case. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/73101&quot;&gt;The fix&lt;/a&gt; turned out to be easy enough that I could implement it as my first contribution to rustdoc.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note from Manish:&lt;/em&gt; Actually, the distinction between &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html&quot;&gt;&lt;code&gt;DefId&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.LocalDefId.html&quot;&gt;&lt;code&gt;LocalDefId&lt;/code&gt;&lt;/a&gt; &lt;em&gt;didn&#x27;t exist&lt;/em&gt; when we wrote the feature, and the code would only resolve paths based on the resolver&#x27;s current internal scope (which can only be within the current crate, since that is the only scope information the resolver had at the time). However, over time the compiler &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/63400&quot;&gt;gained the ability&lt;/a&gt; to store and query resolution scopes of dependencies. We never noticed, and continued to believe that there was a large piece of work blocking stabilization.&lt;/p&gt;
&lt;p&gt;However, my solution had one small problem: on certain &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/71820&quot;&gt;carefully crafted inputs&lt;/a&gt;, it would crash:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(decl_macro)]
fn main() {
    || {
        macro m() {}
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;thread &#x27;rustc&#x27; panicked at &#x27;called &#x60;Option::unwrap()&#x60; on a &#x60;None&#x60; value&#x27;, /home/joshua/src/rust/src/librustc_hir/definitions.rs:358:9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#hirids-and-defids-and-trees-oh-my&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;hirids-and-defids-and-trees-oh-my&quot;&gt;&lt;/a&gt;HirIds and DefIds and trees, oh my!&lt;/h2&gt;
&lt;p&gt;(If you&#x27;re not interested in the internals of the Rust compiler, feel free to skip this section.)&lt;/p&gt;
&lt;p&gt;The error above came because of a pass called &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/bd49eec3d76d5894b539a28309c2fe24f915ee94/compiler/rustc_interface/src/util.rs#L583&quot;&gt;&lt;code&gt;everybody_loops&lt;/code&gt;&lt;/a&gt;. A compiler &#x27;pass&#x27; is a transformation on the source code, for example &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src/librustc_lint/builtin.rs#L302&quot;&gt;finding items without documentation&lt;/a&gt;.
The &lt;code&gt;everybody_loops&lt;/code&gt; pass turns the above code into:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn main() {
    {
        macro m { () &#x3D;&amp;gt; { } }
    }
    loop  { }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As part of my changes for resolving cross-crate items, I needed to know the first parent module, so I could tell what items were in scope. Note however, that after &lt;code&gt;everybody_loops&lt;/code&gt; the closure has disappeared! The crash happened because &lt;code&gt;rustdoc&lt;/code&gt; was trying to access a closure that &lt;code&gt;rustc&lt;/code&gt; didn&#x27;t think existed (in compiler jargon, it was turning the &lt;code&gt;DefId&lt;/code&gt; for the closure, which works across crates, into a &lt;code&gt;HirId&lt;/code&gt;, which is specific to the current crate but contains a lot more info).&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#why-is-this-hard&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-is-this-hard&quot;&gt;&lt;/a&gt;Why is this hard?&lt;/h1&gt;
&lt;p&gt;This turned out to be an enormous rabbit hole. &lt;code&gt;everybody_loops&lt;/code&gt; was &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/43348&quot;&gt;introduced&lt;/a&gt; all the way back in 2017 to solve another long-standing issue: &lt;code&gt;rustdoc&lt;/code&gt; doesn&#x27;t know how to deal with &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/1998&quot;&gt;conditional compilation&lt;/a&gt;. What it lets rustdoc (and by extension, the standard library) do is ignore type and name errors in function bodies. This allows documenting both Linux and Windows APIs on the same host, even though the implementations would &lt;a href&#x3D;&quot;https://gist.github.com/jyn514/aee31eb1cc99d012ff674bec7d122b5e&quot;&gt;normally be broken&lt;/a&gt;. As seen above, the way it works is by turning every function body into &lt;code&gt;loop {}&lt;/code&gt; - this is always valid, because &lt;code&gt;loop {}&lt;/code&gt; has type &lt;code&gt;!&lt;/code&gt;, which coerces to any type!&lt;/p&gt;
&lt;!--
However there&#x27;s a problem: [function bodies aren&#x27;t _always_ opaque][preserve-item-decls].
You can implement traits inside a function:

&#x60;&#x60;&#x60;rust
pub struct S;
fn f() {
    impl Default for S {
        fn default() -&gt; Self {
            S
        }
    }
}
&#x60;&#x60;&#x60;

If you replace that trait implementation with a loop, you have a problem.
--&gt;
&lt;p&gt;As we saw above, though, this transformation broke rustdoc. Additionally, it was causing &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/65863&quot;&gt;lots&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/53002&quot;&gt;of&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/43878&quot;&gt;other&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/65252/commits/25cc99fca0650f54828e8ba7ad2bab341b231fcc&quot;&gt;problems&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So I got rid of it! This was &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/73566&quot;&gt;Don&#x27;t run everybody_loops&lt;/a&gt;. It is the single largest PR I&#x27;ve ever made to rustc, and hopefully the largest I will ever make. The issue was that the errors from libstd haven&#x27;t gone away - if anything, it had been expanded since 2017. The hack I came up with was to, instead of running type checking and trying to rewrite the code into something that was valid, never run type checking in function bodies at all! This is both &lt;a href&#x3D;&quot;https://perf.rust-lang.org/compare.html?start&#x3D;6ee1b62c811a6eb68d6db6dfb91f66a49956749b&amp;end&#x3D;5c9e5df3a097e094641f16dab501ab1c4da10e9f&amp;stat&#x3D;instructions:u&quot;&gt;less work&lt;/a&gt; and closer to the semantics rustdoc wants. In particular, it never causes the invalid states that were crashing &lt;code&gt;rustdoc&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#aftermath-no-good-deed-goes-unpunished&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;aftermath-no-good-deed-goes-unpunished&quot;&gt;&lt;/a&gt;Aftermath: No good deed goes unpunished&lt;/h2&gt;
&lt;p&gt;About a month after the PR was merged, rustdoc got a bug report: the docs for &lt;code&gt;async-std&lt;/code&gt; failed to build on the nightly channel. Their code looked something like &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/b146000e910ccd60bdcde89363cb6aa14ecc0d95/src/test/rustdoc-ui/error-in-impl-trait/realistic-async.rs&quot;&gt;the following&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;mod windows {
    pub trait WinFoo {
        fn foo(&amp;amp;self) {}
    }
    impl WinFoo for () {}
}

#[cfg(any(windows, doc))]
use windows::*;

mod unix {
    pub trait UnixFoo {
        fn foo(&amp;amp;self) {}
    }
    impl UnixFoo for () {}
}

#[cfg(any(unix, doc))]
use unix::*;

async fn bar() {
    ().foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In particular, notice that under &lt;code&gt;cfg(doc)&lt;/code&gt;, both traits would be in scope with the same method, so it would be ambiguous which to use for &lt;code&gt;.foo()&lt;/code&gt;. This is exactly the sort of problem meant to be solved by not running type-checking. Unfortunately, since it was used in an &lt;code&gt;async fn&lt;/code&gt;, type checking was still being run; &lt;code&gt;bar&lt;/code&gt; desugars to a closure of the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn bar() -&amp;gt; impl Future&amp;lt;Output &#x3D; ()&amp;gt; {
    async {
        ().foo()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because the function returned &lt;code&gt;impl Future&lt;/code&gt;, that required type-checking the body to infer the return type of the function. That&#x27;s exactly what &lt;code&gt;rustdoc&lt;/code&gt; wanted not to do!&lt;/p&gt;
&lt;p&gt;The &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75127/&quot;&gt;hacky &#x27;fix&#x27;&lt;/a&gt; implemented was to not infer the type of the function at all - rustdoc doesn&#x27;t care about the exact type, only the traits that it implements. This was such a hack there&#x27;s an &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/75100&quot;&gt;issue open to fix it&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#stabilizing-intra-doc-links&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilizing-intra-doc-links&quot;&gt;&lt;/a&gt;Stabilizing intra-doc links&lt;/h2&gt;
&lt;p&gt;Now that cross-crate re-exports work, there isn&#x27;t much standing in the way of stabilizing intra-doc links! There are a &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/74489&quot;&gt;few&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75176&quot;&gt;cleanup&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75079&quot;&gt;PRs&lt;/a&gt;, but for the most part, the path to stabilization seems clear.&lt;/p&gt;
&lt;p&gt;In the meantime, I&#x27;ve been working on various improvements to intra-doc links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md#linking-to-associated-items&quot;&gt;Resolving associated items&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75176&quot;&gt;Fixing&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75649&quot;&gt;various&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76082&quot;&gt;bugs&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76093&quot;&gt;in&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76467&quot;&gt;the&lt;/a&gt; implementation&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/75080&quot;&gt;Using intra-doc links throughout the standard library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Detecting more cases when &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75815&quot;&gt;links are ambiguous&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76078&quot;&gt;Removing disambiguators&lt;/a&gt; that only distract from the docs&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75756&quot;&gt;Improving the errors messages&lt;/a&gt; when a link fails to resolve&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In particular, there have been a ton of people who stepped up to help &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/75080&quot;&gt;convert the standard library to intra-doc links&lt;/a&gt;. A giant thank you to &lt;strong&gt;@camelid&lt;/strong&gt;, &lt;strong&gt;@denisvasilik&lt;/strong&gt;, &lt;strong&gt;@poliorcetics&lt;/strong&gt;, &lt;strong&gt;@nixphix&lt;/strong&gt;, &lt;strong&gt;@EllenNyan&lt;/strong&gt;, &lt;strong&gt;@kolfs&lt;/strong&gt;, &lt;strong&gt;@LeSeulArtichaut&lt;/strong&gt;, &lt;strong&gt;@Amjad50&lt;/strong&gt;, and &lt;strong&gt;@GuillaumeGomez&lt;/strong&gt; for all their help!&lt;/p&gt;
</content>

        <author>
            <name>Manish Goregaokar and Joshua Nelson</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes to x.py defaults</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html" type="text/html" title="Changes to x.py defaults" />
        <published>2020-08-30T00:00:00+00:00</published>
        <updated>2020-08-30T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html">&lt;p&gt;Recently, the defaults for &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#what-is-xpy&quot;&gt;&lt;code&gt;x.py&lt;/code&gt;&lt;/a&gt;, the tool used to &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html&quot;&gt;bootstrap&lt;/a&gt; the Rust compiler from source, changed. If you regularly contribute to Rust, this might affect your workflow.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-changes-were-made&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-changes-were-made&quot;&gt;&lt;/a&gt;What changes were made?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The default stage is now dependent on the subcommand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dist&lt;/code&gt;: stage 2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt;: stage 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt;: stage 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doc&lt;/code&gt;: stage 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stage 1 &lt;code&gt;rustc&lt;/code&gt; artifacts are no longer built by &lt;code&gt;x.py build --stage 1&lt;/code&gt;. To get the old behavior back, use &lt;code&gt;x.py build --stage 1 src/rustc&lt;/code&gt;. The new behavior for &lt;code&gt;build --stage 1&lt;/code&gt; builds everything except &lt;code&gt;rustc&lt;/code&gt;, which includes the standard library, &lt;code&gt;rustdoc&lt;/code&gt;, and various other tools (if the tools are enabled).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;debuginfo&lt;/code&gt; now defaults to &lt;code&gt;1&lt;/code&gt; when &lt;code&gt;debug &#x3D; true&lt;/code&gt;. Previously, the default was 2.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#why-were-the-changes-made&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-were-the-changes-made&quot;&gt;&lt;/a&gt;Why were the changes made?&lt;/h2&gt;
&lt;p&gt;Previously, &lt;code&gt;x.py build&lt;/code&gt; would build &lt;code&gt;rustc&lt;/code&gt; twice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;build/stage0-std&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage0-rustc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage1-std&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage1-rustc&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Normally, contributors only want to build the compiler once, which lets them test their changes quickly. After this change, that&#x27;s now the default:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;build/stage0-std&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage0-rustc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage1-std&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;debuginfo &#x3D; 2&lt;/code&gt; generates several gigabytes of debug information,
making the previous default settings for &lt;code&gt;debug &#x3D; true&lt;/code&gt; very painful.&lt;/p&gt;
&lt;p&gt;For a detailed rationale of the changes, as well as more information about the alternatives considered, see&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/326&quot;&gt;the MCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/73964&quot;&gt;implementation PR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/233931-xxx/topic/Use.20sane.20defaults.20in.20x.py.20compiler-team.23326&quot;&gt;Zulip stream&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Joshua Nelson</name>
        </author>
    </entry>
    
    <entry>
        <title>Upcoming compiler-team design meetings</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/08/28/upcoming-compiler-team-design-meetings.html" type="text/html" title="Upcoming compiler-team design meetings" />
        <published>2020-08-28T00:00:00+00:00</published>
        <updated>2020-08-28T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/08/28/upcoming-compiler-team-design-meetings.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/08/28/upcoming-compiler-team-design-meetings.html">&lt;p&gt;In our &lt;a href&#x3D;&quot;https://zulip-archive.rust-lang.org/238009tcompilermeetings/99475planningmeeting20200828.html&quot;&gt;planning meeting today&lt;/a&gt;, the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/compiler&quot;&gt;compiler team&lt;/a&gt; has scheduled our
next batch of upcoming design meetings. You can find the exact times
on the compiler team&#x27;s &lt;a href&#x3D;&quot;https://rust-lang.github.io/compiler-team/#meeting-calendar&quot;&gt;meeting calendar&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On September 4th (&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;tmeid&#x3D;NTMwYmxwaDRxZG8xdHJkdm1mdW1jMWxwMmYgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss the results
of the contributor survey that we conducted. See &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/318&quot;&gt;rust-lang/compiler-team#318&lt;/a&gt; for more details.&lt;/li&gt;
&lt;li&gt;On September 18th (&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;tmeid&#x3D;MzVmbGVvcXVkcTM4MmJxam5lM25wbWEzaG8gNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will conduct a retrospective
of the &lt;a href&#x3D;&quot;https://forge.rust-lang.org/compiler/mcp.html&quot;&gt;compiler-team MCP process&lt;/a&gt;. See &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/314&quot;&gt;rust-lang/compiler-team#314&lt;/a&gt; for more details.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#did-you-know&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;did-you-know&quot;&gt;&lt;/a&gt;Did you know?&lt;/h3&gt;
&lt;p&gt;Most weeks, the compiler team has some sort of design meeting. These
meetings take place on Zulip and are open to all. Every 4 weeks, we do
a planning meeting to pick the next few meetings from the list of open
proposals. You can find &lt;a href&#x3D;&quot;https://rust-lang.github.io/compiler-team/about/steering-meeting/&quot;&gt;more details about how the compiler-team
steering meeting process here&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>1.46.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/08/24/1.46.0-prerelease.html" type="text/html" title="1.46.0 pre-release testing" />
        <published>2020-08-24T00:00:00+00:00</published>
        <updated>2020-08-24T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/08/24/1.46.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/08/24/1.46.0-prerelease.html">&lt;p&gt;The 1.46.0 pre-release is ready for testing. The release is scheduled for this
Thursday, August 27th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1460-2020-08-27&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2020-08-24/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2020-08-24/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-46-0-pre-release-testing/12957&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2021-01-20T15:50:24+00:00</updated>

    
    <entry>
        <title>Changes to the Rustdoc team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/01/19/changes-to-rustdoc-team.html" type="text/html" title="Changes to the Rustdoc team" />
        <published>2021-01-19T00:00:00+00:00</published>
        <updated>2021-01-19T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/01/19/changes-to-rustdoc-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/01/19/changes-to-rustdoc-team.html">&lt;p&gt;Recently, there have been a lot of improvements in rustdoc. It was possible thanks to our new contributors. In light of these recent contributions, a few changes were made in the rustdoc team.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#adding-a-new-team-leader&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;adding-a-new-team-leader&quot;&gt;&lt;/a&gt;Adding a new team leader&lt;/h2&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/jyn514&quot;&gt;Joshua&lt;/a&gt; has been helping me &lt;strong&gt;a lot&lt;/strong&gt; on the leading parts by tagging issues and mentoring newcomers. But at the same time, he initiated great changes in the rustdoc codebase that led to huge performance improvements, he finished the &amp;quot;intra doc link&amp;quot; features which is now stable after years of instability (more information &lt;a href&#x3D;&quot;https://doc.rust-lang.org/rustdoc/linking-to-items-by-name.html&quot;&gt;here&lt;/a&gt;). He also did multiple additional things but let&#x27;s stop the listing here. :)&lt;/p&gt;
&lt;p&gt;Overall, he&#x27;s been an enormous help and making him co-lead is just making offical everything&#x27;s he&#x27;s been doing since he joined the rustdoc team (and even before!). I&#x27;m glad to have him on the team and as co-lead.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#membership-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;membership-changes&quot;&gt;&lt;/a&gt;Membership Changes&lt;/h2&gt;
&lt;p&gt;In addition to the new co-leadership nomination, we also have some new rustdoc team members to announce: &lt;a href&#x3D;&quot;https://github.com/camelid&quot;&gt;&lt;strong&gt;@camelid&lt;/strong&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/Nemo157&quot;&gt;&lt;strong&gt;@Nemo157&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/camelid&quot;&gt;&lt;strong&gt;@camelid&lt;/strong&gt;&lt;/a&gt; did a huge number of contributions on rustdoc, helping on the cleanup and fixing bugs.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/Nemo157&quot;&gt;&lt;strong&gt;@Nemo157&lt;/strong&gt;&lt;/a&gt; helped a lot on the &amp;quot;front-end&amp;quot; part of rustdoc (i.e. HTML/CSS/JS), not only reviewing but also fixing bugs and improving the current code.&lt;/p&gt;
&lt;p&gt;Both of them have been contributing for a long time and we&#x27;re really glad to (finally) have them on board.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;With all these great new onboardings, we&#x27;re expecting rustdoc to improve at much faster rate. More to come soon!&lt;/p&gt;
</content>

        <author>
            <name>Guillaume Gomez</name>
        </author>
    </entry>
    
    <entry>
        <title>Rustdoc performance improvements</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2021/01/15/rustdoc-performance-improvements.html" type="text/html" title="Rustdoc performance improvements" />
        <published>2021-01-15T00:00:00+00:00</published>
        <updated>2021-01-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2021/01/15/rustdoc-performance-improvements.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2021/01/15/rustdoc-performance-improvements.html">&lt;p&gt;Hi everyone! &lt;a href&#x3D;&quot;https://github.com/GuillaumeGomez&quot;&gt;&lt;strong&gt;@GuillaumeGomez&lt;/strong&gt;&lt;/a&gt; recently tweeted about the rustdoc performance improvements and suggested that we write a blog post about it:&lt;/p&gt;
&lt;blockquote class&#x3D;&quot;twitter-tweet&quot;&gt;&lt;p lang&#x3D;&quot;en&quot; dir&#x3D;&quot;ltr&quot;&gt;The performance comparison between &lt;a href&#x3D;&quot;https://twitter.com/rustlang?ref_src&#x3D;twsrc%5Etfw&quot;&gt;@rustlang&lt;/a&gt; rustdoc now and rustdoc 4 months ago are crazy! The rustdoc cleanup going on (we&amp;#39;re still far from done!) is having a huge positive impact! Can&amp;#39;t wait to see how much better the results will be.&lt;br&gt;&lt;br&gt;Maybe I should write a blog post? &lt;a href&#x3D;&quot;https://t.co/XapdmdZ1IZ&quot;&gt;pic.twitter.com/XapdmdZ1IZ&lt;/a&gt;&lt;/p&gt;&amp;mdash; Guillaume Gomez (@imperioworld_) &lt;a href&#x3D;&quot;https://twitter.com/imperioworld_/status/1349383125051305984?ref_src&#x3D;twsrc%5Etfw&quot;&gt;January 13, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src&#x3D;&quot;https://platform.twitter.com/widgets.js&quot; charset&#x3D;&quot;utf-8&quot;&gt;&lt;/script&gt; 
&lt;p&gt;The tweet received a lot of comments approving the blog post idea so here we go!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#performance-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;performance-changes&quot;&gt;&lt;/a&gt;Performance changes&lt;/h2&gt;
&lt;p&gt;There were actually only two PRs explicitly meant to improve the performance of rustdoc:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Rustdoc: Cache resolved links &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/77700&quot;&gt;#77700&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This does what it says in the title. In particular, this sped up the time to generate intra-doc
links for &lt;code&gt;stm32h7xx&lt;/code&gt; by a whopping &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/77700#issuecomment-735995025&quot;&gt;90,000%&lt;/a&gt;. &lt;a href&#x3D;&quot;https://github.com/bugadani&quot;&gt;&lt;strong&gt;@bugadani&lt;/strong&gt;&lt;/a&gt; did an
excellent job on this, congratulations!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start&#x3D;&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;Don&#x27;t look for blanket impls in intra-doc links &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79682&quot;&gt;#79682&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This PR was very disappointing to write. The gist is that if you had&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Trait {
    fn f() {}
}

impl&amp;lt;T&amp;gt; Trait for T {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then linking to &lt;code&gt;usize::f&lt;/code&gt; would not only not work, but would take longer to run than the rest of
intra-doc links to run. This temporarily disabled blanket impls until the bug is fixed and the performance can be improved, for a similar &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79682#issuecomment-738505531&quot;&gt;90x&lt;/a&gt; speedup on &lt;code&gt;stm32h7xx&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You may be wondering why &lt;code&gt;stm32h7xx&lt;/code&gt; was so slow before; see the end of the post for details.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#its-all-about-cleanup&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;its-all-about-cleanup&quot;&gt;&lt;/a&gt;It&#x27;s all about cleanup&lt;/h2&gt;
&lt;p&gt;With the recent growth of the rustdoc team, we finally had some time to pay down the technical debt we&#x27;ve been accumulating for a while. To sum it up: removing implementations in rustdoc and using the compiler types directly. First, we need to explain a bit about how rustdoc works. When we run it to generate HTML documentation, it goes through several steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run parts of the compiler to get the information we need.&lt;/li&gt;
&lt;li&gt;Remove the information provided by the compiler that we don&#x27;t need (for example, if an item is &lt;code&gt;doc(hidden)&lt;/code&gt;, we don&#x27;t need it). There is a lot to say on this part so maybe we&#x27;ll write another blog post to go more into details.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;doctree&lt;/code&gt; pass which adds some extra information needed by rustdoc on some items of the compiler.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;clean&lt;/code&gt; pass which converts the compiler types into rustdoc ones: basically, it transforms everything into &amp;quot;printable&amp;quot; content.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;render&lt;/code&gt; pass which then generates the desired output (HTML or, on nightly, JSON).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/jyn514&quot;&gt;&lt;strong&gt;@jyn514&lt;/strong&gt;&lt;/a&gt; noticed a while ago that &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/76382&quot;&gt;most of the work in Rustdoc is duplicated&lt;/a&gt;: there are actually &lt;em&gt;three&lt;/em&gt; different abstract syntax trees (ASTs)! One for &lt;code&gt;doctree&lt;/code&gt;, one for &lt;code&gt;clean&lt;/code&gt;, and one is the original &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/hir.html&quot;&gt;HIR&lt;/a&gt; used by the compiler.
Rustdoc was spending quite a lot of time converting between them. Most of the speed improvements have come from getting rid of parts of the AST altogether.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#pruning-the-tree&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;pruning-the-tree&quot;&gt;&lt;/a&gt;Pruning the tree&lt;/h3&gt;
&lt;p&gt;Most of the work &lt;code&gt;doctree&lt;/code&gt; did was 100% unnecessary. All the information it had was already present in the &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/hir.html&quot;&gt;HIR&lt;/a&gt;, and recursively walking the crate and building up new types took quite a while to run.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/jyn514&quot;&gt;&lt;strong&gt;@jyn514&lt;/strong&gt;&lt;/a&gt;&#x27;s first stab at this was to &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/78082&quot;&gt;get rid of the pass altogether&lt;/a&gt;. This went... badly. It turns out it did some useful work after all.&lt;/p&gt;
&lt;p&gt;That said, there was a bunch of unnecessary work it didn&#x27;t need to do, which was to add its own types for everything. If you look at &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/31d275e5877d983fecb39bbaad837f6b7cf120d3/src/librustdoc/doctree.rs&quot;&gt;the types from 3 months ago&lt;/a&gt; against &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/a4f022e1099c712fdcc8555fd10caccb1a631877/src/librustdoc/doctree.rs&quot;&gt;the types from today&lt;/a&gt;, the difference is really startling! It went from 300 lines of code replicating almost every type in the compiler to only 75 lines and 6 types.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#cleaning-the-clean-pass&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cleaning-the-clean-pass&quot;&gt;&lt;/a&gt;Cleaning the &lt;code&gt;clean&lt;/code&gt; pass&lt;/h2&gt;
&lt;p&gt;The first and most important part of this cleanup was a PR called &#x27;Add &lt;code&gt;Item::from_def_id_and_kind&lt;/code&gt; to reduce duplication in rustdoc&#x27; (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/77820&quot;&gt;#77820&lt;/a&gt;). Before that change, every &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc/clean/types/struct.Item.html&quot;&gt;&lt;code&gt;Item&lt;/code&gt;&lt;/a&gt; in rustdoc was constructed in dozens of different places - for structs, for enums, for traits, the list went on and on. This made it very hard to make changes to the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc/clean/types/struct.Item.html&quot;&gt;&lt;code&gt;Item&lt;/code&gt;&lt;/a&gt; struct, because any change would break dozens of callsites, each of which had to be fixed individually. What &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/77820&quot;&gt;#77820&lt;/a&gt; did was to construct all those items in the same place, which made it far easier to change how &lt;code&gt;Item&lt;/code&gt; was represented internally.&lt;/p&gt;
&lt;p&gt;Along the way, &lt;a href&#x3D;&quot;https://github.com/jyn514&quot;&gt;&lt;strong&gt;@jyn514&lt;/strong&gt;&lt;/a&gt; found several cleanups that were necessary in the compiler first:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Calculate visibilities once in resolve &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/78077&quot;&gt;#78077&lt;/a&gt;. Thanks to &lt;a href&#x3D;&quot;https://github.com/petrochenkov&quot;&gt;&lt;strong&gt;@petrochenkov&lt;/strong&gt;&lt;/a&gt; for tackling this!&lt;/li&gt;
&lt;li&gt;Fix handling of item names for HIR &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/78345&quot;&gt;#78345&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#deleting-parts-of-item&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;deleting-parts-of-item&quot;&gt;&lt;/a&gt;Deleting parts of &lt;code&gt;Item&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Once that was done, we were able to get rid of large parts of the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc/clean/types/struct.Item.html&quot;&gt;&lt;code&gt;Item&lt;/code&gt;&lt;/a&gt; type by calculating the information on-demand instead, using the compiler internals. This had two benefits:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Less memory usage, because the information wasn&#x27;t stored longer than it was needed.&lt;/li&gt;
&lt;li&gt;Less time overall, because not every item needed all the information available.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This benefited quite a lot from the &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/query.html&quot;&gt;query system&lt;/a&gt;, which I highly encourage reading about.&lt;/p&gt;
&lt;p&gt;Here are some example changes that calculate information on demand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Don&#x27;t unnecessarily override attrs for Module &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80340&quot;&gt;#80340&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get rid of &lt;code&gt;clean::Deprecation&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80041&quot;&gt;#80041&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get rid of &lt;code&gt;clean::{Method, TyMethod}&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79125&quot;&gt;#79125&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Remove duplicate &lt;code&gt;Trait::auto&lt;/code&gt; field &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79126&quot;&gt;#79126&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get rid of some doctree items &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79264&quot;&gt;#79264&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get rid of &lt;code&gt;doctree::{ExternalCrate, ForeignItem, Trait, Function}&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79335&quot;&gt;#79335&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get rid of &lt;code&gt;doctree::Impl&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79312&quot;&gt;79312&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Remove &lt;code&gt;doctree::Macro&lt;/code&gt; and distinguish between &lt;code&gt;macro_rules!&lt;/code&gt; and &lt;code&gt;pub macro&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79455&quot;&gt;#79455&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Pass around Symbols instead of Idents in doctree &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79623&quot;&gt;#79623&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As you can see, all these changes not only sped up rustdoc, but discovered bugs and duplication that had been around for years.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#reusing-compiler-types&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;reusing-compiler-types&quot;&gt;&lt;/a&gt;Reusing compiler types&lt;/h3&gt;
&lt;p&gt;And some examples of using the existing compiler types without adding our own:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[rustdoc] Switch to Symbol for &lt;code&gt;item.name&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80044&quot;&gt;#80044&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Use more symbols in rustdoc &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80047&quot;&gt;#80047&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Replace String with Symbol where possible &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80091&quot;&gt;#80091&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Continue String to Symbol conversion in rustdoc (1) &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80119&quot;&gt;#80119&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Continue String to Symbol conversion in rustdoc (2) &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80154&quot;&gt;#80154&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get rid of custom pretty-printing in rustdoc &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80799&quot;&gt;#80799&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;They replace &lt;code&gt;String&lt;/code&gt; used for items&#x27; name to use &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; instead. Symbols are interned strings, so we&#x27;re not only preventing unnecessary conversions but also greatly improving memory usage. You can read more about Symbols in the &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/appendix/glossary.html?highlight&#x3D;symbol#glossary&quot;&gt;rustc-dev-guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The interesting part is that it also allowed some &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80750&quot;&gt;small improvements&lt;/a&gt; in the compiler itself.&lt;/p&gt;
&lt;p&gt;With the same logic came &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80261&quot;&gt;#80261&lt;/a&gt; (which required &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/80295&quot;&gt;#80295&lt;/a&gt; beforehand) which kept the original document attributes &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; with the &amp;quot;transformation information&amp;quot; instead of the transformed string. If you want to know more about how rustdoc works on doc comments formatting, &lt;a href&#x3D;&quot;https://github.com/GuillaumeGomez&quot;&gt;&lt;strong&gt;@GuillaumeGomez&lt;/strong&gt;&lt;/a&gt; wrote a blog post about it &lt;a href&#x3D;&quot;https://blog.guillaume-gomez.fr/articles/2020-11-11+New+doc+comment+handling+in+rustdoc&quot;&gt;here&lt;/a&gt;. The idea here is once again to compute this &amp;quot;on demand&amp;quot; instead of storing the results ahead for (potential) usage.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#why-did-we-not-rely-more-on-rustc-internals-earlier&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-did-we-not-rely-more-on-rustc-internals-earlier&quot;&gt;&lt;/a&gt;Why did we not rely more on rustc internals earlier?&lt;/h2&gt;
&lt;p&gt;By now, you may be wondering why rustdoc didn&#x27;t rely more on rustc internals before this cleanup. The answer is actually simple: rustdoc is &lt;strong&gt;old&lt;/strong&gt;. When it was being written, rustc internals changed very frequently (even daily), making it very complicated for the rustdoc maintainers to keep up. To allow them to work without worrying too much about these changes, they decided to abstract the compiler internals so that they could then work with those rustdoc types without having breaking changes to worry about every day.&lt;/p&gt;
&lt;p&gt;Since then, things got improved, the 1.0 version of Rust finally got released and things slowed down. Then, focus was mostly on adding new features to make rustdoc as great as possible. With the arrival of new rustdoc team members, we were finally able to get back on this aspect. It didn&#x27;t make much sense to keep all those abstractions because the internals are somewhat stable now and we can all see the results. :)&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#next-steps&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;next-steps&quot;&gt;&lt;/a&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;As you saw from the displayed benchmarks, the results were strongly positive. However, we&#x27;re still far from done. As we speak, we continue to simplify and rework a lot of the rustdoc source code.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#remove-doctree-altogether&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;remove-doctree-altogether&quot;&gt;&lt;/a&gt;Remove doctree altogether&lt;/h3&gt;
&lt;p&gt;This is the &amp;quot;useful work&amp;quot; (as opposed to unnecessary complexity) that &lt;code&gt;doctree&lt;/code&gt; does today:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Detecting which items are publicly reachable. Ideally, this would just use compiler APIs, but those APIs &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/64762&quot;&gt;are broken&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inlining items that are only reachable from an export. &#x27;Inlining&#x27; is showing the full documentation for an item at a re-export (&lt;code&gt;pub use std::process::Command&lt;/code&gt;) instead of just showing the &lt;code&gt;use&lt;/code&gt; statement. It&#x27;s used pervasively by the standard library and facade crates like &lt;code&gt;futures&lt;/code&gt; to show the relevant documentation in one place, instead of spread out across many crates. &lt;strong&gt;@jyn514&lt;/strong&gt; hopes this could be done in &lt;code&gt;clean&lt;/code&gt; instead, but has no idea yet how to do it.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Moving macros from always being at the root of the crate to the module where they&#x27;re accessible. For example, this macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![crate_name&#x3D;&amp;quot;my_crate&amp;quot;]
#![feature(decl_macro)]
mod inner {
    pub macro m() {}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;should be documented at &lt;code&gt;my_crate::inner::m&lt;/code&gt;, but the compiler shows it at &lt;code&gt;my_crate::m&lt;/code&gt; instead. The fix for this is an awful hack that goes through every module Rustdoc knows about to see if the name of the module matches the name of the macro&#x27;s parent module. At some point in the future, it would be great to fix the compiler APIs so this is no longer necessary.&lt;/p&gt;
&lt;p&gt;Giant thank you to &lt;a href&#x3D;&quot;https://github.com/danielhenrymantilla&quot;&gt;&lt;strong&gt;@danielhenrymantilla&lt;/strong&gt;&lt;/a&gt; both for writing up the fix, and discovering and fixing several other macro-related bugs along the way!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If all these issues could be fixed, that would be an even bigger speedup - there would be no need to walk the tree in the first place!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#continue-to-shrink-cleanitem&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;continue-to-shrink-cleanitem&quot;&gt;&lt;/a&gt;Continue to shrink &lt;code&gt;clean::Item&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Most of the existing cleanups have been focused on calculating info on-demand that&#x27;s used for &lt;em&gt;every&lt;/em&gt; item in rustdoc, since that has the greatest impact. There are still lots of other parts that are calculated ahead of time, though: in particular &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc/clean/types/enum.ItemKind.html&quot;&gt;&lt;code&gt;ItemKind&lt;/code&gt;&lt;/a&gt; goes completely through &lt;code&gt;clean&lt;/code&gt; before starting to render the documentation.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#speed-up-collect_blanket_impls&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;speed-up-collect_blanket_impls&quot;&gt;&lt;/a&gt;Speed up &lt;code&gt;collect_blanket_impls&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;One of the slowest functions in all of rustdoc is a function called
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc/clean/utils/fn.get_auto_trait_and_blanket_impls.html&quot;&gt;&lt;code&gt;get_auto_trait_and_blanket_impls&lt;/code&gt;&lt;/a&gt;.
On crates with many blanket implementation, such as &lt;code&gt;stm32&lt;/code&gt;-generated crates, this can take
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/79103#issuecomment-745732064&quot;&gt;almost half of the &lt;em&gt;total&lt;/em&gt;
time&lt;/a&gt; rustdoc spends on
the crate.&lt;/p&gt;
&lt;p&gt;We are not sure yet how to speed this up, but there is definitely lots of room for improvement.
If you&#x27;re interested in working on this, please reach out &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/247081-t-compiler.2Fperformance/topic/rustdoc.20calls.20.60for_each_relevant_impl.60.20a.20lot&quot;&gt;on Zulip&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Overall, rustdoc is making rapid progress in performance, but there is still a lot more work to be done.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#errata&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;errata&quot;&gt;&lt;/a&gt;Errata&lt;/h2&gt;
&lt;p&gt;An earlier version of the blog post described the section on slimming &lt;code&gt;doctree&lt;/code&gt; as &amp;quot;Burning down
the tree&amp;quot;. The name was changed to be more environmentally friendly.&lt;/p&gt;
</content>

        <author>
            <name>Joshua Nelson and Guillaume Gomez</name>
        </author>
    </entry>
    
    <entry>
        <title>1.49.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/12/29/1.49.0-prerelease.html" type="text/html" title="1.49.0 pre-release testing" />
        <published>2020-12-29T00:00:00+00:00</published>
        <updated>2020-12-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/12/29/1.49.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/12/29/1.49.0-prerelease.html">&lt;p&gt;The 1.49.0 pre-release is ready for testing. The release is scheduled for this
Thursday, December 31st. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1490-2020-12-31&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2020-12-29/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2020-12-29/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-49-0-pre-release-testing/13690&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Please welcome cjgillot and Nadrieril to compiler-contributors</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/12/28/cjgillot-and-nadrieril-for-compiler-contributors.html" type="text/html" title="Please welcome cjgillot and Nadrieril to compiler-contributors" />
        <published>2020-12-28T00:00:00+00:00</published>
        <updated>2020-12-28T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/12/28/cjgillot-and-nadrieril-for-compiler-contributors.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/12/28/cjgillot-and-nadrieril-for-compiler-contributors.html">&lt;p&gt;Please welcome &lt;a href&#x3D;&quot;https://github.com/cjgillot&quot;&gt;@cjgillot&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/Nadrieril&quot;&gt;@Nadrieril&lt;/a&gt; to the &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2689-compiler-team-contributors.html&quot;&gt;compiler-contributors&lt;/a&gt; group!&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/cjgillot&quot;&gt;@cjgillot&lt;/a&gt; has been working to improve the query system used internally in &lt;code&gt;rustc&lt;/code&gt; which powers incremental compilation.
Some of their improvements have been to reduce unnecessary work performed during incremental compilation, leading to faster builds.
Other improvements have made the query system leaner allowing &lt;code&gt;rustc&lt;/code&gt; to bootstrap faster.
&lt;a href&#x3D;&quot;https://github.com/cjgillot&quot;&gt;@cjgillot&lt;/a&gt; has also made many tweaks and optimizations to the query system.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/Nadrieril&quot;&gt;@Nadrieril&lt;/a&gt; has been working on the pattern matching system resulting in improvements to compilation performance, code readability and related diagnostics generated by rustc.
They have also been working on implementing features related to pattern matching like or-patterns and slice-patterns and helping push those features closer to stabilization.&lt;/p&gt;
&lt;p&gt;Congratulations &lt;a href&#x3D;&quot;https://github.com/cjgillot&quot;&gt;@cjgillot&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/Nadrieril&quot;&gt;@Nadrieril&lt;/a&gt; and thanks!&lt;/p&gt;
</content>

        <author>
            <name>Wesley Wiser</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes to Rust compiler team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/12/14/changes-to-compiler-team.html" type="text/html" title="Changes to Rust compiler team" />
        <published>2020-12-14T00:00:00+00:00</published>
        <updated>2020-12-14T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/12/14/changes-to-compiler-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/12/14/changes-to-compiler-team.html">&lt;p&gt;There have been important changes recently to the Rust compiler team.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#leadership-rotation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;leadership-rotation&quot;&gt;&lt;/a&gt;Leadership Rotation&lt;/h2&gt;
&lt;p&gt;Here is something very new for our team: We are rotating the leadership. Niko Matsakis will be stepping down from their role as co-lead, and Wesley Wiser will be joining Felix Klock as the co-leads for the team.&lt;/p&gt;
&lt;p&gt;Niko remains a compiler team member and will continue his contributions, especially on the RFC 2229, Polonius and Chalk projects. &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2020/12/11/rotating-the-compiler-team-leads/&quot;&gt;Niko&#x27;s blog post&lt;/a&gt; discusses their motivations for stepping down in more detail.&lt;/p&gt;
&lt;p&gt;Wesley has been contributing to Rust since 2015, and became a compiler team member in 2019. Wesley has contributed heavily to the compiler&#x27;s &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html&quot;&gt;&lt;code&gt;self-profile&lt;/code&gt; infrastructure&lt;/a&gt;, to its collection of &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2019/12/02/const-prop-on-by-default.html&quot;&gt;MIR optimizations&lt;/a&gt;, and to its const-eval and incremental compilation subsystems. Wesley has also already proven himself as an effective leader: they are currently co-lead of several working groups: wg-incr-comp, wg-prioritization, and wg-self-profile.&lt;/p&gt;
&lt;p&gt;Niko and I are delighted that Wesley is taking on this new leadership role, and I look forward to steering the compiler alongside them.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#membership-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;membership-changes&quot;&gt;&lt;/a&gt;Membership Changes&lt;/h2&gt;
&lt;p&gt;In addition to the changes in leadership, we also have a new compiler team member to announce: lcnr.&lt;/p&gt;
&lt;p&gt;lcnr has been contributing to the compiler since 2018. They have improved the type system via changes such as higher-ranked lifetimes in predicates (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/73503&quot;&gt;#73503&lt;/a&gt;), and also have focused for the past two years on improving Rust&#x27;s support for complex generic expressions in constants (tracked at &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76560&quot;&gt;#76560&lt;/a&gt;)&lt;/p&gt;
</content>

        <author>
            <name>Felix S. Klock II</name>
        </author>
    </entry>
    
    <entry>
        <title>What the Error Handling Project Group is Working On</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/11/23/What-the-error-handling-project-group-is-working-on.html" type="text/html" title="What the Error Handling Project Group is Working On" />
        <published>2020-11-23T00:00:00+00:00</published>
        <updated>2020-11-23T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/11/23/What-the-error-handling-project-group-is-working-on.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/11/23/What-the-error-handling-project-group-is-working-on.html">&lt;p&gt;The Rust community takes its error handling seriously. There’s already a strong culture in place for emphasizing helpful error handling and reporting, with multiple libraries each offering their own take (see Jane Lusby’s thorough &lt;a href&#x3D;&quot;https://youtu.be/rAF8mLI0naQ&quot;&gt;survey&lt;/a&gt; of Rust error handling/reporting libraries).&lt;/p&gt;
&lt;p&gt;But there’s still room for improvement. The main focus of the group is carrying on error handling-related work that was in progress before the group&#x27;s formation. To that end, we&#x27;re working on systematically addressing error handling-related issues, as well as eliminating blockers that are holding up stalled RFCs.&lt;/p&gt;
&lt;p&gt;Our first few meetings saw us setting a number of short- and long-term goals. These goals fall into one of three themes: making the &lt;code&gt;Error&lt;/code&gt; trait more universally accessible, improving error handling ergonomics, and authoring additional learning resources.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#one-standardized-error-trait&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;one-standardized-error-trait&quot;&gt;&lt;/a&gt;One Standardized &lt;code&gt;Error&lt;/code&gt; Trait&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;Error&lt;/code&gt; trait has been around since 1.0, and exposed two methods: &lt;code&gt;Error::description&lt;/code&gt; and &lt;code&gt;Error::cause&lt;/code&gt;. As it was originally constructed, it was too restictive for a number of reasons&lt;sup&gt;1&lt;/sup&gt;. The &lt;code&gt;Failure&lt;/code&gt; crate addressed many of the &lt;code&gt;Error&lt;/code&gt; trait&#x27;s shortcomings by exporting the &lt;code&gt;Fail&lt;/code&gt; trait, which informs many of changes that are being made to improve the &lt;code&gt;Error&lt;/code&gt; trait.&lt;/p&gt;
&lt;p&gt;On that note, bolstering the &lt;code&gt;std::error::Error&lt;/code&gt; trait such that it could be adopted across the Rust community as &lt;em&gt;the&lt;/em&gt; &lt;code&gt;Error&lt;/code&gt; trait has been an ongoing process since &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2504&quot;&gt;RFC 2504&lt;/a&gt; was merged in August 2018.&lt;/p&gt;
&lt;p&gt;This process also involves stabilizing many &lt;code&gt;Error&lt;/code&gt; trait APIs and crates that are, as of this writing, on nightly only. These include the &lt;code&gt;backtrace&lt;/code&gt; and &lt;code&gt;chain&lt;/code&gt; methods, which are both extremely useful for working with error types. If you’re interested in following or contributing to this work, take a look at &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling/issues/3&quot;&gt;this issue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another related initiative is migrating the &lt;code&gt;Error&lt;/code&gt; trait to &lt;code&gt;core&lt;/code&gt; so that it’s more widely accessible to different use cases (such as in FFI or embedded contexts).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#more-ways-to-access-error-contexts&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;more-ways-to-access-error-contexts&quot;&gt;&lt;/a&gt;More Ways to Access Error Contexts&lt;/h2&gt;
&lt;p&gt;Rust’s language semantics already provide a decently ergonomic error handling experience, what with the &lt;code&gt;Result&lt;/code&gt; type and the &lt;code&gt;?&lt;/code&gt; operator. The error handling group has identified a few additional features to further improve the error handling user experience.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#adding-the-capability-to-iterate-through-the-backtrace-type&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;adding-the-capability-to-iterate-through-the-backtrace-type&quot;&gt;&lt;/a&gt;Adding the Capability to Iterate Through the &lt;code&gt;Backtrace&lt;/code&gt; Type&lt;/h3&gt;
&lt;p&gt;As of this writing, the &lt;code&gt;backtrace&lt;/code&gt; type only implements the &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Debug&lt;/code&gt; traits. This means that the only way to work with the &lt;code&gt;backtrace&lt;/code&gt; type is to print it out, which is less than ideal. An iterator API that provided the ability to iterate through stack frames would give users the ability to control how their backtraces are formatted, which is a necessary step adding &lt;code&gt;std::backtrace::Backtrace&lt;/code&gt; support to crates like &lt;code&gt;color-backtrace&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Upon researching strategies for how to tackle this, we found that the &lt;code&gt;backtrace&lt;/code&gt; crate already has a &lt;code&gt;frames&lt;/code&gt; method that would work nicely for implementing the &lt;code&gt;Iterator&lt;/code&gt; API. It should be a relatively straightforward ordeal to expose an identical method in &lt;code&gt;std&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/78299&quot;&gt;PR&lt;/a&gt; for this has been opened for anyone who would like to check it out.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#generic-member-access&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;generic-member-access&quot;&gt;&lt;/a&gt;Generic Member Access&lt;/h3&gt;
&lt;p&gt;Currently, when we want to fetch some additional context related to an error, there are specific methods that need to be called in order to fetch that context. For example, to see the backtrace for an error, we’d call the &lt;code&gt;backtrace&lt;/code&gt; method: &lt;code&gt;let backtrace &#x3D; some_error.backtrace();&lt;/code&gt;. The problem with this approach is that it&#x27;s not possible to support types that are defined outside of &lt;code&gt;std&lt;/code&gt;. Even for types that exist within &lt;code&gt;std&lt;/code&gt;, a method to access each respective type needs to be defined, which makes things cumbersome and harder to maintain.&lt;/p&gt;
&lt;p&gt;As the name implies, generic member access, when it gets implemented, is a type-agnostic way to access different pieces of context from an &lt;code&gt;Error&lt;/code&gt; trait object. The analogy that clicked for me is when you’re parsing a string into a number, with something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let ten &#x3D; &amp;quot;10&amp;quot;.parse::&amp;lt;i32&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or when you’re collecting the contents yielded by an iterator:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::collections::HashSet;

let a_to_z_set &#x3D; (&#x27;a&#x27;..&#x3D;&#x27;z&#x27;).collect::&amp;lt;HashSet&amp;lt;_&amp;gt;&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In a similar vein, you’d be able to access some piece of context from an error by specifying its type ID:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let span_trace &#x3D; some_error.context::&amp;lt;&amp;amp;SpanTrace&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This could be used to fetch other pieces of context related to the error such as its backtrace, the error’s sources, status codes, alternate formatting representations (such as &lt;code&gt;&amp;amp;dyn Serialize&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;This feature will enable other features we plan on adding down the line, such as exposing a way to report back all of the locations from which errors originated from in a program, as well as exposing a more consistent error reporting format besides just &lt;code&gt;Display&lt;/code&gt; and &lt;code&gt;Debug&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Jane has been putting in a lot of work on pushing these ideas forward. You can check out the associated &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2895&quot;&gt;RFC&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#authoring-a-book-on-rust-error-handling-best-practices&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;authoring-a-book-on-rust-error-handling-best-practices&quot;&gt;&lt;/a&gt;Authoring a Book on Rust Error Handling Best Practices&lt;/h2&gt;
&lt;p&gt;Last but not least, there’s a lot of interest in the group around authoring &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling/tree/master/the-rust-error-book&quot;&gt;&lt;em&gt;The Rust Error Book&lt;/em&gt;&lt;/a&gt;. The aim of the book would be to codify and communicate different error handling best practices based on the respective use-case. This could include FFI use-cases, or best practices around returning error codes from programs.&lt;/p&gt;
&lt;p&gt;This is an ongoing effort that will see a lot of progress in the coming weeks and months!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#in-summary&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;in-summary&quot;&gt;&lt;/a&gt;In Summary&lt;/h2&gt;
&lt;p&gt;We&#x27;re excited by the opportunities to continue to iterate on and improve Rust&#x27;s error handling ergonomics and culture! If you&#x27;re interested in helping out and/or joining in on the conversation, please come by and introduce yourself in our &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/257204-project-error-handling&quot;&gt;Zulip stream&lt;/a&gt;. You can also keep track of our progress via our &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling&quot;&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Lastly, we&#x27;ll be presenting some forthcoming news about a universally consistent error reporting format in our next update, so stay tuned for that!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#footnotes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;footnotes&quot;&gt;&lt;/a&gt;Footnotes&lt;/h3&gt;
&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt;The &lt;code&gt;Error::description&lt;/code&gt; method only supported string slices, which meant that it was not straightforward to create dynamic error messages that included additional context. This method was deprecated in favor of &lt;code&gt;Display&lt;/code&gt;. The &lt;code&gt;Error::cause&lt;/code&gt; method, now known as &lt;code&gt;Error::source&lt;/code&gt;, doesn&#x27;t enforce errors having a &lt;code&gt;&#x27;static&lt;/code&gt; lifetime, which means that downcasting error sources is impossible, making it much more difficult to handle errors using dynamic error handlers.&lt;/p&gt;
</content>

        <author>
            <name>Sean Chen</name>
        </author>
    </entry>
    
    <entry>
        <title>1.48.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/11/16/1.48.0-prerelease.html" type="text/html" title="1.48.0 pre-release testing" />
        <published>2020-11-16T00:00:00+00:00</published>
        <updated>2020-11-16T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/11/16/1.48.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/11/16/1.48.0-prerelease.html">&lt;p&gt;The 1.48.0 pre-release is ready for testing. The release is scheduled for this
Thursday, November 19th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1480-2020-11-19&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2020-11-16/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2020-11-16/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-48-0-pre-release-testing/13401&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Using rustc_codegen_cranelift for debug builds</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/11/15/Using-rustc_codegen_cranelift.html" type="text/html" title="Using rustc_codegen_cranelift for debug builds" />
        <published>2020-11-15T00:00:00+00:00</published>
        <updated>2020-11-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/11/15/Using-rustc_codegen_cranelift.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/11/15/Using-rustc_codegen_cranelift.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-rustc_codegen_cranelift&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-rustc_codegen_cranelift&quot;&gt;&lt;/a&gt;What is &lt;code&gt;rustc_codegen_cranelift&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/bjorn3/rustc_codegen_cranelift&quot;&gt;&lt;code&gt;rustc_codegen_cranelift&lt;/code&gt;&lt;/a&gt;, or just &lt;code&gt;cg_clif&lt;/code&gt; for short, is a new experimental
codegen backend for the Rust compiler. The existing backend is LLVM, which is very
good at producing fast, highly optimized code, but is not very good at
compiling code quickly. &lt;code&gt;cg_clif&lt;/code&gt;, which uses the &lt;a href&#x3D;&quot;https://github.com/bytecodealliance/wasmtime/tree/main/cranelift#cranelift-code-generator&quot;&gt;Cranelift&lt;/a&gt; project, would
provide a fast backend which greatly improves compile times, at the cost of
performing very few optimizations. This is a great fit for debug builds, and the hope is
that &lt;code&gt;cg_clif&lt;/code&gt; will eventually be the default backend in debug mode.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-the-progress-of-using-rustc_codegen_cranelift-for-debug-builds&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-the-progress-of-using-rustc_codegen_cranelift-for-debug-builds&quot;&gt;&lt;/a&gt;What is the progress of using &lt;code&gt;rustc_codegen_cranelift&lt;/code&gt; for debug builds?&lt;/h2&gt;
&lt;p&gt;There has been a &lt;a href&#x3D;&quot;https://forge.rust-lang.org/compiler/mcp.html&quot;&gt;Major Change Proposal&lt;/a&gt; open for some time for making
&lt;code&gt;cg_clif&lt;/code&gt; part of the main Rust repository. Recently, &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/270&quot;&gt;the MCP was
accepted&lt;/a&gt; and the compiler team &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/77975&quot;&gt;merged&lt;/a&gt;
&lt;code&gt;rustc_cranelift_codegen&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/77975&quot;&gt;into the main Rust git repository&lt;/a&gt;.
&lt;code&gt;cg_clif&lt;/code&gt; is not yet distributed with &lt;code&gt;rustup&lt;/code&gt;, but this means you can now
build it from source in-tree!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#how-do-i-use-rustc_codegen_cranelift&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-do-i-use-rustc_codegen_cranelift&quot;&gt;&lt;/a&gt;How do I use &lt;code&gt;rustc_codegen_cranelift&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;In this section, I&#x27;ll walk through step-by-step how to build the new backend from source, then use it on your own projects. All code is copy/paste-able, and each step is explained.&lt;/p&gt;
&lt;p&gt;First, let&#x27;s build &lt;code&gt;cg_clif&lt;/code&gt; from source.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-sh&quot;&gt;$ git clone https://github.com/bjorn3/rustc_codegen_cranelift.git
$ ./prepare.sh
$ ./build.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can start using it to compile a project. For demonstration purposes,
I&#x27;ll be be using &lt;code&gt;cargo&lt;/code&gt;, but you can use any Rust project supported by
&lt;code&gt;cg_clif&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd ..
$ git clone https://github.com/rust-lang/cargo/
$ cd cargo
$ ../rustc_codegen_cranelift/build/cargo.sh build
...
    Finished dev [unoptimized + debuginfo] target(s) in 49.93s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It works! For comparison, let&#x27;s see how long the equivalent LLVM backend would
take.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-sh&quot;&gt;$ rustup install nightly-2020-10-31
$ cargo +nightly-2020-10-31 build
...
    Finished dev [unoptimized + debuginfo] target(s) in 54.64s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LLVM takes a full 5 seconds longer for a full build. Next, let&#x27;s try incremental builds:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git apply &amp;lt;&amp;lt;EOF
diff --git a/src/cargo/lib.rs b/src/cargo/lib.rs
index bccb41121..703afa754 100644
--- a/src/cargo/lib.rs
+++ b/src/cargo/lib.rs
@@ -36,8 +36,8 @@ use anyhow::Error;
 use log::debug;
 use std::fmt;
 
-pub use crate::util::errors::{InternalError, VerboseError};
 pub use crate::util::{CargoResult, CliError, CliResult, Config};
+pub use crate::util::errors::{InternalError, VerboseError};
 
 pub const CARGO_ENV: &amp;amp;str &#x3D; &amp;quot;CARGO&amp;quot;;
EOF
$ ../rustc_codegen_cranelift/build/cargo.sh build
    Finished dev [unoptimized + debuginfo] target(s) in 7.98s
$ cargo +nightly-2020-10-31 build
   Compiling cargo v0.50.0 (/home/joshua/cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 5.48s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;LLVM is actually &lt;em&gt;faster&lt;/em&gt; here: &lt;code&gt;serde_derive&lt;/code&gt; took longer to run under cranelift, since it wasn&#x27;t as optimized. Under cranelift it takes ~14% percent of the time, while under LLVM it takes less than 3%.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#building-in-tree&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;building-in-tree&quot;&gt;&lt;/a&gt;Building in-tree&lt;/h2&gt;
&lt;p&gt;This section is mostly for compiler hackers, but feel free to follow along even
if you&#x27;re just interested! The reason this isn&#x27;t the recommended way to build
&lt;code&gt;cg_clif&lt;/code&gt; is because the Rust compiler takes a very long time to build.&lt;/p&gt;
&lt;p&gt;First, download the Rust repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;git clone https://github.com/rust-lang/rust
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let&#x27;s set up the build system to use &lt;code&gt;cg_clif&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;$ cat &amp;gt; config.toml &amp;lt;&amp;lt;EOF
[rust]
codegen-backends &#x3D; [&amp;quot;cranelift&amp;quot;]
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, let&#x27;s run the build. This can take a long time, over a half-hour in some cases.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;./x.py build
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#how-can-i-help&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-can-i-help&quot;&gt;&lt;/a&gt;How can I help?&lt;/h2&gt;
&lt;p&gt;You don&#x27;t need to be a compiler developer to help improve &lt;code&gt;cg_clif&lt;/code&gt;!  The best
way you can help is by testing &lt;code&gt;cg_clif&lt;/code&gt; on different Rust crates across the
ecosystem.  Just while writing this article, I found &lt;a href&#x3D;&quot;https://github.com/bjorn3/rustc_codegen_cranelift/issues/1102&quot;&gt;two&lt;/a&gt;
&lt;a href&#x3D;&quot;https://github.com/bjorn3/rustc_codegen_cranelift/issues/1101&quot;&gt;bugs&lt;/a&gt;, so there&#x27;s plenty of work left to be done. Please report any bugs you find
to the &lt;a href&#x3D;&quot;https://github.com/bjorn3/rustc_codegen_cranelift/issues/new&quot;&gt;&lt;code&gt;rustc_codegen_cranelift&lt;/code&gt; git repository&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the future, we hope to distribute &lt;code&gt;cg_clif&lt;/code&gt; with Rustup, and if it matures sufficiently, eventually make it the default backend for debug builds.&lt;/p&gt;
</content>

        <author>
            <name>Joshua Nelson</name>
        </author>
    </entry>
    
    <entry>
        <title>Source-based code coverage in nightly</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/11/12/source-based-code-coverage.html" type="text/html" title="Source-based code coverage in nightly" />
        <published>2020-11-12T00:00:00+00:00</published>
        <updated>2020-11-12T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/11/12/source-based-code-coverage.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/11/12/source-based-code-coverage.html">&lt;p&gt;Support has landed in the nightly compiler for source-based code coverage,
and we want your help testing it!&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#what-is-source-based-code-coverage-exactly&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-source-based-code-coverage-exactly&quot;&gt;&lt;/a&gt;What is &lt;em&gt;source-based&lt;/em&gt; code coverage, exactly?&lt;/h1&gt;
&lt;p&gt;You may already be familiar with code coverage, which shows you which lines
of code execute. Code coverage is usually applied to tests to find out which
code is actually being tested and which code isn’t.&lt;/p&gt;
&lt;p&gt;Nightly Rust already supports another kind of source code coverage, commonly
called gcov, which relies on debug info to map from LLVM IR to lines of
source code. Instrumentation is then added in the LLVM backend during code
generation to count how many times each line is run.&lt;/p&gt;
&lt;p&gt;However, since LLVM doesn’t know exactly how Rust code is structured, there’s
a lot lost in the translation between Rust source and LLVM IR. Line-level
granularity is sometimes too coarse, and debug info can be unreliable,
especially when building in release mode. The result is coverage reports that
only show an approximation of what code actually executed.&lt;/p&gt;
&lt;p&gt;Source-based code coverage instrumentation is applied by the Rust compiler,
not LLVM. This instrumentation is more precise because it&#x27;s being done in
MIR, which holds a mapping between the original Rust source code and the
control-flow graph of the program.&lt;/p&gt;
&lt;p&gt;That means things like short-circuited conditionals, closures, and match
guards are all precisely counted. And since instrumentation counters are
injected as regular MIR statements, the compiler can further optimize the
program without affecting coverage results.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;/images/inside-rust/2020-11-12-source-based-code-coverage/comparison.png&quot;&gt;&lt;img src&#x3D;&quot;/images/inside-rust/2020-11-12-source-based-code-coverage/comparison.png&quot; alt&#x3D;&quot;Comparison of gcov and source-based coverage results&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Above: A comparison of the gcov (left) and source-based coverage (right)
results. gcov highlights skipped lines, marked with #####, while source-based
coverage highlights exact regions of code that were skipped. Note that on
line 30, one boolean subexpression is short-circuited. This is surfaced by
source-based coverage but not gcov.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What this means is that source-based code coverage is both efficient and
accurate. LLVM’s existing coverage tools (&lt;a href&#x3D;&quot;https://llvm.org/docs/CommandGuide/llvm-profdata.html&quot;&gt;llvm-profdata&lt;/a&gt; and &lt;a href&#x3D;&quot;https://llvm.org/docs/CommandGuide/llvm-cov.html&quot;&gt;llvm-cov&lt;/a&gt;)
generate both coverage summaries and very fine-grained code regions, helping
you find gaps in your testing coverage. What you do about that is up to you!&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#trying-it-out&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;trying-it-out&quot;&gt;&lt;/a&gt;Trying it out&lt;/h1&gt;
&lt;p&gt;Work on the implementation &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/278&quot;&gt;began back in April&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pulls?q&#x3D;is%3Apr+author%3Arichkadel+is%3Aclosed+closed%3A%3C2020-11-06&quot;&gt;many PRs
later&lt;/a&gt;, it’s ready for you to try. All you need is a recent nightly and
a tool to read the coverage reports.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/unstable-book/compiler-flags/source-based-code-coverage.html&quot;&gt;Take a look at this guide to get started&lt;/a&gt;. If you spot any issues,
please &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report them&lt;/a&gt;. It’s a huge help!&lt;/p&gt;
&lt;p&gt;Finally, if you try it out and it works well, we’d also like to hear from
you! Come by the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Implement.20LLVM-compatible.20source-based.20cod.20compiler-team.23278&quot;&gt;Zulip stream&lt;/a&gt; for this change or comment on the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/34701&quot;&gt;feature
request&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#acknowledgements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h1&gt;
&lt;p&gt;The implementation work was all done by Rich Kadel; thanks to him for all the
amazing work he’s done. Thanks also to Wesley Wiser for helping with reviews,
to Bob Wilson for lending his experience with LLVM&#x27;s InstrProf coverage APIs,
and to eddyb for their guidance in choosing a MIR-based approach.&lt;/p&gt;
</content>

        <author>
            <name>Tyler Mandry</name>
        </author>
    </entry>
    
    <entry>
        <title>Exploring PGO for the Rust compiler</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler.html" type="text/html" title="Exploring PGO for the Rust compiler" />
        <published>2020-11-11T00:00:00+00:00</published>
        <updated>2020-11-11T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/11/11/exploring-pgo-for-the-rust-compiler.html">&lt;p&gt;&lt;strong&gt;TLDR&lt;/strong&gt; -- PGO makes the compiler &lt;a href&#x3D;&quot;#final-numbers-and-a-benchmarking-plot-twist&quot;&gt;faster&lt;/a&gt; but is &lt;a href&#x3D;&quot;#where-to-go-from-here&quot;&gt;not straightforward&lt;/a&gt; to realize in CI.&lt;/p&gt;
&lt;p&gt;For the last few months Mozilla has been using Profile-Guided Optimization (PGO) to build their own &lt;a href&#x3D;&quot;https://bugzilla.mozilla.org/show_bug.cgi?id&#x3D;1326486&quot;&gt;optimized version of Clang&lt;/a&gt;, leading to an up to 9% reduction of Firefox compile times on their build infrastructure.
Would the same be possible for the Rust compiler, that is, could we apply profile-guided optimization to &lt;em&gt;rustc&lt;/em&gt; itself in order to make it faster?
This post explores exactly this question, detailing first the steps needed for generating a PGOed versions of &lt;em&gt;rustc&lt;/em&gt; (in two flavors), and then taking a look at the resulting performance implications.
But before that let&#x27;s have a little reminder what PGO even is and how it works in general.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#pgo-primer&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;pgo-primer&quot;&gt;&lt;/a&gt;PGO Primer&lt;/h2&gt;
&lt;p&gt;Here is how the respective &lt;a href&#x3D;&quot;https://doc.rust-lang.org/rustc/profile-guided-optimization.html&quot;&gt;chapter from the rustc book&lt;/a&gt; describes profile-guided optimization:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The basic concept of PGO is to collect data about the typical execution of a program (e.g. which branches it is likely to take) and then use this data to inform optimizations such as inlining, machine-code layout, register allocation, etc.&lt;/p&gt;
&lt;p&gt;There are different ways of collecting data about a program&#x27;s execution. One is to run the program inside a profiler (such as perf) and another is to create an instrumented binary, that is, a binary that has data collection built into it, and run that. The latter usually provides more accurate data and it is also what is supported by &lt;code&gt;rustc&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In other words, we first generate a special, &amp;quot;instrumented&amp;quot; version of the program we want to optimize, and then use this instrumented version to generate an execution profile.
This execution profile is then used by the compiler for better optimizing the actual, final version of the program.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#how-to-apply-pgo-to-the-rust-compiler&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-to-apply-pgo-to-the-rust-compiler&quot;&gt;&lt;/a&gt;How to apply PGO to the Rust compiler&lt;/h2&gt;
&lt;p&gt;Generating a PGOed version of &lt;em&gt;rustc&lt;/em&gt; involves the same basic steps as it does for any other kind of program:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an instrumented version of &lt;em&gt;rustc&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Use the instrumented version of &lt;em&gt;rustc&lt;/em&gt; in order to collect profile data, i.e. compile a bunch of programs with it, ideally in a way that represents the typical use cases of the compiler.&lt;/li&gt;
&lt;li&gt;Compile the final version of &lt;em&gt;rustc&lt;/em&gt;, this time pointing the build system to the profile data we generated in the previous step.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, as opposed to many other programs, &lt;em&gt;rustc&lt;/em&gt; is a bit of a special case because it consists of two very large chunks of code written in different programming languages: the LLVM backend (written in C++) and the front and middle parts of the compiler (written in Rust).
Consequently, there are also two separate compilers involved in building &lt;em&gt;rustc&lt;/em&gt; -- both of which support their own version of PGO.
This complicates things slightly but fortunately the PGO setup for each of the two components can be treated in isolation.
Let&#x27;s take a look at the LLVM part first, since that is slightly simpler.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#compiling-rustcs-llvm-with-pgo&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;compiling-rustcs-llvm-with-pgo&quot;&gt;&lt;/a&gt;Compiling rustc&#x27;s LLVM with PGO&lt;/h3&gt;
&lt;p&gt;PGO is a toolchain specific feature, so how it works might be different for different C++ compilers.
In this article I will only go into how it works with Clang because (a) I have no experience with PGO in other compilers, and (b) Clang is what the Rust project actually uses in production.&lt;/p&gt;
&lt;p&gt;In order to enable PGO for rustc&#x27;s LLVM we basically follow the steps laid out in the previous section.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We make sure that our LLVM gets instrumented by applying the following changes to the &lt;code&gt;config.toml&lt;/code&gt; file in the root directory of our Rust checkout:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[llvm]

# Pass extra compiler and linker flags to the LLVM CMake build.
# &amp;lt;PROFDATA_DIR&amp;gt; must be an absolute path to a writeable
# directory, like for example /tmp/my-rustc-profdata
cflags &#x3D; &amp;quot;-fprofile-generate&#x3D;&amp;lt;PROFDATA_DIR&amp;gt;&amp;quot;
cxxflags &#x3D; &amp;quot;-fprofile-generate&#x3D;&amp;lt;PROFDATA_DIR&amp;gt;&amp;quot;

# Make sure that LLVM is built as a dylib
link-shared &#x3D; true

# Make sure we use Clang for compiling LLVM
# (assuming that we are building for x86_64 Linux in this case)
[target.x86_64-unknown-linux-gnu]
cc &#x3D; &amp;quot;clang&amp;quot;
cxx &#x3D; &amp;quot;clang++&amp;quot;
linker &#x3D; &amp;quot;clang&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;-fprofile-generate&lt;/code&gt; flag tells Clang to create an instrumented binary that will write any profile data it generates to the given directory.
It is advisable to always use an absolute path here since we don&#x27;t want things to depend on the working directory of the compiler.
We also set &lt;code&gt;link-shared &#x3D; true&lt;/code&gt; which makes sure that &lt;em&gt;rustc&lt;/em&gt;&#x27;s linker does not have to deal with linking the instrumentation runtime into C++ code.
It&#x27;s possible to make that work but it&#x27;s not worth the trouble.
Now we just need to run &lt;code&gt;./x.py build&lt;/code&gt; and wait until we have a working &lt;em&gt;rustc&lt;/em&gt; with an instrumented LLVM.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Next we collect profile data by running the compiler we built in the previous step.
This is straightforward because data collection happens completely transparently.
Just run the compiler as you always would (e.g. via Cargo) and the profile data will show up in the &lt;code&gt;&amp;lt;PROFDATA_DIR&amp;gt;&lt;/code&gt; we specified in the &lt;code&gt;-fprofile-generate&lt;/code&gt; flag above.
In order to make the collected data as useful as possible, we should try to exercise all the common code paths within the compiler.
I typically use the &amp;quot;standard&amp;quot; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustc-perf&quot;&gt;rustc-perf&lt;/a&gt; benchmark suite for this purpose, which includes debug builds, optimized builds, check builds, both incremental and non-incremental.
After this is done, you will find a number of &lt;code&gt;.profraw&lt;/code&gt; files in &lt;code&gt;&amp;lt;PROFDATA_DIR&amp;gt;&lt;/code&gt;.
&lt;a href&#x3D;&quot;https://clang.llvm.org/docs/UsersManual.html#cmdoption-fprofile-generate&quot;&gt;As described in the Clang user manual&lt;/a&gt; these &lt;code&gt;.profraw&lt;/code&gt; files need to be merged into a single &lt;code&gt;.profdata&lt;/code&gt; file by using the &lt;code&gt;llvm-profdata&lt;/code&gt; tool that comes with your Clang installation:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-bash&quot;&gt;$ cd &amp;lt;PROFDATA_DIR&amp;gt;
$ llvm-profdata merge -output&#x3D;rustc-llvm.profdata *.profraw
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start&#x3D;&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;Now that the combined profile data from all &lt;em&gt;rustc&lt;/em&gt; invocations can be found in &lt;code&gt;&amp;lt;PROFDATA_DIR&amp;gt;/rustc-llvm.profdata&lt;/code&gt; it is time to re-compile LLVM and &lt;em&gt;rustc&lt;/em&gt; again, this time instructing Clang to make use of this valuable new information.
To this end we modify &lt;code&gt;config.toml&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[llvm]
# Instead of -fprofile-generate, we now pass -fprofile-use to Clang
cflags &#x3D; &amp;quot;-fprofile-use&#x3D;&amp;lt;PROFDATA_DIR&amp;gt;/rustc-llvm.profdata&amp;quot;
cxxflags &#x3D; &amp;quot;-fprofile-use&#x3D;&amp;lt;PROFDATA_DIR&amp;gt;/rustc-llvm.profdata&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we make sure that LLVM is properly rebuilt by deleting the old version and build everything again:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-bash&quot;&gt;$ cd $RUST_PROJECT_ROOT
$ rm -rf ./build/x86_64-unknown-linux-gnu/llvm
$ ./x.py build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once this is done, we have a Rust compiler with PGO-optimized LLVM. Congratulations!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#pgo-optimized-llvm----benchmark-results&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;pgo-optimized-llvm----benchmark-results&quot;&gt;&lt;/a&gt;PGO-optimized LLVM -- Benchmark Results&lt;/h4&gt;
&lt;p&gt;As mentioned above Firefox build times have improved by up to 9% with a PGOed compiler.
Clang&#x27;s own documentation even &lt;a href&#x3D;&quot;https://www.llvm.org/docs/HowToBuildWithPGO.html#introduction&quot;&gt;reports&lt;/a&gt; an up to 20% improvement.
The best way we have for assessing the Rust compiler&#x27;s performance is the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustc-perf&quot;&gt;rustc-perf&lt;/a&gt; benchmark suite.
Since compiling with PGO does not quite fit with how the Rust project&#x27;s CI works, we cannot use the &lt;a href&#x3D;&quot;https://perf.rust-lang.org/&quot;&gt;perf.rust-lang.org&lt;/a&gt; version of the benchmark suite.
Fortunately, thanks to &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustc-perf/blob/master/collector/README.md&quot;&gt;good documentation&lt;/a&gt;, running the benchmarks locally is straightforward enough.
Here&#x27;s a glance at the effect that a PGOed LLVM has on &lt;em&gt;rustc&lt;/em&gt;&#x27;s performance:&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://perf.rust-lang.org/compare.html?start&#x3D;pgo-2020-10-30-none&amp;end&#x3D;pgo-2020-10-30-llvm&amp;stat&#x3D;instructions%3Au&quot;&gt;&lt;img src&#x3D;&quot;/images/inside-rust/2020-11-11-exploring-pgo-for-the-rust-compiler/rustc-perf-pgo-llvm-thumb.png&quot; alt&#x3D;&quot;Performance improvements gained from apply PGO to LLVM&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The results are not quite as spectacular as the anecdotal 20% improvement from Clang&#x27;s documentation;
but they are pretty encouraging and show no significant performance regressions.
Diving more into details shows the expected profile:&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/inside-rust/2020-11-11-exploring-pgo-for-the-rust-compiler/rustc-perf-pgo-llvm-expanded.png&quot; alt&#x3D;&quot;Performance improvements gained from apply PGO to LLVM (details)&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Workloads that spend most of their time in LLVM (e.g. optimized builds) show the most improvement, while workloads that don&#x27;t invoke LLVM at all (e.g. check builds) also don&#x27;t profit from a faster LLVM.
Let&#x27;s take a look at how we can take things further by applying PGO to the other half of the compiler.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#applying-pgo-to-the-rust-part-of-the-compiler&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;applying-pgo-to-the-rust-part-of-the-compiler&quot;&gt;&lt;/a&gt;Applying PGO to the Rust part of the compiler&lt;/h3&gt;
&lt;p&gt;The basic principle stays the same:
create an instrumented compiler, use it to collect profile data, use that data when compiling the final version of the compiler.
The only difference is that this time we instrument a different part of the compiler&#x27;s code, namely the part generated by &lt;em&gt;rustc&lt;/em&gt; itself.
The compiler has had support for doing that &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/61268&quot;&gt;for a while now&lt;/a&gt; and, as can be seen in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/rustc/profile-guided-optimization.html&quot;&gt;respective chapter of the rustc book&lt;/a&gt;, the command-line interface has been modeled after Clang&#x27;s set of flags.
Unfortunately, the compiler&#x27;s build system does not support using PGO out of the box, so we have to directly modify &lt;code&gt;src/bootstrap/compile.rs&lt;/code&gt; in order to set the desired flags.
We only want to instrument the compiler itself, not the other tools or the standard library, see we add the flags to &lt;code&gt;rustc_cargo_env()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub fn rustc_cargo_env(builder: &amp;amp;Builder&amp;lt;&#x27;_&amp;gt;,
                       cargo: &amp;amp;mut Cargo,
                       target: TargetSelection) {
    // ... omitted ...

    if builder.config.rustc_parallel {
        cargo.rustflag(&amp;quot;--cfg&#x3D;parallel_compiler&amp;quot;);
    }
    if builder.config.rust_verify_llvm_ir {
        cargo.env(&amp;quot;RUSTC_VERIFY_LLVM_IR&amp;quot;, &amp;quot;1&amp;quot;);
    }

    // This is new: Hard code instrumentation in the
    // RUSTFLAGS of the Cargo invocation that builds
    // the compiler
    cargo.rustflag(&amp;quot;-Cprofile-generate&#x3D;&amp;lt;PROFDATA_DIR&amp;gt;&amp;quot;);

    // ... omitted ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As before &lt;code&gt;&amp;lt;PROFDATA_DIR&amp;gt;&lt;/code&gt; must be an actual, absolute path to a directory.
Once we have collected enough profile data, we go back to &lt;code&gt;src/bootstrap/compile.rs&lt;/code&gt; and replace the &lt;code&gt;-Cprofile-generate&lt;/code&gt; flag with a &lt;code&gt;-Cprofile-use&lt;/code&gt; flag:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub fn rustc_cargo_env(builder: &amp;amp;Builder&amp;lt;&#x27;_&amp;gt;,
                       cargo: &amp;amp;mut Cargo,
                       target: TargetSelection) {
    // ... omitted ...

    if builder.config.rustc_parallel {
        cargo.rustflag(&amp;quot;--cfg&#x3D;parallel_compiler&amp;quot;);
    }
    if builder.config.rust_verify_llvm_ir {
        cargo.env(&amp;quot;RUSTC_VERIFY_LLVM_IR&amp;quot;, &amp;quot;1&amp;quot;);
    }

    // Replace &#x60;-Cprofile-generate&#x60; with &#x60;-Cprofile-use&#x60;,
    // assuming that we used the &#x60;llvm-profdata&#x60; tool to
    // merge the collected &#x60;&amp;lt;PROFDATA_DIR&amp;gt;/*.profraw&#x60; files
    // into a common file named
    // &#x60;&amp;lt;PROFDATA_DIR&amp;gt;/rustc-rust.profdata&#x60;.
    cargo.rustflag(
        &amp;quot;-Cprofile-use&#x3D;&amp;lt;PROFDATA_DIR&amp;gt;/rustc-rust.profdata&amp;quot;
    );

    // ... omitted ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#x27;s take a look at the effects PGO has on this portion of the compiler.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#pgo-optimized-rust----benchmark-results&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;pgo-optimized-rust----benchmark-results&quot;&gt;&lt;/a&gt;PGO-optimized Rust -- Benchmark Results&lt;/h4&gt;
&lt;p&gt;As expected the results are similar to when PGO was applied to LLVM: a reduction of instruction counts by roughly 5%. NOTE: These numbers show the improvement from applying PGO &lt;em&gt;exclusively&lt;/em&gt; to the Rust part of the compiler. The LLVM part was &lt;em&gt;not&lt;/em&gt; compiled with PGO here:&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://perf.rust-lang.org/compare.html?start&#x3D;pgo-2020-10-30-none&amp;end&#x3D;pgo-2020-10-30-rust&amp;stat&#x3D;instructions%3Au&quot;&gt;&lt;img src&#x3D;&quot;/images/inside-rust/2020-11-11-exploring-pgo-for-the-rust-compiler/rustc-perf-pgo-rust-thumb.png&quot; alt&#x3D;&quot;Performance improvements gained from applying PGO to (only) the Rust part of the compiler&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Because different workloads execute different amounts of Rust code (vs C++/LLVM code), the total reduction can be a lot less for LLVM-heavy cases.
For example, a full &lt;em&gt;webrender-opt&lt;/em&gt; build will spend more than 80% of its time in LLVM, so reducing the remaining 20% by 5% can only reduce the total number by 1%.
On the other hand, a &lt;em&gt;check&lt;/em&gt; build or an &lt;em&gt;incr-unchanged&lt;/em&gt; build spends almost no time in LLVM, so the 5% Rust performance improvement translates almost entirely into a 5% instruction count reduction for these cases:&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/inside-rust/2020-11-11-exploring-pgo-for-the-rust-compiler/rustc-perf-pgo-rust-expanded.png&quot; alt&#x3D;&quot;Performance improvements gained from applying PGO to (only) the Rust part of the compiler (details)&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#can-we-apply-pgo-to-rust-and-llvm-at-the-same-time&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;can-we-apply-pgo-to-rust-and-llvm-at-the-same-time&quot;&gt;&lt;/a&gt;Can we apply PGO to Rust and LLVM at the same time?&lt;/h3&gt;
&lt;p&gt;The short answer is &lt;em&gt;yes&lt;/em&gt;.
The longer answer is that we have to be careful about profile data incompatibilities.
Both Clang and the Rust compiler use the same LLVM-based PGO mechanisms underneath.
If both Clang and the Rust compiler use the exact same version of LLVM, we can even combine the two into a single &lt;code&gt;.profdata&lt;/code&gt; file.
However, if the two LLVM versions are different, we better make sure that the two compilers don&#x27;t get into each other&#x27;s way.
Luckily it&#x27;s straightforward to facilitate that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;We need to specify different directories for the respective &lt;code&gt;-fprofile-generate&lt;/code&gt; and &lt;code&gt;-Cprofile-generate&lt;/code&gt; (and &lt;code&gt;*-use&lt;/code&gt;) flags.
This way the instrumentation code coming from Clang will write into one directory and the code coming from &lt;em&gt;rustc&lt;/em&gt; will write into another.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;We need to make sure that we use the right &lt;code&gt;llvm-profdata&lt;/code&gt; tool for each set of &lt;code&gt;.profraw&lt;/code&gt; files.
Use the one coming with Clang for handling the files in the Clang directory and the one coming with the Rust compiler for the files in the Rust directory.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If we do that, we get a compiler with both parts optimized via PGO, with the compile time reductions adding up nicely.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#final-numbers-and-a-benchmarking-plot-twist&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;final-numbers-and-a-benchmarking-plot-twist&quot;&gt;&lt;/a&gt;Final Numbers and a Benchmarking Plot Twist&lt;/h3&gt;
&lt;p&gt;When I looked at the &lt;a href&#x3D;&quot;https://perf.rust-lang.org/compare.html?start&#x3D;pgo-2020-10-30-none&amp;end&#x3D;pgo-2020-10-30-both&amp;stat&#x3D;instructions%3Au&quot;&gt;the final numbers&lt;/a&gt;, I was a bit underwhelmed.
Sure, PGO seems to lead to a pretty solid 5% reduction of instruction counts across basically all real world workloads in the benchmark suite, for &lt;em&gt;check&lt;/em&gt;, &lt;em&gt;debug&lt;/em&gt;, and &lt;em&gt;opt&lt;/em&gt; builds alike.
That is pretty nice -- but also far away from the 20% improvement mentioned in the Clang documentation.
Given that PGO adds quite a few complications to the build process of the compiler itself (not to mention the almost tripled build times) I started to think that applying PGO to the compiler would probably not be worth the trouble.&lt;/p&gt;
&lt;p&gt;I then took a glance at the benchmarks&#x27; wall time measurements (instead of the instruction count measurements) and saw quite a different picture: &lt;em&gt;webrender-opt&lt;/em&gt; minus 15%, &lt;em&gt;style-servo-opt&lt;/em&gt; minus 14%, &lt;em&gt;serde-check&lt;/em&gt; minus 15%?
This looked decidedly better than for instruction counts.
But wall time measurements can be very noisy (which is why most people only look at instruction counts on perf.rust-lang.org), and &lt;code&gt;rustc-perf&lt;/code&gt; only does a single iteration for each benchmark, so I was not prepared to trust these numbers just yet.
I decided to try and reduce the noise by increasing the number of benchmark iterations from one to twenty.
I only did &amp;quot;full&amp;quot; builds in this configuration as PGO&#x27;s effect seemed to translate pretty predictably to incremental builds.
After roughly eight hours to complete both the PGO and the non-PGO versions of the benchmarks these are the numbers I got:&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://perf.rust-lang.org/compare.html?start&#x3D;pgo-2020-10-30-none-20&amp;end&#x3D;pgo-2020-10-30-both-20&amp;stat&#x3D;wall-time&quot;&gt;&lt;img src&#x3D;&quot;/images/inside-rust/2020-11-11-exploring-pgo-for-the-rust-compiler/rustc-perf-pgo-both-walltime-thumb.png&quot; alt&#x3D;&quot;Wall time improvements gained from applying PGO to the entire compiler&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As you can see we get a 10-16% reduction of build times almost across the board for real world test cases.
This was more in line with what I had initially hoped to get from PGO.
It is a bit surprising that the difference between instruction counts and wall time is so pronounced.
One plausible explanation would be that PGO improves instruction cache utilization, something which makes a difference for execution time but would not be reflected in the amount of instructions executed.
I also don&#x27;t know how branch mispredictions factor into instruction counts -- branch prediction being another aspect explicitly targeted by PGO.&lt;/p&gt;
&lt;p&gt;As good as these numbers look, please keep in mind that they come from a single machine.
It&#x27;s possible that the Ryzen 1700X processor I used has some idiosyncrasies that favor the kind of optimizations that PGO does, and a different processor with a different caching system and branch predictor would generate quite different numbers.
Nonetheless, the numbers undoubtedly are very encouraging and warrant further investigation.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#where-to-go-from-here&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;where-to-go-from-here&quot;&gt;&lt;/a&gt;Where to go from here&lt;/h2&gt;
&lt;p&gt;The numbers above suggest that PGO can indeed provide noticeable compile time reductions.
Unfortunately, bringing these improvements to end users is not as simple as adding a few compiler flags to our &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/tree/master/src/ci/docker/host-x86_64&quot;&gt;dist builds&lt;/a&gt;.
PGO is different from most other optimizations in that it&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;requires a different, extended build workflow due to the additional instrumentation and data collection phases, and&lt;/li&gt;
&lt;li&gt;it incurs a sustained build time cost (a trait it shares with other automated optimizations like LTO).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both of these problems pose substantial hurdles for actually using PGO on the compiler itself.
Rust&#x27;s CI build times have always been too long and we already forgo some optimizations because of them
(e.g. macOS still does not get the 10% performance boost from using a ThinLTOed LLVM because the build machines on that platform are especially slow).
However, I think there&#x27;s still a way forward. There&#x27;s a tradeoff between the two obstacles mentioned above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If build times are not a problem, then the engineering effort for supporting PGO in the compiler&#x27;s build system is quite low.
That is, if it is OK for instrumentation, data collection, and final build to all occur as a single monolithic build on the same machine then it should be straightforward to extend the build system to support just that.&lt;/li&gt;
&lt;li&gt;If a lot of engineering effort is put into a more complicated build setup, with out-of-band instrumentation and caching of profile data, then the impact on build times can be kept quite low.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I estimate that the first approach is more fruitful, as it is always better to put more value on low engineering and maintenance costs than on low compute times.
Having a straightforward way of obtaining a PGOed compiler (e.g. by adding a simple setting in &lt;code&gt;config.toml&lt;/code&gt;) would unblock the path to a couple of scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Organizations and individuals who don&#x27;t switch compiler versions too frequently can easily compile their own, optimized version of &lt;em&gt;rustc&lt;/em&gt; for internal use, like Mozilla is already doing with Clang.
Letting a computer spend a couple of hours in order to get a 15% compile time reduction for the next couple of months seems like a good investment.&lt;/li&gt;
&lt;li&gt;The Rust project itself could start thinking about providing more optimized builds, at least on the beta and stable channels.
Significantly increasing the compiler&#x27;s build times on the official build infrastructure is a lot more viable if it only has to be done every six weeks instead of for every merged pull request.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It&#x27;s unlikely that I can spend a lot of time on this personally -- but my hope is that others will pick up the baton. I&#x27;d be happy to provide guidance on how to use PGO specifically.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt; -- Special thanks to Mark Rousskov for uploading my local benchmarking data to &lt;a href&#x3D;&quot;https://perf.rust-lang.org/compare.html?start&#x3D;pgo-2020-10-30-none-20&amp;end&#x3D;pgo-2020-10-30-both-20&amp;stat&#x3D;wall-time&quot;&gt;perf.rust-lang.org&lt;/a&gt;, which makes it much nicer to explore!&lt;/p&gt;
</content>

        <author>
            <name>Michael Woerister</name>
        </author>
    </entry>
    
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2023-04-12T21:01:46+00:00</updated>

    
    <entry>
        <title>A note on the Trademark Policy Draft</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html" type="text/html" title="A note on the Trademark Policy Draft" />
        <published>2023-04-12T00:00:00+00:00</published>
        <updated>2023-04-12T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/04/12/trademark-policy-draft-feedback.html">&lt;h1&gt;&lt;a href&#x3D;&quot;#a-note-on-the-trademark-policy-draft&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-note-on-the-trademark-policy-draft&quot;&gt;&lt;/a&gt;A note on the Trademark Policy Draft&lt;/h1&gt;
&lt;p&gt;For the past eight months, the Rust Foundation Project Directors have been working with the informal Trademark Working Group and the Foundation staff to draft an updated policy and FAQ for the Rust trademark. We&#x27;d like to provide some context around this work and address the community response to the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt; for the recently circulated draft.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#background&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;background&quot;&gt;&lt;/a&gt;Background&lt;/h2&gt;
&lt;p&gt;Back when the Rust Foundation was created, one of the first things to happen was Mozilla transferring its ownership of the Rust trademark to the newly created foundation. An update to the existing policy&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; was needed, and project leadership planned for this to be done together with the Foundation.&lt;/p&gt;
&lt;p&gt;Since we wanted to incorporate community input to this policy and make it accessible as possible, the board waited until the Foundation was well-staffed to coordinate the effort. That included things like running a [community-wide survey] and discussing the result with a number of stakeholders, including the board, community members, project leadership, as well as legal counsel. The latest state of this process is the draft that was published late last week.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#our-approach&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;our-approach&quot;&gt;&lt;/a&gt;Our approach&lt;/h2&gt;
&lt;p&gt;Since the draft was announced, we&#x27;ve noticed a widespread impression that this policy was created solely by the Foundation and is being imposed on the Rust Project and community. That is not true. The policy draft was created with the input and consent of each of the co-authors of this post, with the intent to clarify existing policies, incorporate community feedback, and preserve the Rust brand for years to come. The Foundation also cannot – and has no interest in – unilaterally adopting such a policy without the agreement and involvement of its Project Directors.&lt;/p&gt;
&lt;p&gt;There can be wildly differing opinions on how to achieve a particular intent.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; Fundamentally however, the question at hand is whether we want Rust to be a trademark or not. If we want to be able to defend Rust as the brand it is today, trademark law fundamentally constrains how permissible we can be, especially in public guidelines.&lt;/p&gt;
&lt;p&gt;Our answer to the question of whether Rust should be a trademark has been &amp;quot;yes&amp;quot;, just as it has been since before Rust 1.0. Furthermore, our goal is to make a policy that is as permissive as it can be without substantially giving up our right to define what Rust &lt;em&gt;is&lt;/em&gt; and &lt;em&gt;is not&lt;/em&gt; in the future. Not all open source projects have retained that right.&lt;/p&gt;
&lt;p&gt;We aren&#x27;t lawyers and we leave the question of &lt;em&gt;how&lt;/em&gt; to do that to them – and believe us when we say we have gone through &lt;em&gt;many&lt;/em&gt; rounds of questions with ours, who have extensive experience in open source projects.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#feedback&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;feedback&quot;&gt;&lt;/a&gt;Feedback&lt;/h2&gt;
&lt;p&gt;The current proposal is a draft that the Foundation staff, Project Directors, and Trademark Working Group are actively seeking feedback on. We will not ship a trademark policy that Project representatives and the Foundation aren&#x27;t happy with and proud of after reviewing community feedback.&lt;/p&gt;
&lt;p&gt;We genuinely appreciate all the thoughtful input the community has already left, both in public and via the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt;.&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn3&quot; id&#x3D;&quot;fnref3&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; Please continue to utilize this form as the official way of getting feedback back into this process. We know the draft is not perfect, and we&#x27;re committed to fixing any mistakes identified and considering the feedback we get.&lt;/p&gt;
&lt;p&gt;Unfortunately, in addition to the large volume of thoughtful and respectful feedback, we&#x27;re ashamed to say we&#x27;ve seen firsthand examples of significant harassment and abuse directed at the Foundation staff. &lt;strong&gt;We condemn this in the strongest possible terms.&lt;/strong&gt; These folks have been doing their best to navigate an extremely diverse set of interests and viewpoints throughout this process. It&#x27;s unacceptable for anyone in the Rust community to demean, harass or insult anyone, let alone the people we&#x27;ve asked to do this work.&lt;/p&gt;
&lt;p&gt;Please remember that any and all communication with Foundation staff is subject to the Rust project &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/code-of-conduct&quot;&gt;Code of Conduct&lt;/a&gt; and will be enforced accordingly. We don&#x27;t expect this to be an issue for most people participating, but when emotions run high it&#x27;s always a good idea to check your assumptions and remember the person on the other end of the keyboard.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#next-steps&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;next-steps&quot;&gt;&lt;/a&gt;Next steps&lt;/h2&gt;
&lt;p&gt;We want to thank the community for participating in this process, and for your patience as we learn the best way to navigate it. We recognize that the process and communication around it could have been better. Notably, the wider project was insufficiently included in the process. We were  responsible for that and apologize.&lt;/p&gt;
&lt;p&gt;We&#x27;re committed to learning everything we can from this process and your feedback, and to talking as openly as we can about what we&#x27;ve learned. To that end, we will soon conduct and publish a retrospective around how the process unfolded.&lt;/p&gt;
&lt;p&gt;Thank you again to those who have shared their thoughts on the Rust Trademark Policy draft respectfully. A summary of the feedback received will be shared after the consultation period closes. If you have not yet reviewed the draft, we invite you to fill out the &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSdaM4pdWFsLJ8GHIUFIhepuq0lfTg_b0mJ-hvwPdHa4UTRaAg/viewform&quot;&gt;feedback form&lt;/a&gt; by April 16 at 5 PM PDT. We only ask that you treat everyone in this community, including the Rust Foundation team, respectfully when doing so.&lt;/p&gt;
&lt;p&gt;Sincerely,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ryan Levick, Project Director and trademark working group member&lt;/li&gt;
&lt;li&gt;Jane Losare-Lusby, Project Director&lt;/li&gt;
&lt;li&gt;Tyler Mandry, Project Director&lt;/li&gt;
&lt;li&gt;Mark Rousskov, Project Director&lt;/li&gt;
&lt;li&gt;Josh Stone, Project Director and trademark working group member&lt;/li&gt;
&lt;li&gt;Josh Triplett, Lang team lead and trademark working group member&lt;/li&gt;
&lt;/ul&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;https://prev.rust-lang.org/en-US/legal.html &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;This was none more apparent than when the community survey got over 1,000 responses, representing a number of popular but fundamentally incompatible views. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn3&quot;&gt;
&lt;p&gt;We know this feedback-via-form exercise is not familiar, and we&#x27;re still getting used to it, too. But it&#x27;s really the best we can do when we&#x27;re asking a heroic staff to read and respond to the feedback, and when it&#x27;s a legal matter where what we say can have substantial consequences down the line. &lt;a href&#x3D;&quot;#fnref3&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Ryan Levick, Jane Losare-Lusby, Tyler Mandry, Mark Rousskov, Josh Stone, and Josh Triplett</name>
        </author>
    </entry>
    
    <entry>
        <title>Welcome Arlo and Scott to the Cargo Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html" type="text/html" title="Welcome Arlo and Scott to the Cargo Team" />
        <published>2023-04-06T00:00:00+00:00</published>
        <updated>2023-04-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/04/06/cargo-new-members.html">&lt;p&gt;We are excited to welcome &lt;a href&#x3D;&quot;https://github.com/arlosi&quot;&gt;Arlo Siemsen&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/Muscraft&quot;&gt;Scott Schafer&lt;/a&gt; as new members to the Cargo Team!&lt;/p&gt;
&lt;p&gt;Arlo has been instrumental in bringing Cargo&#x27;s new &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2023/01/30/cargo-sparse-protocol.html&quot;&gt;sparse registry&lt;/a&gt; support to fruition, which significantly improves registry performance. He has been involved with registry design and authentication discussions, and has been closely working with the team over the past year.&lt;/p&gt;
&lt;p&gt;Scott has been very active in the past year, working on various parts of Cargo, namely implementing &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table&quot;&gt;workspace inheritance&lt;/a&gt;. Since then, he has been helping with maintenance and designing new features.&lt;/p&gt;
&lt;p&gt;With their help we now have capacity to start thinking about how feature development should be done moving forward. We are still in early discussions of processes for matching feature development with reviewer capacity, and will share more in the future. Thanks to Arlo and Scott for their help, and we are very much looking forward to having them as a part of the team!&lt;/p&gt;
</content>

        <author>
            <name>Eric Huss</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.2 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html" type="text/html" title="1.68.2 pre-release testing" />
        <published>2023-03-27T00:00:00+00:00</published>
        <updated>2023-03-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/27/1.68.2-prerelease.html">&lt;p&gt;The 1.68.2 pre-release is ready for testing. The release is scheduled for
March 28. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1682-2023-03-28&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-27/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-27/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-2-pre-release-testing/18585&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.1 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html" type="text/html" title="1.68.1 pre-release testing" />
        <published>2023-03-20T00:00:00+00:00</published>
        <updated>2023-03-20T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/20/1.68.1-prerelease.html">&lt;p&gt;The 1.68.1 pre-release is ready for testing. The release is scheduled for
March 23. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1681-2023-03-23&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-20/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-20/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-1-pre-release-testing/18547&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>1.68.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html" type="text/html" title="1.68.0 pre-release testing" />
        <published>2023-03-06T00:00:00+00:00</published>
        <updated>2023-03-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/03/06/1.68.0-prerelease.html">&lt;p&gt;The 1.68.0 pre-release is ready for testing. The release is scheduled for
March 09. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1680-2023-03-09&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2023-03-06/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2023-03-06/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-68-0-pre-release-testing/18481&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Keyword Generics Progress Report: February 2023</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html" type="text/html" title="Keyword Generics Progress Report: February 2023" />
        <published>2023-02-23T00:00:00+00:00</published>
        <updated>2023-02-23T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/02/23/keyword-generics-progress-report-feb-2023.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#introduction&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h2&gt;
&lt;p&gt;About 9 months ago &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html&quot;&gt;we announced&lt;/a&gt; the creation of the Keyword Generics
Initiative; a group working under the lang team with the intent to solve the
&lt;a href&#x3D;&quot;https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/&quot;&gt;function coloring problem&lt;/a&gt; &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; through the type system not just for
&lt;code&gt;async&lt;/code&gt;, but for &lt;code&gt;const&lt;/code&gt; and all current and future function modifier keywords
as well.&lt;/p&gt;
&lt;p&gt;We&#x27;re happy to share that we&#x27;ve made a lot of progress over these last several
months, and we&#x27;re finally ready to start putting some of our designs forward through
RFCs. Because it&#x27;s been a while since our last update, and because we&#x27;re excited
to share what we&#x27;ve been working on, in this post we&#x27;ll be going over some of the things
we&#x27;re planning to propose.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#an-async-example&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;an-async-example&quot;&gt;&lt;/a&gt;An async example&lt;/h2&gt;
&lt;p&gt;In our &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html&quot;&gt;previous post&lt;/a&gt; we introduced the placeholder &lt;code&gt;async&amp;lt;A&amp;gt;&lt;/code&gt; syntax to describe the
concept of a &amp;quot;function which is generic over its asyncness&amp;quot;. We always knew we
wanted something that felt lighter weight than that, so in for our current design
we&#x27;ve chosen to drop the notion of a generic parameter for the end-user syntax,
and instead picked the &lt;code&gt;?async&lt;/code&gt; notation. We&#x27;ve borrowed this from the trait
system, where for example &lt;code&gt;+ ?Sized&lt;/code&gt; indicates that something may or may not
implement the &lt;code&gt;Sized&lt;/code&gt; trait. Similarly &lt;code&gt;?async&lt;/code&gt; means a function may or may not be
async. We also refer to these as &amp;quot;maybe-async&amp;quot; functions.&lt;/p&gt;
&lt;p&gt;Time for an example. Say we took the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/io/trait.Read.html&quot;&gt;&lt;code&gt;Read&lt;/code&gt; trait&lt;/a&gt; and the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/io/fn.read_to_string.html&quot;&gt;read_to_string_methods&lt;/a&gt;. In the stdlib their implementations look somewhat
like this today:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Read {
    fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { ... }
}

/// Read from a reader into a string.
fn read_to_string(reader: &amp;amp;mut impl Read) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string)?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, what if we wanted to make these async in the future? Using &lt;code&gt;?async&lt;/code&gt;
notation we could change them to look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait ?async Read {
    ?async fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    ?async fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { ... }
}

/// Read from a reader into a string.
?async fn read_to_string(reader: &amp;amp;mut impl ?async Read) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).await?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The way this would work is that &lt;code&gt;Read&lt;/code&gt; and &lt;code&gt;read_to_string&lt;/code&gt; would become generic over
their &amp;quot;asyncness&amp;quot;. When compiled for an &lt;code&gt;async&lt;/code&gt; context, they will behave
asynchronously. When compiled in a non-async context, they will behave
synchronously. The &lt;code&gt;.await&lt;/code&gt; in the &lt;code&gt;read_to_string&lt;/code&gt; function body is necessary
to mark the cancellation point in case the function is compiled as async; but
when not async would essentially become a no-op &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// &#x60;read_to_string&#x60; is inferred to be &#x60;!async&#x60; because
// we didn&#x27;t &#x60;.await&#x60; it, nor expected a future of any kind.
#[test]
fn sync_call() {
    let _string &#x3D; read_to_string(&amp;quot;file.txt&amp;quot;)?;
}

// &#x60;read_to_string&#x60; is inferred to be &#x60;async&#x60; because
// we &#x60;.await&#x60;ed it.
#[async_std::test]
async fn async_call() {
    let _string &#x3D; read_to_string(&amp;quot;file.txt&amp;quot;).await?;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We expect &lt;code&gt;?async&lt;/code&gt; notation would be most useful for library code which doesn&#x27;t
do anything particularly specific to async Rust. Think: most of the stdlib, and
ecosystem libraries such as parsers, encoders, and drivers. We expect most
applications to choose to be compiled either as async or non-async, making them
mostly a consumer of &lt;code&gt;?async&lt;/code&gt; APIs.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-const-example&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-const-example&quot;&gt;&lt;/a&gt;A const example&lt;/h2&gt;
&lt;p&gt;A main driver of the keywords generics initiative has been our desire to make the
different modifier keywords in Rust feel consistent with one another. Both the
const WG and the async WG were thinking about introducing keyword-traits at the
same time, and we figured we should probably start talking with each other to make
sure that what we were going to introduce felt like it was part of the same
language - and could be extended to support more keywords in the future.&lt;/p&gt;
&lt;p&gt;So with that in mind, it may be unsurprising that for the maybe-&lt;code&gt;const&lt;/code&gt; trait
bounds and declarations we&#x27;re going to propose using the &lt;code&gt;?const&lt;/code&gt; notation.
A common source of confusion with &lt;code&gt;const fn&lt;/code&gt; is that it actually doesn&#x27;t
guarantee compile-time execution; it only means that it&#x27;s &lt;em&gt;possible&lt;/em&gt; to evaluate
in a &lt;code&gt;const&lt;/code&gt; compile-time context. So in a way &lt;code&gt;const fn&lt;/code&gt; has always been a way
of declaring a &amp;quot;maybe-const&amp;quot; function, and there isn&#x27;t a way to declare an
&amp;quot;always-const&amp;quot; function. More on that later in this post.&lt;/p&gt;
&lt;p&gt;Taking the &lt;code&gt;Read&lt;/code&gt; example we used earlier, we could imagine a &amp;quot;maybe-const&amp;quot; version
of the &lt;code&gt;Read&lt;/code&gt; trait to look very similar:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait ?const Read {
    ?const fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    ?const fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which we could then use use as a bound in the const &lt;code&gt;read_to_string&lt;/code&gt; function,
like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;const fn read_to_string(reader: &amp;amp;mut impl ?const Read) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string)?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just like with &lt;code&gt;?async&lt;/code&gt; traits, &lt;code&gt;?const&lt;/code&gt; traits would also need to be labeled as
&lt;code&gt;?const&lt;/code&gt; when used as a bound. This is important to surface at the trait level,
because it&#x27;s allowed to pass non-const bounds to maybe-const functions, as long
as no trait methods are called in the function body. This means we need to
distinguish between &amp;quot;never-const&amp;quot; and &amp;quot;maybe-const&amp;quot;.&lt;/p&gt;
&lt;p&gt;You may have noticed the &lt;code&gt;?const&lt;/code&gt; on the trait declaration and the extra
&lt;code&gt;?const&lt;/code&gt; on the trait methods. This is on purpose: it keeps the path open to
potentially add support for &amp;quot;always-const&amp;quot; or &amp;quot;never-const&amp;quot; methods on traits as
well. In &lt;code&gt;?async&lt;/code&gt; we know that even if the entire trait is &lt;code&gt;?async&lt;/code&gt;, some
methods (such as &lt;code&gt;Iterator::size_hint&lt;/code&gt;) will never be async. And this would
make &lt;code&gt;?const&lt;/code&gt; and &lt;code&gt;?async&lt;/code&gt; traits behave similarly using the same rules.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#combining-const-and-async&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;combining-const-and-async&quot;&gt;&lt;/a&gt;Combining const and async&lt;/h2&gt;
&lt;p&gt;We&#x27;ve covered &lt;code&gt;?async&lt;/code&gt;, and we&#x27;ve covered &lt;code&gt;?const&lt;/code&gt;. Now what happens if we were
to use them together? Let&#x27;s take a look at what the &lt;code&gt;Read&lt;/code&gt; trait would look like
when if we extended it using our designs for &lt;code&gt;?const&lt;/code&gt; and &lt;code&gt;?async&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait ?const ?async Read {
    ?const ?async fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    ?const ?async fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { .. }
}

/// Read from a reader into a string.
const ?async fn read_to_string(reader: &amp;amp;mut impl ?const ?async Read) -&amp;gt; io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).await?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That&#x27;s sure starting to feel like a lot of keywords, right? We&#x27;ve accurately
described exactly what&#x27;s going on, but there&#x27;s a lot of repetition. We know that
if we&#x27;re dealing with a &lt;code&gt;const ?async fn&lt;/code&gt;, most arguments probably will
want to be &lt;code&gt;?const ?async&lt;/code&gt;. But under the syntax rules we&#x27;ve proposed so far,
you&#x27;d end up repeating that everywhere. And it probably gets worse once we start
adding in more keywords. Not ideal!&lt;/p&gt;
&lt;p&gt;So we&#x27;re very eager to make sure that we find a solution to this. And we&#x27;ve been
thinking about a way we could get out of this, which we&#x27;ve been calling
&lt;code&gt;effect/.do&lt;/code&gt;-notation. This would allow you to mark a function as &amp;quot;generic over
all modifier keywords&amp;quot; by annotating it as &lt;code&gt;effect fn&lt;/code&gt;, and it would allow the
compiler to insert all the right &lt;code&gt;.await&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;yield&lt;/code&gt; keywords in the
function body by suffixing function calls with &lt;code&gt;.do&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Just to set some expectations: this is the least developed part of our proposal,
and we don&#x27;t intend to formally propose this until after we&#x27;re done with some of
the other proposals. But we think it&#x27;s an important part of the entire vision,
so we wanted to make sure we shared it here. And with that out of the way,
here&#x27;s the same example we had above, but this time using the &lt;code&gt;effect/.do&lt;/code&gt;-notation:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait ?effect Read {
    ?effect fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    ?effect fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { .. }
}

/// Read from a reader into a string.
?effect fn read_to_string(reader: &amp;amp;mut impl ?effect Read) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).do;  // note the singular &#x60;.do&#x60; here
    string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One of the things we would like to figure out as part of &lt;code&gt;effect/.do&lt;/code&gt; is a way
to enable writing conditional effect-bounds. For example: there may be a
function which is always async, may never panic, and is generic over the
remainder of the effects. Or like we&#x27;re seeing with APIs such as
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.reserve&quot;&gt;&lt;code&gt;Vec::reserve&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve&quot;&gt;&lt;code&gt;Vec::try_reserve&lt;/code&gt;&lt;/a&gt;: the ability to panic xor return an
error. This will take more time and research to figure out, but we believe it
is something which can be solved.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#adding-support-for-types&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;adding-support-for-types&quot;&gt;&lt;/a&gt;Adding support for types&lt;/h2&gt;
&lt;p&gt;Something we&#x27;re keen on doing is not just adding support for &lt;code&gt;?async&lt;/code&gt; and to
apply to functions, traits, and trait bounds. We would like &lt;code&gt;?async&lt;/code&gt; to be
possible to use with types as well. This would enable the ecosystem to stop
having to provide both sync and async versions of crates. It would also enable
the stdlib to gradually &amp;quot;asyncify&amp;quot; just like we have been with const.&lt;/p&gt;
&lt;p&gt;The challenge with async types, especially in the stdlib, is that their behavior
will often have to be different when used in async and non-async contexts. At
the very lowest level async system calls work a bit differently from non-async
system calls. But we think we may have a solution for that too in the form of
the &lt;code&gt;is_async&lt;/code&gt; compiler built-in method.&lt;/p&gt;
&lt;p&gt;Say we wanted to implement &lt;code&gt;?async File&lt;/code&gt; with a single &lt;code&gt;?async open&lt;/code&gt; method. The
way we expect this to look will be something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;/// A file which may or may not be async
struct ?async File {
    file_descriptor: std::os::RawFd,  // shared field in all contexts
    async waker: Waker,               // field only available in async contexts
    !async meta: Metadata,            // field only available in non-async contexts
}

impl ?async File {
    /// Attempts to open a file in read-only mode.
    ?async fn open(path: Path) -&amp;gt; io::Result&amp;lt;Self&amp;gt; {
        if is_async() {   // compiler built-in function
            // create an async &#x60;File&#x60; here; can use &#x60;.await&#x60;
        } else {
            // create a non-async &#x60;File&#x60; here
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would enable authors to use different fields depending on whether they&#x27;re
compiling for async or not, while still sharing a common core. And within
function bodies it would be possible to provide different behaviors depending on
the context as well. The function body notation would work as a generalization
of the currently unstable &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/intrinsics/fn.const_eval_select.html&quot;&gt;&lt;code&gt;const_eval_select&lt;/code&gt;&lt;/a&gt; intrinsic, and at
least for the function bodies we expect a similar &lt;code&gt;is_const()&lt;/code&gt; compiler built-in
to be made available as well.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#consistent-syntax&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;consistent-syntax&quot;&gt;&lt;/a&gt;Consistent syntax&lt;/h2&gt;
&lt;p&gt;As we alluded to earlier in the post: one of the biggest challenges we see in
language design is adding features in a way that makes them feel like they&#x27;re in
harmony with the rest of the language - and not something which stands out as
noticably different. And because we&#x27;re touching on something core to Rust, the
way we do keywords, we have to pay extra close attention here to make sure Rust
keeps feeling like a single language.&lt;/p&gt;
&lt;p&gt;Luckily Rust has the ability to make surface-level changes to the
language through the edition system. There are many things this doesn&#x27;t let us
do, but it does allow us to require syntax changes. A possibility we&#x27;re
exploring is leveraging the edition system to make some minor changes to &lt;code&gt;const&lt;/code&gt;
and &lt;code&gt;async&lt;/code&gt; so they feel more consistent with one another, and with &lt;code&gt;?const&lt;/code&gt; and
&lt;code&gt;?async&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For &lt;code&gt;const&lt;/code&gt; this means there should be a syntactic distinction between &lt;code&gt;const&lt;/code&gt;
declarations and &lt;code&gt;const&lt;/code&gt; uses. Like we mentioned earlier in the post, when you
write &lt;code&gt;const fn&lt;/code&gt; you get a function which can be evaluated both at runtime and
during compilation. But when you write &lt;code&gt;const FOO: () &#x3D; ..;&lt;/code&gt; the meaning of
&lt;code&gt;const&lt;/code&gt; there guarantees compile-time evaluation. One keyword, different
meanings. So for that reason we&#x27;re wondering whether perhaps it would make more
sense if we changed &lt;code&gt;const fn&lt;/code&gt; to &lt;code&gt;?const fn&lt;/code&gt;.  This would make it clear that
it&#x27;s a function which &lt;em&gt;may&lt;/em&gt; be const-evaluated, but doesn&#x27;t necessarily have to -
and can also be called from non-&lt;code&gt;const&lt;/code&gt; contexts.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;//! Define a function which may be evaluated both at runtime and during
//! compilation.

// Current
const fn meow() -&amp;gt; String { .. }

// Proposed
?const fn meow() -&amp;gt; String { .. }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For &lt;code&gt;async&lt;/code&gt; we&#x27;re considering some similar surface-level changes.  The Async WG
is in the process of expanding the &amp;quot;async functions in traits&amp;quot; design into an
design covering &amp;quot;async traits&amp;quot; entirely, largely motivated by the desire to be
able to add &lt;code&gt;+ Send&lt;/code&gt; bound to anonymous futures. There are more details about
this in &lt;a href&#x3D;&quot;https://blog.theincredibleholk.org/blog/2023/02/16/lightweight-predictable-async-send-bounds/&quot;&gt;&amp;quot;Lightweight, Predictable Async Send Bounds&amp;quot;&lt;/a&gt; by Eric
Holk. But it would roughly become the following notation:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct File { .. }
impl async Read for File {                                                // async trait declaration
    async fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; io::Result&amp;lt;usize&amp;gt; { .. }  // async method
}

async fn read_to_string(reader: &amp;amp;mut impl async Read) -&amp;gt; io::Result&amp;lt;String&amp;gt; { // async trait bound
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).await?;
    Ok(string)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This would make &lt;code&gt;impl ?async Read&lt;/code&gt; and &lt;code&gt;impl async Read&lt;/code&gt; consistent with each
other. And it would open the door for &lt;code&gt;trait ?async&lt;/code&gt; traits to be passed to
&lt;code&gt;impl async Read&lt;/code&gt; and be guaranteed to be always interpreted as &lt;code&gt;trait async&lt;/code&gt;.
Which is another nice consistency gain.&lt;/p&gt;
&lt;p&gt;The final thing we&#x27;re looking at is &lt;code&gt;async&lt;/code&gt;-notation for types. To implement
inherent &lt;code&gt;?async&lt;/code&gt; methods on types, our current design requires the type to also
be marked as &lt;code&gt;?async&lt;/code&gt;. In order to bring &lt;code&gt;?async&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt; closer together,
we&#x27;re exploring whether it might also make sense to require types to be marked
as &lt;code&gt;async&lt;/code&gt; as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;//! Proposed: define a method on a maybe-async type
struct ?async File { .. }
impl ?async File {
    ?async fn open(path: PathBuf) -&amp;gt; io::Result&amp;lt;Self&amp;gt; { .. }
}

//! Current: define a method on an always-async type
struct File { .. }
impl File {
    async fn open(path: PathBuf) -&amp;gt; io::Result&amp;lt;Self&amp;gt; { .. }
}

//! Proposed: define a method on an always-async type
struct async File { .. }
impl async File {
    async fn open(path: PathBuf) -&amp;gt; io::Result&amp;lt;Self&amp;gt; { .. }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We already have something similar going on for &amp;quot;always-const&amp;quot; arguments via the
const-generics system. These look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn foo&amp;lt;const N: usize&amp;gt;() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every &amp;quot;always-const&amp;quot; argument to the function must always be marked by &lt;code&gt;const&lt;/code&gt;,
so it wouldn&#x27;t be entirely without precedent for every &amp;quot;always-async&amp;quot; type to
always require to be marked using &lt;code&gt;async&lt;/code&gt;. So we&#x27;re exploring some of what might
be possible here.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-tentative-plan&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-tentative-plan&quot;&gt;&lt;/a&gt;The tentative plan&lt;/h2&gt;
&lt;p&gt;We plan to initially focus our efforts on the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; keywords only.
We&#x27;re feeling ready to start converting some of our designs into RFCs, and start
putting them out for review. In the coming months we expect to start writing
the following proposals (in no particular order):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;?async fn&lt;/code&gt; notation without trait bounds, including an &lt;code&gt;is_async&lt;/code&gt; mechanism.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trait async&lt;/code&gt;  declarations and bounds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trait ?async&lt;/code&gt; declarations and bounds, &lt;code&gt;trait ?const&lt;/code&gt; declarations and bounds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?const fn&lt;/code&gt; notation without trait bounds.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct async&lt;/code&gt; notation and &lt;code&gt;struct ?const&lt;/code&gt; notation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&#x27;ll be working closely with the Lang Team, Const WG, and Async WG on these
proposals, and in some cases (such as &lt;code&gt;trait async&lt;/code&gt;) we may even take an
advising role with a WG directly driving the RFC. As usual, these will be going
through the RFC-nightly-stabilization cycle. And only once we&#x27;re fully confident
in them will they become available on stable Rust.&lt;/p&gt;
&lt;p&gt;We&#x27;re intentionally not yet including &lt;code&gt;effect/.do&lt;/code&gt; notation on this roadmap. We
expect to only be able to start this work once we have &lt;code&gt;?async&lt;/code&gt; on nightly,
which we don&#x27;t yet have. So for now we&#x27;ll continue work on designing it within
the initiative, and hold off on making plans to introduce it quiet yet.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;And that concludes the 9-month progress report of the Keyword Generics
Initiative. We hope to be able to provide more exact details about things such
as desugarings, semantics, and alternatives in the RFCs. We&#x27;re pretty stoked with the
progress we&#x27;ve made in these past few months! Something which I don&#x27;t think
we&#x27;ve mentioned yet, but is probably good to share: we&#x27;ve actually prototyped
much of the work in this post already; so we&#x27;re feeling fairly confident all of
this may actually &lt;em&gt;actually&lt;/em&gt; work. And that is something we&#x27;re
incredibly excited for!&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;To briefly recap this problem: you can&#x27;t call an &lt;code&gt;async fn&lt;/code&gt; from a
non-async fn. This makes the &amp;quot;async&amp;quot; notation go viral, as every function that
calls it also needs to be async. But we believe possibly more importantly: it
requires a duplication of most stdlib types and ecosystem libraries. Instead we
suspected we might be able to overcome this issue by introducing a new kind of
generic which would enable functions and types to be &amp;quot;generic&amp;quot; over whether
they&#x27;re async or not, const or not, etc. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;One restriction &lt;code&gt;?async&lt;/code&gt; contexts have is that they can
only call other &lt;code&gt;?async&lt;/code&gt; and non-&lt;code&gt;async&lt;/code&gt; functions. Because if we could call an
always-&lt;code&gt;async&lt;/code&gt; function, there would be no clear right thing to do when compiled
in non-async mode. So things like async concurrency operations won&#x27;t directly
work in always-async contexts. But we have a way out of this we talk about later
in the post: &lt;code&gt;if is_async() .. else ..&lt;/code&gt;. This allows you to branch the body of a
&lt;code&gt;?async fn&lt;/code&gt; based on which mode it&#x27;s being compiled in, and will allow you to
write different logic for async and non-async modes. This means you can choose
to use async concurrency in the async version, but keep things sequential in the
non-async version. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Yoshua Wuyts</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance Reform RFC Announcement</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/02/22/governance-reform-rfc.html" type="text/html" title="Governance Reform RFC Announcement" />
        <published>2023-02-22T00:00:00+00:00</published>
        <updated>2023-02-22T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/02/22/governance-reform-rfc.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/02/22/governance-reform-rfc.html">&lt;p&gt;As part of &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/10/06/governance-update.html&quot;&gt;ongoing work on governance&lt;/a&gt;, the &amp;quot;leadership chat&amp;quot; established a smaller &amp;quot;governance reform&amp;quot; working group to create an RFC to establish new project wide governance. This RFC is now live and can found on the RFCs repo: &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3392&quot;&gt;https://github.com/rust-lang/rfcs/pull/3392&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We have set up a &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/369838-rfc-leadership-council-feedback&quot;&gt;Zulip stream&lt;/a&gt; to provide an additional dedicated place for feedback on the RFC. In addition, team leads will be asking their respective teams for feedback directly. However, anyone is welcome to participate and provide feedback directly in the Zulip stream or the RFC PR if they prefer.&lt;/p&gt;
&lt;p&gt;Again, if you have any questions or concerns, please don&#x27;t hesitate to reach out.&lt;/p&gt;
</content>

        <author>
            <name>Jane Losare-Lusby and the Governance Reform WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Welcome Tyler Mandry to the Rust language team!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/02/14/lang-team-membership-update.html" type="text/html" title="Welcome Tyler Mandry to the Rust language team!" />
        <published>2023-02-14T00:00:00+00:00</published>
        <updated>2023-02-14T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/02/14/lang-team-membership-update.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/02/14/lang-team-membership-update.html">&lt;p&gt;We are happy to announce that &lt;a href&#x3D;&quot;https://github.com/tmandry&quot;&gt;Tyler Mandry&lt;/a&gt; is joining the Rust language design team as a full member!&lt;/p&gt;
&lt;p&gt;Tyler has been driving the design of async functions in traits over the last year. In that process Tyler has authored two RFCs, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3185&quot;&gt;#3185 (static async functions in traits)&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3245&quot;&gt;#3245 (refined trait impls)&lt;/a&gt;, both of which were accepted. He has good instincts for language design and orthogonality, devising general solutions to address a range of use cases with a small set of language changes, such as &lt;a href&#x3D;&quot;https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/&quot;&gt;contexts/capabilities&lt;/a&gt; and &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2022/03/29/dyn-can-we-make-dyn-sized/&quot;&gt;&lt;code&gt;dyn*&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Tyler is also a strong implementor. He was a past contributor to the chalk project and understands the intricacies of the trait and type system quite well. He also implemented a number of improvements to async Rust, such as work to reduce the size of futures.&lt;/p&gt;
&lt;p&gt;Throughout his work on Rust, Tyler has demonstrated his ability to drive discussions towards consensus on a number of occasions. For example, he helped to navigate questions around boxing and auto-traits. He always makes an effort to understand people&#x27;s points, even when he disagrees with their conclusions.&lt;/p&gt;
&lt;p&gt;Welcome to the team, Tyler!&lt;/p&gt;
</content>

        <author>
            <name>Josh Triplett, Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Language team advisors</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/02/14/lang-advisors.html" type="text/html" title="Language team advisors" />
        <published>2023-02-14T00:00:00+00:00</published>
        <updated>2023-02-14T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/02/14/lang-advisors.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/02/14/lang-advisors.html">&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3327&quot;&gt;RFC #3327&lt;/a&gt; created a new lang-team subteam, the lang team advisors. The advisors team recognizes people who regularly aid the Rust community and the lang team in particular in language design decisions. We already value their input highly and treat their concerns as blocking on features or proposals. The advisors team gives us a way to acknowledge them officially.&lt;/p&gt;
&lt;p&gt;The initial advisors team consists of the following people:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ralf Jung&lt;/strong&gt; is a leader in designing Rust&#x27;s rules for unsafe code as well as, through his work on miri, the semantics of compile-time evaluation. His work on stacked borrows and minirust has moved the state of that conversation forward in major ways, and he has also driven a number of language changes related to that area.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jakob Degen&lt;/strong&gt; is one of the authorities around the semantics of unsafe code. He has consistently shown the ability to aggregate opinion, identify the key constraints to respect and those to disregard, and find consensus solutions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mark Rousskov&lt;/strong&gt; has been a huge part of the Rust community for many years now, and participates regularly in lang-team meetings. He has a wide knowledge of Rust and its nooks and crannies, and often brings key insights to our discussions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jack Huey&lt;/strong&gt; co-leads the types team, and provides expertise in the workings of Rust&#x27;s trait and type system, as well as the chalk system.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Amanieu d&#x27;Antras&lt;/strong&gt; leads the design of inline assembly and has been involved as an expert in a number of other areas, such as the &amp;quot;FFI unwind&amp;quot; working group.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wesley Wiser&lt;/strong&gt; is the co-lead of the compiler team. He&#x27;s been involved in the project for many years and is an expert on the overall compiler architecture as well as several areas within.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Alex Crichton&lt;/strong&gt; is a well-known figure to many Rustaceans. Among other things, he is a former lead of the libs team, a key cargo contributor, and drove extensive work for Rust in WebAssembly. Indeed, it&#x27;s hard to find a part of Rust that Alex hasn&#x27;t had an impact on.&lt;/p&gt;
&lt;p&gt;Finally, as part of this change, &lt;strong&gt;Taylor Cramer&lt;/strong&gt; will be stepping back as a full-time lang team member and becoming an advisor. In his time on the lang team, Taylor was a core driver for &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;, &lt;code&gt;impl Trait&lt;/code&gt;, and a number of other highly impactful language features. We look forward to continuing to have his guidance as an advisor going forward.&lt;/p&gt;
</content>

        <author>
            <name>Josh Triplett, Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Compiler February 2023 Steering Cycle</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2023/02/10/compiler-team-feb-steering-cycle.html" type="text/html" title="Rust Compiler February 2023 Steering Cycle" />
        <published>2023-02-10T00:00:00+00:00</published>
        <updated>2023-02-10T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2023/02/10/compiler-team-feb-steering-cycle.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2023/02/10/compiler-team-feb-steering-cycle.html">&lt;p&gt;On &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bplanning.20meeting.5D.202023-02-10/near/327073587&quot;&gt;Friday, February 10th&lt;/a&gt;, the Rust Compiler team had a planning meeting for the February 2023 steering cycle.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#t-compiler-june-steering-schedule&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;t-compiler-june-steering-schedule&quot;&gt;&lt;/a&gt;T-compiler June Steering Schedule&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Meeting Id&lt;/th&gt;
&lt;th&gt;Meeting Topic&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/calendar/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;Nzk5YW5ybjZhZHI5c243cjllZmdhc2RkMG8gNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2023-02-17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/589&quot;&gt;compiler-team#589&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Dealing with PR review latency&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/calendar/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;MDFpY2NtNmFxbWZ1Y2tpN3Fka2Vqa251YWkgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2023-02-24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/583&quot;&gt;compiler-team#583&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Scope and goals of rust-lang/rust optimizations&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/calendar/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;MDk5ZDhtMjAzcmt2ZDlmMmR0ZWE0cXB2ZjUgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2023-03-03&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/590&quot;&gt;compiler-team#590&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;P-high review for 2023 Q1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/calendar/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;MDJyYnJ1cGFtdWR1c2lnNjFmcHJ2b3JlODFfMjAyMzAzMTBUMTUwMDAwWiA2dTVycnRjZTZscnR2MDdwZmkzZGFtZ2p1c0Bn&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2023-03-10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;(planning for March cycle)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#details&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;details&quot;&gt;&lt;/a&gt;Details&lt;/h3&gt;
&lt;p&gt;Every fourth Friday, the Rust compiler team decides how
it is going to use its scheduled steering and design meeting time over the next
three Fridays.&lt;/p&gt;
&lt;p&gt;On Friday, 17 February, we will discuss ways to improve our Pull Request review
latency. Jack Huey, apiraino, and oli-obk will work on a document to drive the
meeting, collecting ideas on how to attack the problem.&lt;/p&gt;
&lt;p&gt;On Friday, 24 February, we will discuss our philosophy about code optimizations
that are implemented in the rust-lang/rust repository (as opposed to
optimizations that are implemented in LLVM itself, which is where the bulk of
our optimization logic currently resides). Jak{e,ob} Degen will author the
document driving this meeting.&lt;/p&gt;
&lt;p&gt;On Friday, 3 March, we will do a quarterly &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/590&quot;&gt;review of the open P-high issues&lt;/a&gt;.
pnkfelix will do some ahead of time work &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/reviewing.20P-high.20issues.202022.20.28Q3.29/near/300390068&quot;&gt;in zulip&lt;/a&gt;
triaging
some of the issues, and potentially prepare a meeting document summarizing the
remainder, to maximize the quality of our synchronous in-meeting time.&lt;/p&gt;
&lt;p&gt;On Friday, 10 March, we will hold our planning meeting for the next steering
cycle in March and April.&lt;/p&gt;
&lt;p&gt;Each meeting will run from 2pm to 3pm GMT, and will take place on the
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings&quot;&gt;T-compiler/meetings zulip stream&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2022-07-28T07:57:01+00:00</updated>

    
    <entry>
        <title>Announcing the Keyword Generics Initiative</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html" type="text/html" title="Announcing the Keyword Generics Initiative" />
        <published>2022-07-27T00:00:00+00:00</published>
        <updated>2022-07-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/07/27/keyword-generics.html">&lt;p&gt;We (&lt;a href&#x3D;&quot;https://github.com/oli-obk&quot;&gt;Oli&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/nikomatsakis&quot;&gt;Niko&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/yoshuawuyts&quot;&gt;Yosh&lt;/a&gt;) are excited to announce the start of the &lt;a href&#x3D;&quot;https://github.com/rust-lang/keyword-generics-initiative&quot;&gt;Keyword
Generics Initiative&lt;/a&gt;, a new initiative &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; under the purview of
the language team. We&#x27;re officially just a few weeks old now, and in this post
we want to briefly share why we&#x27;ve started this initiative, and share some
insight on what we&#x27;re about.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-missing-kind-of-generic&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-missing-kind-of-generic&quot;&gt;&lt;/a&gt;A missing kind of generic&lt;/h2&gt;
&lt;p&gt;One of Rust&#x27;s defining features is the ability to write functions which are
&lt;em&gt;generic&lt;/em&gt; over their input types. That allows us to write a function once,
leaving it up to the compiler to generate the right implementations for us.&lt;/p&gt;
&lt;p&gt;Rust allows you to be generic over types - it does not allow you to be generic
over other things that are usually specified by keywords. For example, whether a
function is async, whether a function can fail or not, whether a function is
const or not, etc.&lt;/p&gt;
&lt;p&gt;The post &lt;a href&#x3D;&quot;https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/&quot;&gt;&amp;quot;What color is your function&amp;quot;&lt;/a&gt; &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; describes what happens
when a language introduces async functions, but with no way to be generic over
them:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I will take async-await over bare callbacks or futures any day of the week.
But we’re lying to ourselves if we think all of our troubles are gone. As soon
as you start trying to write higher-order functions, or reuse code, you’re
right back to realizing color is still there, bleeding all over your codebase.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This isn&#x27;t just limited to async though, it applies to all modifier keywords -
including ones we may define in the future. So we&#x27;re looking to fill that gap
by exploring something we call &amp;quot;keyword generics&amp;quot; &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn3&quot; id&#x3D;&quot;fnref3&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;: the ability to be
generic over keywords such as &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To give you a quick taste of what we&#x27;re working on, this is roughly how we
imagine you may be able to write a function which is generic over &amp;quot;asyncness&amp;quot;
in the future:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Please note that this syntax is entirely made up, just so we can use something
in examples. Before we can work on syntax we need to finalize the semantics,
and we&#x27;re not there yet. This means the syntax will likely be subject to
change over time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;async&amp;lt;A&amp;gt; trait Read {
    async&amp;lt;A&amp;gt; fn read(&amp;amp;mut self, buf: &amp;amp;mut [u8]) -&amp;gt; Result&amp;lt;usize&amp;gt;;
    async&amp;lt;A&amp;gt; fn read_to_string(&amp;amp;mut self, buf: &amp;amp;mut String) -&amp;gt; Result&amp;lt;usize&amp;gt; { ... }
}

/// Read from a reader into a string.
async&amp;lt;A&amp;gt; fn read_to_string(reader: &amp;amp;mut impl Read * A) -&amp;gt; std::io::Result&amp;lt;String&amp;gt; {
    let mut string &#x3D; String::new();
    reader.read_to_string(&amp;amp;mut string).await?;
    string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function introduces a &amp;quot;keyword generic&amp;quot; parameter into the function of &lt;code&gt;A&lt;/code&gt;.
You can think of this as a flag which indicates whether the function is being
compiled in an async context or not. The parameter &lt;code&gt;A&lt;/code&gt; is forwarded to the &lt;code&gt;impl Read&lt;/code&gt;, making that conditional on &amp;quot;asyncness&amp;quot; as well.&lt;/p&gt;
&lt;p&gt;In the function body you can see a &lt;code&gt;.await&lt;/code&gt; call. Because &lt;a href&#x3D;&quot;https://blog.yoshuawuyts.com/async-cancellation-1/&quot;&gt;the &lt;code&gt;.await&lt;/code&gt; keyword
marks cancellation sites&lt;/a&gt; we unfortunately can&#x27;t just infer them
&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn4&quot; id&#x3D;&quot;fnref4&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;. Instead we require them to be written for when the code is
compiled in async mode, but are essentially reduced to a no-op in non-async
mode.&lt;/p&gt;
&lt;p&gt;We still have lots of details left to figure out, but we hope this at least
shows the general &lt;em&gt;feel&lt;/em&gt; of what we&#x27;re going for.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-peek-at-the-past-horrors-before-const&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-peek-at-the-past-horrors-before-const&quot;&gt;&lt;/a&gt;A peek at the past: horrors before const&lt;/h2&gt;
&lt;p&gt;Rust didn&#x27;t always have &lt;code&gt;const fn&lt;/code&gt; as part of the language. A long long long long
long time ago (2018) we had to write a regular function for runtime computations
and associated const of generic type logic for compile-time computations. As an
example, to add the number &lt;code&gt;1&lt;/code&gt; to a constant provided to you, you had to write
(&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;50e818b79b8af322ed4384d3c33e9773&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Const&amp;lt;T&amp;gt; {
    const VAL: T;
}

/// &#x60;42&#x60; as a &amp;quot;const&amp;quot; (type) generic:
struct FourtyTwo;
impl Const&amp;lt;i32&amp;gt; for FourtyTwo {
    const VAL: i32 &#x3D; 42;
}

/// &#x60;C&#x60; -&amp;gt; &#x60;C + 1&#x60; operation:
struct AddOne&amp;lt;C: Const&amp;lt;i32&amp;gt;&amp;gt;(C);
impl&amp;lt;C: Const&amp;lt;i32&amp;gt;&amp;gt; Const&amp;lt;i32&amp;gt; for AddOne&amp;lt;C&amp;gt; {
    const VAL: i32 &#x3D; C::VAL + 1;
}

AddOne::&amp;lt;FourtyTwo&amp;gt;::VAL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Today this is as easy as writing a &lt;code&gt;const fn&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;const fn add_one(i: i32) -&amp;gt; i32 {
    i + 1
}

add_one(42)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The interesting part here is that you can also just call this function in
runtime code, which means the implementation is shared between both &lt;code&gt;const&lt;/code&gt;
(CTFE&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn5&quot; id&#x3D;&quot;fnref5&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;) and non-&lt;code&gt;const&lt;/code&gt; (runtime) contexts.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#memories-of-the-present-async-today&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;memories-of-the-present-async-today&quot;&gt;&lt;/a&gt;Memories of the present: async today&lt;/h2&gt;
&lt;p&gt;People write duplicate code for async/non-async with the only difference being
the &lt;code&gt;async&lt;/code&gt; keyword. A good example of that code today is &lt;a href&#x3D;&quot;https://docs.rs/async-std/latest/async_std/&quot;&gt;&lt;code&gt;async-std&lt;/code&gt;&lt;/a&gt;, which
duplicates and translates a large part of the stdlib&#x27;s API surface to be async
&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn6&quot; id&#x3D;&quot;fnref6&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;. And because the Async WG has made it an explicit goal to &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async/vision/how_it_feels.html&quot;&gt;bring
async Rust up to par with non-async Rust&lt;/a&gt;, the issue of code
duplication is particularly relevant for the Async WG as well. Nobody on the
Async WG seems particularly keen on proposing we add a second instance of just
about every API currently in the stdlib.&lt;/p&gt;
&lt;p&gt;We&#x27;re in a similar situation with &lt;code&gt;async&lt;/code&gt; today as &lt;code&gt;const&lt;/code&gt; was prior to 2018.
Duplicating entire interfaces and wrapping them in &lt;code&gt;block_on&lt;/code&gt; calls is the
approach taken by e.g. the &lt;code&gt;mongodb&lt;/code&gt;
[&lt;a href&#x3D;&quot;https://docs.rs/mongodb/latest/mongodb/index.html&quot;&gt;async&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://docs.rs/mongodb/latest/mongodb/sync/index.html&quot;&gt;non-async&lt;/a&gt;], &lt;code&gt;postgres&lt;/code&gt;
[&lt;a href&#x3D;&quot;https://docs.rs/tokio-postgres/latest/tokio_postgres/index.html&quot;&gt;async&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://docs.rs/postgres/latest/postgres/&quot;&gt;non-async&lt;/a&gt;], and &lt;code&gt;reqwest&lt;/code&gt;
[&lt;a href&#x3D;&quot;https://docs.rs/reqwest/latest/reqwest/&quot;&gt;async&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://docs.rs/reqwest/latest/reqwest/blocking/index.html&quot;&gt;non-async&lt;/a&gt;] crates:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// Async functionality like this would typically be exposed from a crate &amp;quot;foo&amp;quot;:
async fn bar() -&amp;gt; Bar { 
    // async implementation goes here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// And a sync counterpart would typically be exposed from a crate
// named &amp;quot;blocking_foo&amp;quot; or a submodule on the original crate as
// &amp;quot;foo::blocking&amp;quot;. This wraps the async code in a &#x60;block_on&#x60; call:
fn bar() -&amp;gt; Bar {
    futures::executor::block_on(foo::bar())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This situation is not ideal. Instead of using the host&#x27;s synchronous syscalls,
we&#x27;re now going through an async runtime to get the same results - something
which is often not zero-cost. But more importantly, it&#x27;s rather hard to
keep both a sync and async API version of the same crate in, err, sync with each
other. Without automation it&#x27;s really easy for the two APIs to get out of sync,
leading to mismatched functionality.&lt;/p&gt;
&lt;p&gt;The ecosystem has come up with some solutions to this, perhaps most notably the
proc-macro based &lt;a href&#x3D;&quot;https://docs.rs/maybe-async/0.2.6/maybe_async/&quot;&gt;&lt;code&gt;maybe-async&lt;/code&gt; crate&lt;/a&gt;.  Instead of writing two
separate copies of &lt;code&gt;foo&lt;/code&gt;, it generates a sync and async variant for you:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[maybe_async]
async fn foo() -&amp;gt; Bar { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While being useful, the macro has clear limitations with respect to diagnostics
and ergonomics. That&#x27;s absolutely not an issue with the crate, but an inherent
property of the problem it&#x27;s trying to solve. Implementing a way to be generic
over the &lt;code&gt;async&lt;/code&gt; keyword is something which will affect the language in many
ways, and a type system + compiler will be better equipped to handle it than
proc macros reasonably can.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-taste-of-trouble-the-sandwich-problem&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-taste-of-trouble-the-sandwich-problem&quot;&gt;&lt;/a&gt;A taste of trouble: the sandwich problem&lt;/h2&gt;
&lt;p&gt;A pervasive issue in existing Rust is the &lt;em&gt;sandwich&lt;/em&gt; problem. It occurs when a
type passed into an operation wants to perform control flow not supported by the
type it&#x27;s passed into. Thus creating a &lt;em&gt;sandwich&lt;/em&gt; &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn7&quot; id&#x3D;&quot;fnref7&quot;&gt;7&lt;/a&gt;&lt;/sup&gt; The classic example
is a &lt;code&gt;map&lt;/code&gt; operation:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;enum Option&amp;lt;T&amp;gt; {
    Some(T),
    None,
}

impl&amp;lt;T&amp;gt; Option&amp;lt;T&amp;gt; {
    fn map&amp;lt;J&amp;gt;(self, f: impl FnOnce(T) -&amp;gt; J) -&amp;gt; Option&amp;lt;J&amp;gt; { ... }
}

my_option.map(|x| x.await)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will produce a compiler error: the closure &lt;code&gt;f&lt;/code&gt; is not an async context, so
&lt;code&gt;.await&lt;/code&gt; cannot be used within it. And we can&#x27;t just convert the closure to be
&lt;code&gt;async&lt;/code&gt; either, since &lt;code&gt;fn map&lt;/code&gt; doesn&#x27;t know how to call async functions. In
order to solve this issue, we could provide a new &lt;code&gt;async_map&lt;/code&gt; method which
&lt;em&gt;does&lt;/em&gt; provide an async closure. But we may want to repeat those for more
effects, and that would result in a combinatorial explosion of effects. Take for
example &amp;quot;can fail&amp;quot; and &amp;quot;can be async&amp;quot;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;not async&lt;/th&gt;
&lt;th&gt;async&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;infallible&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fn map&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fn async_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;fallible&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fn try_map&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;fn async_try_map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;That&#x27;s a lot of API surface for just a single method, and &lt;strong&gt;that problem
multiplies across the entire API surface in the stdlib&lt;/strong&gt;. We expect that once we
start applying &amp;quot;keyword generics&amp;quot; to traits, we will be able to solve the
sandwich problem. The type &lt;code&gt;f&lt;/code&gt; would be marked generic over a set of effects,
and the compiler would choose the right variant during compilation.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affecting-all-effects&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affecting-all-effects&quot;&gt;&lt;/a&gt;Affecting all effects&lt;/h2&gt;
&lt;p&gt;Both &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;async&lt;/code&gt; share a very similar issue, and we expect that other
&amp;quot;effects&amp;quot; will face the same issue. &amp;quot;fallibility&amp;quot; is particularly on our mind here,
but it isn&#x27;t the only effect. In order for the language to feel consistent we
need consistent solutions.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#faq&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;faq&quot;&gt;&lt;/a&gt;FAQ&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#q-is-there-an-rfc-available-to-read&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;q-is-there-an-rfc-available-to-read&quot;&gt;&lt;/a&gt;Q: Is there an RFC available to read?&lt;/h3&gt;
&lt;p&gt;Rust initiatives are intended for &lt;em&gt;exploration&lt;/em&gt;. The announcement of the Keyword
Generics Initiative marks the &lt;em&gt;start&lt;/em&gt; of the exploration process. Part of
exploring is not knowing what the outcomes will be. Right now we&#x27;re in the
&amp;quot;pre-RFC&amp;quot; phase of design. What we hope we&#x27;ll achieve is to enumerate the
full problem space, design space, find a balanced solution, and eventually
summarize that in the form of an RFC. Then after the RFC is accepted: implement
it on nightly, work out the kinks, and eventually move to stabilize.  But we may
at any point during this process conclude that this initiative is actually
infeasible and start ramping down.&lt;/p&gt;
&lt;p&gt;But while we can&#x27;t make any &lt;em&gt;assurances&lt;/em&gt; about the outcome of the initiative,
what we can share is that we&#x27;re pretty optimistic about the initiative overall.
We wouldn&#x27;t be investing the time we are on this if we didn&#x27;t think we&#x27;d be
actually be able to see it through to completion.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#q-will-this-make-the-language-more-complicated&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;q-will-this-make-the-language-more-complicated&quot;&gt;&lt;/a&gt;Q: Will this make the language more complicated?&lt;/h3&gt;
&lt;p&gt;The goal of keyword generics is not to minimize the complexity of the Rust
programming language, but to &lt;em&gt;minimize the complexity of programming in Rust.&lt;/em&gt;
These two might sound similar, but they&#x27;re not. Our reasoning here is that by
&lt;em&gt;adding&lt;/em&gt; a feature, we will actually be able to significantly reduce the surface
area of the stdlib, crates.io libraries, and user code - leading to a more
streamlined user experience.&lt;/p&gt;
&lt;p&gt;Choosing between sync or async code is a fundamental choice which needs to be
made. This is complexity which cannot be avoided, and which needs to exist
somewhere. Currently in Rust that complexity is thrust entirely on users of
Rust, making them responsible for choosing whether their code should support
async Rust or not. But other languages have made diferent choices. For example
Go doesn&#x27;t distinguish between &amp;quot;sync&amp;quot; and &amp;quot;async&amp;quot; code, and has a runtime which
is able to remove that distinction.&lt;/p&gt;
&lt;p&gt;In today&#x27;s Rust application authors choose whether their application will be sync
or async, and even after the introduction of keyword generics we don&#x27;t really
expect that to change. All generics eventually need to have their types known,
and keyword generics are no different. What we&#x27;re targeting is the choice made
by &lt;em&gt;library&lt;/em&gt; authors whether their library supports is sync or async. With
keyword generics library authors will be able to support both with the help of
the compiler, and leave it up to application authors to decide how they want to
compile their code.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#q-are-you-building-an-effect-system&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;q-are-you-building-an-effect-system&quot;&gt;&lt;/a&gt;Q: Are you building an effect system?&lt;/h3&gt;
&lt;p&gt;The short answer is: kind of, but not really. &amp;quot;Effect systems&amp;quot; or &amp;quot;algebraic
effect systems&amp;quot; generally have a lot of surface area. A common example of what
effects allow you to do is implement your own &lt;code&gt;try/catch&lt;/code&gt; mechanism. What we&#x27;re
working on is intentionally limited to built-in keywords only, and wouldn&#x27;t
allow you to implement anything like that at all.&lt;/p&gt;
&lt;p&gt;What we do share with effect systems is that we&#x27;re integrating modifier keywords
more directly into the type system. Modifier keywords like &lt;code&gt;async&lt;/code&gt; are often
referred to as &amp;quot;effects&amp;quot;, so being able to be conditional over them in
composable ways effectively gives us an &amp;quot;effect algebra&amp;quot;. But that&#x27;s very
different from &amp;quot;generalized effect systems&amp;quot; in other languages.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#q-are-you-looking-at-other-keywords-beyond-async-and-const&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;q-are-you-looking-at-other-keywords-beyond-async-and-const&quot;&gt;&lt;/a&gt;Q: Are you looking at other keywords beyond &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;?&lt;/h3&gt;
&lt;p&gt;For a while we were referring to the initiative as &amp;quot;modifier generics&amp;quot; or
&amp;quot;modifier keyword generics&amp;quot;, but it never really stuck. We&#x27;re only really
interested in keywords which modify how types work. Right now this is &lt;code&gt;const&lt;/code&gt;
and &lt;code&gt;async&lt;/code&gt; because that&#x27;s what&#x27;s most relevant for the const-generics WG and
async WG. But we&#x27;re designing the feature with other keywords in mind as well.&lt;/p&gt;
&lt;p&gt;The one most at the top of our mind is a future keyword for fallibility. There
is talk about introducing &lt;code&gt;try fn() {}&lt;/code&gt; or &lt;code&gt;fn () -&amp;gt; throws&lt;/code&gt; syntax. This could
make it so methods such as &lt;code&gt;Iterator::filter&lt;/code&gt; would be able to use &lt;code&gt;?&lt;/code&gt; to break
out of the closure and short-circuit iteration.&lt;/p&gt;
&lt;p&gt;Our main motivation for this feature is that without it, it&#x27;s easy for Rust to
start to feel &lt;em&gt;disjointed&lt;/em&gt;. We sometimes joke that Rust is actually 3-5
languages in a trenchcoat. Between const rust, fallible rust, async rust, unsafe
rust - it can be easy for common APIs to only be available in one variant of the
language, but not in others. We hope that with this feature we can start to
systematically close those gaps, leading to a more consistent Rust experience
for &lt;em&gt;all&lt;/em&gt; Rust users.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#q-what-will-the-backwards-compatibility-story-be-like&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;q-what-will-the-backwards-compatibility-story-be-like&quot;&gt;&lt;/a&gt;Q: What will the backwards compatibility story be like?&lt;/h3&gt;
&lt;p&gt;Rust has pretty strict backwards-compatibility guarantees, and any feature we
implement needs to adhere to this. Luckily we have some wiggle room because of
the edition mechanism, but our goal is to shoot for maximal backwards compat. We
have some ideas of how we&#x27;re going to make this work though, and we&#x27;re
cautiously optimistic we might actually be able to pull this off.&lt;/p&gt;
&lt;p&gt;But to be frank: this is by far one of the hardest aspects of this feature, and
we&#x27;re lucky that we&#x27;re not designing any of this just by ourselves, but have the
support of the language team as well.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#q-arent-implementations-sometimes-fundamentally-different&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;q-arent-implementations-sometimes-fundamentally-different&quot;&gt;&lt;/a&gt;Q: Aren&#x27;t implementations sometimes fundamentally different?&lt;/h3&gt;
&lt;p&gt;Const Rust can&#x27;t make any assumptions about the host it runs on, so it can&#x27;t do
anything platform-specific. This includes using more efficient instructions of
system calls which are only available in one platform but not another. In order
to work around this, the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/intrinsics/fn.const_eval_select.html&quot;&gt;&lt;code&gt;const_eval_select&lt;/code&gt;&lt;/a&gt; intrinsic in the standard
library enables &lt;code&gt;const&lt;/code&gt; code to detect whether it&#x27;s executing during CTFE or
runtime, and execute different code based on that.&lt;/p&gt;
&lt;p&gt;For async we expect to be able to add a similar intrinsic, allowing library
authors to detect whether code is being compiled as sync or async, and do
something different based on that. This includes: using internal concurrency, or
switching to a different set of system calls. We&#x27;re not sure whether an
intrinsic is the right choice for this though; we may want to provide a more
ergonomic API for this instead. But because keyword generics is being designed
as a consistent feature, we expect that whatever we end up going with can be used
consistently by &lt;em&gt;all&lt;/em&gt; modifier keywords.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this post we&#x27;ve introduced the new keyword generics initiatve, explained why
it exists, and shown a brief example of what it might look like in the future.&lt;/p&gt;
&lt;p&gt;The initiative is active on the Rust Zulip under
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/328082-t-lang.2Fkeyword-generics&quot;&gt;&lt;code&gt;t-lang/keyword-generics&lt;/code&gt;&lt;/a&gt; - if this seems interesting to you, please
pop by!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Thanks to everyone who&#x27;s helped review this post, but in particular:
&lt;a href&#x3D;&quot;https://github.com/fee1-dead&quot;&gt;fee1-dead&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/danielhenrymantilla&quot;&gt;Daniel Henry-Mantilla&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/rylev&quot;&gt;Ryan Levick&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;Rust governance terminology can sometimes get confusing. An
&amp;quot;initiative&amp;quot; in Rust parlance is different from a &amp;quot;working group&amp;quot; or &amp;quot;team&amp;quot;.
Initiatives are intentionally limited: they exist to explore, design, and
implement specific pieces of work - and once that work comes to a close, the
initiative will wind back down. This is different from, say, the lang team -
which essentially carries a &lt;code&gt;&#x27;static&lt;/code&gt; lifetime - and whose work does
not have a clearly defined end. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;R. Nystrom, “What Color is Your Function?,” Feb. 01, 2015.
https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/
(accessed Apr. 06, 2022). &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn3&quot;&gt;
&lt;p&gt;The longer, more specific name would be: &amp;quot;keyword modifier generics&amp;quot;.
We&#x27;ve tried calling it that, but it&#x27;s a bit of a mouthful. So we&#x27;re just
sticking with &amp;quot;keyword generics&amp;quot; for now, even if the name for this feature may
end up being called something more specific in the reference and documentation. &lt;a href&#x3D;&quot;#fnref3&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn4&quot;&gt;
&lt;p&gt;No really, we can&#x27;t just infer them - and it may not be as
simple as omitting all &lt;code&gt;.await&lt;/code&gt; calls either. The Async WG is working through
the full spectrum of cancellation sites, async drop, and more. But for now we&#x27;re
working under the assumption that &lt;code&gt;.await&lt;/code&gt; will remain relevant going forward.
And even in the off chance that it isn&#x27;t, fallibility has similar requirements
at the call site as async does. &lt;a href&#x3D;&quot;#fnref4&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn5&quot;&gt;
&lt;p&gt;CTFE stands for &amp;quot;Compile Time Function Execution&amp;quot;: &lt;code&gt;const&lt;/code&gt; functions
can be evaluated during compilation, which is implemented using a Rust
interpreter (miri). &lt;a href&#x3D;&quot;#fnref5&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn6&quot;&gt;
&lt;p&gt;Some limitations in &lt;code&gt;async-std&lt;/code&gt; apply: async Rust is missing async
&lt;code&gt;Drop&lt;/code&gt;, async traits, and async closures. So not all APIs could be duplicated.
Also &lt;code&gt;async-std&lt;/code&gt; explicitly didn&#x27;t reimplement any of the collection APIs to be
async-aware, which means users are subject to the &amp;quot;sandwich problem&amp;quot;. The
purpose of &lt;code&gt;async-std&lt;/code&gt; was to be a proving ground to test whether creating
an async mirror of the stdlib would be possible: and it&#x27;s proven that it is, as
far as was possible with missing language features. &lt;a href&#x3D;&quot;#fnref6&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn7&quot;&gt;
&lt;p&gt;Not to be confused with the higher-order &lt;em&gt;sandwich dilemma&lt;/em&gt; which is
when you look at the sandwich problem and attempt to determine whether the
sandwich is two slices of bread with a topping in between, or two toppings with
a slice of bread in between. Imo the operation part of the problem feels more
&lt;em&gt;bready&lt;/em&gt;, but that would make for a weird-looking sandwich. Ergo: sandwich
dilemma. (yes, you can ignore all of this.) &lt;a href&#x3D;&quot;#fnref7&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Yoshua Wuyts</name>
        </author>
    </entry>
    
    <entry>
        <title>1.62.1 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/07/16/1.62.1-prerelease.html" type="text/html" title="1.62.1 pre-release testing" />
        <published>2022-07-16T00:00:00+00:00</published>
        <updated>2022-07-16T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/07/16/1.62.1-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/07/16/1.62.1-prerelease.html">&lt;p&gt;The 1.62.1 pre-release is ready for testing. The release is scheduled for
July 19. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1621-2022-07-19&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2022-07-16/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2022-07-16/index.html&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-62-1-pre-release-testing/17023&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Release automation</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes at the Clippy Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/07/13/clippy-team-changes.html" type="text/html" title="Changes at the Clippy Team" />
        <published>2022-07-13T00:00:00+00:00</published>
        <updated>2022-07-13T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/07/13/clippy-team-changes.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/07/13/clippy-team-changes.html">&lt;h2&gt;&lt;a href&#x3D;&quot;#new-members&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;new-members&quot;&gt;&lt;/a&gt;New Members&lt;/h2&gt;
&lt;p&gt;We are thrilled to publicly announce that &lt;a href&#x3D;&quot;https://github.com/Alexendoo&quot;&gt;Alex
Macleod&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/dswij&quot;&gt;dswij&lt;/a&gt;, and
&lt;a href&#x3D;&quot;https://github.com/Jarcho&quot;&gt;Jason Newcomb&lt;/a&gt; have joined the Clippy Team!&lt;/p&gt;
&lt;p&gt;Jason has been contributing to Clippy since late 2020 and was the most active
contributor since then. He has contributed in pretty much every area - big
refactors, bug fixes, and major improvements to our Clippy utils. Having him as
an additional reviewer will be a great improvement to the team.&lt;/p&gt;
&lt;p&gt;dswij first started contributing late last summer and has fixed many bugs in
Clippy as well as implementing some new lints to make Clippy even more helpful.
With their continued contributions to Clippy and engagement in the project,
we&#x27;re happy to now have them as a full team member.&lt;/p&gt;
&lt;p&gt;Alex started contributing to Clippy shortly after and has improved our dev
tooling quite a bit. Now he wants to continue focusing on our &lt;code&gt;lintcheck&lt;/code&gt; tool,
which will help detect false positives in new lints before we release them to
the public. We&#x27;re excited to have Alex on our team and looking forward to all
the improvements he will bring in the future.&lt;/p&gt;
&lt;p&gt;With the new additions to the team, we should be able to handle our long PR
queue better. We currently have over 40 open PRs, which is a good sign for the
health of the project, but doesn&#x27;t help when we don&#x27;t have the reviewers to
merge them. Now we do!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#alumni&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;alumni&quot;&gt;&lt;/a&gt;Alumni&lt;/h2&gt;
&lt;p&gt;At the same time, we recently granted some of our oldest members the
well-deserved alumni status. We want to thank &lt;a href&#x3D;&quot;https://github.com/killercup&quot;&gt;Pascal
Hertleif&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/mcarton&quot;&gt;Martin
Carton&lt;/a&gt; for all their contributions, especially in
the early days. People joining today probably never worked with them on Clippy,
but without them, we probably wouldn&#x27;t be here.&lt;/p&gt;
&lt;p&gt;We also want to thank &lt;a href&#x3D;&quot;https://github.com/phansch&quot;&gt;Philipp Hansch&lt;/a&gt; for their
contributions to Clippy and all of the review work they&#x27;ve done over the years.
To this day phansch is one of the most active Clippy contributors (measured by
the number of commits).&lt;/p&gt;
&lt;p&gt;And finally, thank you to &lt;a href&#x3D;&quot;https://github.com/mikerite&quot;&gt;mikerite&lt;/a&gt;, who stepped
down from an active reviewer/team member position but will be staying on as a
contributor. We&#x27;re looking forward to continue working with them!&lt;/p&gt;
</content>

        <author>
            <name>Philipp Krones</name>
        </author>
    </entry>
    
    <entry>
        <title>1.62.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/06/28/1.62.0-prerelease.html" type="text/html" title="1.62.0 pre-release testing" />
        <published>2022-06-28T00:00:00+00:00</published>
        <updated>2022-06-28T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/06/28/1.62.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/06/28/1.62.0-prerelease.html">&lt;p&gt;The 1.62.0 pre-release is ready for testing. The release is scheduled for this
Thursday, June 30th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1620-2022-06-30&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2022-06-27/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2022-06-27/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-62-0-prerelease-testing/16913&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>2021 Annual Survey Report</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/06/21/survey-2021-report.html" type="text/html" title="2021 Annual Survey Report" />
        <published>2022-06-21T00:00:00+00:00</published>
        <updated>2022-06-21T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/06/21/survey-2021-report.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/06/21/survey-2021-report.html">&lt;p&gt;As usual, we conducted an annual community survey in 2021. We previously shared some some highlights and charts
in a &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html&quot;&gt;blog post&lt;/a&gt;. This year we would also like to
make the complete (-ish) dataset available. We have compiled a report which contains data and charts for nearly
all questions with minimal analysis. We have elided a few sensitive questions and have combined some answers
or elided some answers where there is any chance of respondents being identified or of sensitive data being released.&lt;/p&gt;
&lt;p&gt;We intend to produce further small reports with more analysis targetted at specific teams or groups within the
project. If there is any analysis or processed data you&#x27;d like to see, please get in touch with the survey working group via
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/294169-t-community.2Frust-survey-2021&quot;&gt;Zulip&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once again, we&#x27;d like to thank all the respondents, our translators, and everyone else who helped to make the survey a success!&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/surveys/raw/main/surveys/2021-annual-survey/2021-annual-survey-summary.pdf&quot;&gt;Download the report&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Nick Cameron</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Compiler June 2022 Steering Cycle</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/06/03/jun-steering-cycle.html" type="text/html" title="Rust Compiler June 2022 Steering Cycle" />
        <published>2022-06-03T00:00:00+00:00</published>
        <updated>2022-06-03T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/06/03/jun-steering-cycle.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/06/03/jun-steering-cycle.html">&lt;p&gt;On &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bplanning.20meeting.5D.202022-06-03/near/284883023&quot;&gt;Friday, June 3rd&lt;/a&gt;, the Rust Compiler team had a planning meeting for the June 2022 steering cycle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This schedule has changed since this post was first published: the dates of the first two meetings were revised.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#t-compiler-june-steering-schedule&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;t-compiler-june-steering-schedule&quot;&gt;&lt;/a&gt;T-compiler June Steering Schedule&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;th&gt;Meeting Id&lt;/th&gt;
&lt;th&gt;Meeting Topic&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;NHY4Y3VmdXZqcWJxOWgzOXVyZWM5a3JjaWUgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2022-06-10&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/517&quot;&gt;compiler-team#517&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;2022 Q2 P-high review&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;amp;tmeid&#x3D;Nm8xbGtqbHBzMjdpcTRjcHAybmw4a3Y0ZjEgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;2022-06-17&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/516&quot;&gt;compiler-team#516&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;path sanitisation changes &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/issues/3127&quot;&gt;rfc#3127&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/calendar/event?eid&#x3D;MmE2azQyb2ViODQ4NWwxMWViMzJka2g0cjIgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;amp;ctz&#x3D;GMT-04:00&quot;&gt;2022-06-24&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/484&quot;&gt;compiler-team#484&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Compiler Feature Backlog Bonanza&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://calendar.google.com/calendar/event?eid&#x3D;MDJyYnJ1cGFtdWR1c2lnNjFmcHJ2b3JlODFfMjAyMjA3MDFUMTQwMDAwWiA2dTVycnRjZTZscnR2MDdwZmkzZGFtZ2p1c0Bn&amp;amp;ctz&#x3D;GMT-04:00&quot;&gt;2022-07-01&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;none&lt;/td&gt;
&lt;td&gt;(planning for July cycle)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#details&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;details&quot;&gt;&lt;/a&gt;Details&lt;/h3&gt;
&lt;p&gt;Every fourth Friday, the Rust compiler team decides how
it is going to use its scheduled steering and design meeting time over the next
three Fridays.&lt;/p&gt;
&lt;p&gt;On Friday, 10 June, we will be doing a quarterly &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/517&quot;&gt;review of the open P-high issues&lt;/a&gt;.
pnkfelix will do some ahead of time work triaging
some of the issues, and potentially prepare a meeting document summarizing the
remainder, to maximize the quality of our synchronous in-meeting time.&lt;/p&gt;
&lt;p&gt;On Friday, 17 June, we will review &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/issues/3127&quot;&gt;RFC PR #3127&lt;/a&gt;, which proposes
new rustc and Cargo options to allow path sanitisation by default.&lt;/p&gt;
&lt;p&gt;On Friday, 24 June, we will be having a &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/484&quot;&gt;&amp;quot;backlog bonanza&amp;quot;&lt;/a&gt;, in a
similar vein to that done by T-lang, to review the list of unimplemented or
partially-implemented features. pnkfelix and Jack Huey will prepare a document
to drive the meeting.&lt;/p&gt;
&lt;p&gt;On Friday, 1 July, we will hold our planning meeting for the next steering cycle in July.&lt;/p&gt;
&lt;p&gt;Each meeting will run from 2pm to 3pm GMT, and will take place on the
&lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings&quot;&gt;T-compiler/meetings zulip stream&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
    <entry>
        <title>Concluding the events of last November</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/05/26/Concluding-events-mods.html" type="text/html" title="Concluding the events of last November" />
        <published>2022-05-26T00:00:00+00:00</published>
        <updated>2022-05-26T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/05/26/Concluding-events-mods.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/05/26/Concluding-events-mods.html">&lt;p&gt;&lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2021/11/25/in-response-to-the-moderation-team-resignation.html&quot;&gt;With the moderators&#x27; resignation in November&lt;/a&gt;, we (Josh Gould and Khionu Sybiern) had the mantle of the Moderation Team offered to us, and we caught up to speed on what led up to this conflict. Their resignation became a catalyst, and we commited with the rest of the project leadership to do our best to solve the issues present and going forward.&lt;/p&gt;
&lt;p&gt;After these months, the following update was shared with core and team leaders:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The moderation issue has been brought to a resolution. This case was open for an unsually long time, which made this process a considerably worse experience than necessary for all involved. This was caused in part due to the lack of well defined procedures and the underspecified governance structure of the project. Another major factor was the complexity of the situation: it was not a simple case of a CoC violation, but rather a long-standing collaboration and communication issue involving interpersonal conflict and burnout. While we consider this case resolved, we very much recognize the harm that has been done by how the situation was handled, and will continue to work on improving the way we avoid and handle these kind of issues in the future.&lt;/p&gt;
&lt;p&gt;It should be noted that all involved parties are considered in good standing with the project.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bringing a close to this situation is a huge relief, but it is also far from the last step on the journey to recovering as a community. While project leadership &lt;a href&#x3D;&quot;https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html&quot;&gt;continues to work on these issues&lt;/a&gt;, the Moderation Team is working on an RFC to create supporting mechanisms to cover a wider range of issues. We&#x27;re working with professionals in mediation and other relevant fields to make sure we are prepared. The RFC additionally will better define areas of moderation that were overlooked and improve collaboration and safety.&lt;/p&gt;
&lt;p&gt;The number one thing we would like going forward is a stronger two-way relationship between our team and the community. Going forward, we will be asking for your help to make contributing to and using Rust as healthy of an experience as possible.&lt;/p&gt;
</content>

        <author>
            <name>Khionu Sybiern</name>
        </author>
    </entry>
    
    <entry>
        <title>Governance Update</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html" type="text/html" title="Governance Update" />
        <published>2022-05-19T00:00:00+00:00</published>
        <updated>2022-05-19T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html">&lt;p&gt;Last month, the core team, all the leads of top-level teams, the moderators, and the project representatives on the Rust Foundation board jointly sent out an update to all Rust project members on investigations happening into improvements to the governance of the Rust project.&lt;/p&gt;
&lt;p&gt;As is detailed in the update, this report follows extensive conversations with many inside of the project and will continue as we encourage others in the project to reach out should they have feedback or want to get involved.&lt;/p&gt;
&lt;p&gt;Since proper governance of the Rust project impacts all users of Rust, we thought it appropriate to also make this summary public. While typos and grammatical fixes have been made since the original post, the text is otherwise unaltered. &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;As is noted in the summary, the next steps are to take the findings we have so far and begin crafting proposals for how the Rust project will be governed in the future. This will eventually lead to RFCs or similar documents with concrete proposals.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;From: Ryan Levick&lt;br /&gt;
To: All members of the Rust project&lt;br /&gt;
Date: Mon, 11 Apr 2022 18:27:00 UTC&lt;br /&gt;
Subject: Rust Governance Update&lt;/p&gt;
&lt;p&gt;Hey @all,&lt;/p&gt;
&lt;p&gt;We’d like to provide you with an update to our email from December about the issue that led to the resignation of the moderation team in November. In that email, we indicated that we had three high-level goals:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Improve how we handle complex moderation issues.&lt;/li&gt;
&lt;li&gt;Bring the specific moderation issue at the center of the disagreement to an adequate resolution.&lt;/li&gt;
&lt;li&gt;Adapt the governance structure of Rust to better handle the needs of our ever growing project.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order to accomplish these goals the following actions were taken place:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We have established better communication channels between the core team, the moderation team, project representatives on the Rust Foundation, and all top-level team leads. Concretely, we’ve established a Zulip chat with everyone for those groups so that we can quickly and confidently reach consensus on how to approach sensitive items related to project management and governance. This has led to better communication around project management issues and allowed for healthy, productive, and good faith collaboration among all project leads. While there are many different ways we can and will improve how project management is done in the Rust project, it was important that we reach a healthy and productive steady state, and we believe we have been able to do so.&lt;/li&gt;
&lt;li&gt;We have begun exploring possible avenues forward for improving how we handle complex moderation cases including the specific moderation issue in question. While we won’t be diving into detail about this topic in this email, there has been some early progress on better understanding the complexity of this issue. We expect the moderation team in conjunction with project leads to bring forward concrete proposals in the future though this work is somewhat blocked on the next point.&lt;/li&gt;
&lt;li&gt;In pursuit of the ultimate goal of designing and implementing a revised governance structure for Rust, we have been talking with project members to try to deeply understand the requirements of any such governance structure. This process has started with many different conversations with folks from across the project including over 20 formal interviews of project leaders on the needs of Rust project governance. The remainder of this email will be an attempt to outline our initial findings as well as next steps and opportunities for those who are interested to get more involved.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#your-opportunity-to-participate&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;your-opportunity-to-participate&quot;&gt;&lt;/a&gt;Your opportunity to participate&lt;/h3&gt;
&lt;p&gt;First, while we believe we are honing in on a clear understanding of the needs for Rust governance, the conversation is not (and likely will never be) over. If you’d like to participate yourself, you can find the interview questions we have used &lt;a href&#x3D;&quot;https://hackmd.io/@ryanlevick/By2RKtMec&quot;&gt;here&lt;/a&gt;. Write your answers in whatever form you wish, and send them back to Mara or me so they can be incorporated into our notes. Please note that your answers will not be shared with anyone and will only be reflected in documents that attempt to summarize overall feedback from project members.&lt;/p&gt;
&lt;p&gt;We encourage anyone interested in participating to complete the interview before reading the following summary of our findings so far. While every interview brings us closer to a complete understanding of the project management needs of the Rust project, nothing is final yet, and all project members will have the opportunity to provide feedback on any concrete proposals brought forth (most likely in the form of RFCs).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#requirements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;requirements&quot;&gt;&lt;/a&gt;Requirements&lt;/h2&gt;
&lt;p&gt;The following is a list of requirements for Rust governance. Some of these requirements are already met by the current governance structure.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Independent and autonomous teams&lt;/strong&gt;: Almost all decision making should be made at the team level. Teams should have the ability to decide their own directions and have the ultimate authority over their respective piece of the project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cross team collaboration&lt;/strong&gt;: Collaboration between teams should be very high. This ensures teams can make decisions in the context of the larger project and not just within their own silo.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Accountable teams&lt;/strong&gt;: Teams should be held accountable to each other for their work. There should be mechanisms for ensuring teams are meeting other team’s expectations and fulfilling their obligations to other teams.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Centralized leadership&lt;/strong&gt;: While the majority of decisions are owned by and made by independent teams, some decisions affect the entire project. Any such decisions that are not in the purview of one or more specific teams are made by a centralized, accountable leadership body.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Accountable leadership&lt;/strong&gt;: The leadership body should be a structure that has representation and buy-in from all project teams. Additionally, the membership of this group should be chosen transparently, should have large buy-in from other project members, and should be at least reaffirmed relatively often. Lastly, membership in the leadership group requires participation in the wider project and therefore membership in leadership cannot be the exclusive way for someone to participate in the project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Explicit and well-defined structure&lt;/strong&gt;: How the project is structured, who the decision makers are, and how decisions are made should be relatively transparent to both project participants and outsiders. While informal relationships and other soft power mechanisms exist, most collaboration happens transparently and openly.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Structures for project management and administration&lt;/strong&gt;: There should be mechanisms independent from decision making that perform functions of project management and administration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project leaders are not always technical leaders&lt;/strong&gt;: While it may be preferable for some of those who lead technical matters to hold project management leadership positions, being in a leadership position in the project should not require also being in a technical leadership role. In other words, the best language designers don’t necessarily make the best open source project leaders.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flexibility&lt;/strong&gt;: Project structure should be fluid enough to account for the fact that project members always contribute on a volunteer basis (even if they are paid by others for their volunteering), and this means that they are free to leave the project and change what they dedicate their time to whenever they want.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Relatively little bureaucracy&lt;/strong&gt;: It’s important that the amount of project governance overhead and bureaucracy be as little as possible.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Approachable by outsiders&lt;/strong&gt;: Many outside of the Rust project (e.g., users, potential users, other projects, press, partners, etc.) may wish to engage with the Rust project for a variety of reasons. This process should be clear and straightforward.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#under-resourced-work&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;under-resourced-work&quot;&gt;&lt;/a&gt;Under resourced work&lt;/h2&gt;
&lt;p&gt;The following is a list of work that is not receiving the amount of investment that it should be receiving. Our governance structure should ensure that this work receives the proper attention.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Policy development&lt;/strong&gt;: Individual teams do a decent job of ensuring they have proper policies, but there are a few problems with this:
&lt;ul&gt;
&lt;li&gt;Lack of accountability for when a lack of policy might be causing issues&lt;/li&gt;
&lt;li&gt;Lack of support in writing policies&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project structure documentation&lt;/strong&gt;: the structure of the project has practical implications. For example, representation in leadership, permissions, inclusion in project communications, etc. No team is in charge of ensuring this structure is properly documented&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Diversity efforts&lt;/strong&gt;: while some teams may take it on themselves to do diversity work, there is no one responsible for this at the project level&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Identifying gaps&lt;/strong&gt;: Teams do a good job of servicing their own existing needs but sometimes lack the context to know if other needs outside of their purview are being taken care of.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Contributor pipeline improvements&lt;/strong&gt;: Teams often do great work to improve their own workflow, but this assumes contributors are able to find the team they want to contribute on.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conflict resolution&lt;/strong&gt;: Project members don’t always agree and in certain situations a positive outcome cannot be reached without the involvement of those outside that conflict.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Supporting team leads&lt;/strong&gt;: Some leads might be new to leadership and leadership in a vacuum without the support of others is hard. Team leads should not need to rely on personal, private relationships to get the support they need.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project self-reflection&lt;/strong&gt;: instead of waiting for a crisis to occur before addressing issues, the governance structures should have mechanisms for automatically self correcting (i.e., doing the work that Mara and Ryan are doing now on a more regular basis)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reporting progress&lt;/strong&gt;: there is a &lt;em&gt;lot&lt;/em&gt; that happens in the Rust project much of which is not reported on. Having some mechanism for better ensuring that everyone has a good overview of what is happening in the project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Active community management&lt;/strong&gt;: actively fostering the culture of the Rust project&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Marketing&lt;/strong&gt;: the project had previously done more marketing around Rust usage - this work has largely moved to being performed exclusively by individuals&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Public relations&lt;/strong&gt;: The Rust project has obligations to speak to the outside world (i.e., press, companies, educational institutions, other OSS projects, etc.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User outreach&lt;/strong&gt;: while PR is a push mechanism, the project also needs some sort of pull mechanism for engaging with users and understanding their needs rather than solely relying on the individual insights that contributors bring.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Vision work&lt;/strong&gt;: establishing high level project wide goals that cross between team boundaries.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#failure-modes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;failure-modes&quot;&gt;&lt;/a&gt;Failure modes&lt;/h2&gt;
&lt;p&gt;The following are a list of identified failure modes that we want to ensure we avoid when discussing a new governance structure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lack of resources for admin/project management work&lt;/strong&gt;: Administrative and project management work is typically less resourced than technical work. Volunteers are typically more drawn towards technical work, and companies tend to fund technical work since they will more easily see a return on that investment. A properly running project is viewed as “table stakes” and thus less likely to see investment without purposeful resource allocation. A failure mode would be not having admin/project management functions be funded and eventually withering away leaving that work not done or done by those who are already busy with other concerns.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project leadership not held accountable&lt;/strong&gt;: Many teams depend on the work of other teams for their own success. When a team feels another team is not delivering on what they need to succeed, this can lead to cascading failures or even outright conflict. Holding others accountable can be difficult because it requires clear expectations, channels for delivering clear and actionable feedback, consequences for consistently not living up to expectations, and mechanisms for handling conflict should it arise.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Project leadership detached from project&lt;/strong&gt;: As the project grows in complexity so does that admin/project management overhead. It is possible for a project wide decision making body to lose touch with goings-on in the project as they become busy due to this overhead. There are two ways this can manifest itself: the leadership body fails to keep up with what’s happening in the project and/or the project members lose sight of the leadership body leading to degraded authority. A failure mode would be that the project leadership body becomes detached from the project and the two effectively start acting independently.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;An overworked leadership body&lt;/strong&gt;: Many of the requirements described above assume a leadership body with the authority to make decisions. Additionally, the leadership body needs to derive its authority from its members involvement in the rest of the project. A possible failure mode is that the leadership body is tasked with more and more responsibility making it harder for its members to keep up with their responsibilities both inside and outside of that leadership body. The more members begin to focus on their work inside the leadership body, the less they can derive their authority from their work outside that body. Additionally, authority should be largely distributed and so an overworked leadership team is a sign of a failure to properly delegate authority.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lack of delegated authority&lt;/strong&gt;: Some administration and project management tasks require a combination of both authority and large amounts of time to be completed. If authority can only be derived through involvement in technical matters in the project, there is a risk that those charged with that work will not be able to do the work. For example, in the list of under resourced work items above both “identifying gaps” and “project self reflection” require a certain level of authority to have the findings make an impact. It would be necessary for the groups doing that work to somehow gain the level of authority needed to get that work done.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lack of transparency&lt;/strong&gt;: Project governance is composed of activities that live on a spectrum of how sensitive in nature they are. Some activities must be kept private as they directly involve the personal matters of individuals. On the other hand, some activities clearly need the involvement of the entire Rust project from the get-go. Many activities live somewhere in between. A potential failure mode is not consistently ensuring that information that can be made public is regularly made so. Even though this can in practice be very difficult and can make it difficult for some to participate in leadership positions, not doing so can lead to diminishing trust in leadership and a growing lack of accountability.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leadership not consistently held to same standards&lt;/strong&gt;: Those in leadership positions should be held at least to the same standards as those in the rest of the project. What’s more, it can be tempting to revise policies and procedures or interpret underspecified ones while they’re being exercised. A failure mode is that it becomes common practice for leadership to hold themselves to different standards leading to an erosion of trust.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Underspecified processes/policies&lt;/strong&gt;: It can be tempting to write policy assuming participants have the same assumptions, understandings, etc. This is more flexible, requires less bureaucracy, and is easier to change on the fly. However, such processes/policies are easier to abuse (even without intentional malice). Important processes should be applicable even if the entire project membership is switched out.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Changing of delegated decisions&lt;/strong&gt;: A distributed governance structure relies on delegation. However, true delegation means respecting the authority of the party that decision making power has been delegated to. A possible failure mode is constantly second guessing the decisions of teams that have received delegated power. Accountability and oversight are important, but it’s also important that a delegating power not only respect decisions that it would have made itself.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Leadership as popularity contest&lt;/strong&gt;: Some systems of governance favor those who are willing to campaign and/or make themselves most visible. However, those most suitable to lead may not necessarily be those who participate in such activities. A possible failure mode is making project leadership a direct function of how popular/well-known someone is within the community or project.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Diffusion of responsibility&lt;/strong&gt;: If no one is explicitly responsible for a thing then it won’t necessarily get done, even if the thing not getting done is obviously and clearly causing harm. Without an explicit mechanism for understanding the needs of the project and ensuring that those needs are filled, the project is liable to continue to see important work not getting done.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I&#x27;d like to take this opportunity to thank you for reading this very long email. Once again, if you&#x27;d like to participate or give feedback in any form, please do not hesitate to reach out.&lt;/p&gt;
&lt;p&gt;Cheers,&lt;br /&gt;
Ryan&lt;/p&gt;
&lt;/blockquote&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;See &lt;a href&#x3D;&quot;https://github.com/rust-lang/blog.rust-lang.org/pull/974&quot;&gt;rust-lang/blog.rust-lang.org#974&lt;/a&gt; for the full history of changes to the original email. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Ryan Levick and Mara Bos</name>
        </author>
    </entry>
    
    <entry>
        <title>1.61.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/05/16/1.61.0-prerelease.html" type="text/html" title="1.61.0 pre-release testing" />
        <published>2022-05-16T00:00:00+00:00</published>
        <updated>2022-05-16T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/05/16/1.61.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/05/16/1.61.0-prerelease.html">&lt;p&gt;The 1.61.0 pre-release is ready for testing. The release is scheduled for this
Thursday, May 19th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1610-2022-05-19&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2022-05-16/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2022-05-16/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-61-0-prerelease-testing/&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The release team is also thinking about changes to our pre-release process:
we&#x27;d love your feedback &lt;a href&#x3D;&quot;https://github.com/rust-lang/release-team/issues/16&quot;&gt;on this GitHub issue&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Mark Rousskov</name>
        </author>
    </entry>
    
    <entry>
        <title>CTCFT 2022-05-16 Agenda</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2022/05/10/CTCFT-may.html" type="text/html" title="CTCFT 2022-05-16 Agenda" />
        <published>2022-05-10T00:00:00+00:00</published>
        <updated>2022-05-10T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2022/05/10/CTCFT-may.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2022/05/10/CTCFT-may.html">&lt;p&gt;The next &lt;a href&#x3D;&quot;https://rust-lang.github.io/ctcft/&quot;&gt;&amp;quot;Cross Team Collaboration Fun Times&amp;quot; (CTCFT)&lt;/a&gt; meeting will take
place on Monday, 2022-05-16 at &lt;strong&gt;11am US Eastern Time&lt;/strong&gt; (&lt;a href&#x3D;&quot;https://everytimezone.com/s/6c2a0d08&quot;&gt;click to see in your
time zone&lt;/a&gt;). You’ll find the full details (along with a calendar
event, zoom details, etc) &lt;a href&#x3D;&quot;https://rust-lang.github.io/ctcft/meetings/2022-05-16.html&quot;&gt;on the CTCFT website&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#agenda&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;agenda&quot;&gt;&lt;/a&gt;Agenda&lt;/h2&gt;
&lt;p&gt;The theme for this month&#x27;s CTCFT is &lt;strong&gt;Embedded Rust&lt;/strong&gt;. We&#x27;ll hear from some
members of the Rust Embedded Working Group and community about the state of the ecosystem, as
well as how async Rust is working for embedded systems. We also have some people
coming in from the automotive industry to talk about how Rust use is starting to
progress.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(5 min) Opening remarks 👋 (&lt;a href&#x3D;&quot;https://github.com/angelonfira&quot;&gt;angelonfira&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;(15 min) A whirlwind tour of Embedded Rust (&lt;a href&#x3D;&quot;https://github.com/jamesmunns&quot;&gt;jamesmunns&lt;/a&gt;)
&lt;ul&gt;
&lt;li&gt;A brief history of the embedded-wg and use of Rust for embedded&lt;/li&gt;
&lt;li&gt;A look at how developing embedded Rust looks like today&lt;/li&gt;
&lt;li&gt;A sample of patterns that are special to embedded Rust, or differences from
&amp;quot;desktop&amp;quot; Rust&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(15 min) Async Rust for Embedded Systems (&lt;a href&#x3D;&quot;https://github.com/Dirbaio&quot;&gt;Dirbaio&lt;/a&gt;)
&lt;ul&gt;
&lt;li&gt;We&#x27;ll explore how concurrency is traditionally handled in embedded, and how
Rust&#x27;s async makes it significantly easier while still requiring no runtime,
no OS, and no allocation, and what Rust improvements could make it even more
awesome.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(15 min) Rust in Automotive (&lt;a href&#x3D;&quot;https://github.com/cpetig&quot;&gt;cpetig&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/skade&quot;&gt;skade&lt;/a&gt;)
&lt;ul&gt;
&lt;li&gt;We&#x27;ll look at Rust from a Functional Safety perspective, and continuing to
the AUTOSAR architecture. We&#x27;ll also look a bit at what Ferrocene&#x27;s role is
in all this, and look at the AUTOSAR Rust bindings. Finally, we&#x27;ll see
what&#x27;s next for this space.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(5 min) Closing (&lt;a href&#x3D;&quot;https://github.com/angelonfira&quot;&gt;angelonfira&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#afterwards-social-hour&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;afterwards-social-hour&quot;&gt;&lt;/a&gt;Afterwards: Social Hour&lt;/h2&gt;
&lt;p&gt;Like always, we&#x27;ll be running a social hour after the CTCFT. The idea is really
simple: for the hour after the meeting, we will create breakout rooms in Zoom
with different themes. You can join any breakout room you like and hangout.&lt;/p&gt;
</content>

        <author>
            <name>Rust CTCFT Team</name>
        </author>
    </entry>
    
</feed>

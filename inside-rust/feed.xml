<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/inside-rust/" version="0.1.0">Inside Rust Blog</generator>
    <link href="https://blog.rust-lang.org/inside-rust/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/inside-rust/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/inside-rust/</id>
    <title>Inside Rust Blog</title>
    <subtitle>Want to follow along with Rust development? Curious how you might get involved? Take a look!</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2020-09-29T23:09:24+00:00</updated>

    
    <entry>
        <title>Announcing the Portable SIMD Project Group</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/09/29/Portable-SIMD-PG.html" type="text/html" title="Announcing the Portable SIMD Project Group" />
        <published>2020-09-29T00:00:00+00:00</published>
        <updated>2020-09-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/09/29/Portable-SIMD-PG.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/09/29/Portable-SIMD-PG.html">&lt;p&gt;We&#x27;re announcing the start of the &lt;em&gt;Portable SIMD Project Group&lt;/em&gt; within the Libs team. This group is dedicated to making a portable SIMD API available to stable Rust users.&lt;/p&gt;
&lt;p&gt;The Portable SIMD Project Group is lead by &lt;a href&#x3D;&quot;https://github.com/calebzulawski&quot;&gt;@calebzulawski&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/Lokathor&quot;&gt;@Lokathor&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/workingjubilee&quot;&gt;@workingjubilee&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-are-project-groups&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-are-project-groups&quot;&gt;&lt;/a&gt;What are project groups?&lt;/h2&gt;
&lt;p&gt;Rust uses &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2856-project-groups.html&quot;&gt;project groups&lt;/a&gt; to help coordinate work.
They&#x27;re a place for people to get involved in helping shape the parts of Rust that matter to them.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-simd&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-simd&quot;&gt;&lt;/a&gt;What is SIMD?&lt;/h2&gt;
&lt;p&gt;SIMD stands for Single Instruction, Multiple Data.
It lets the CPU apply a single instruction to a &amp;quot;vector&amp;quot; of data.
The vector is a single extra-wide CPU register made of multiple &amp;quot;lanes&amp;quot; of the same data type.
You can think of it as being &lt;em&gt;similar&lt;/em&gt; to an array.
Instead of processing each lane individually, all lanes have the same operation applied &lt;em&gt;simultaneously&lt;/em&gt;.
This lets you transform data much faster than with standard code.
Not every problem can be accelerated with &amp;quot;vectorized&amp;quot; code, but for multimedia and list-processing applications there can be significant gains.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#why-do-you-need-to-make-it-portable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-do-you-need-to-make-it-portable&quot;&gt;&lt;/a&gt;Why do you need to make it portable?&lt;/h2&gt;
&lt;p&gt;Different chip vendors offer different SIMD instructions.
Some of these are available in Rust&#x27;s &lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/arch/index.html&quot;&gt;&lt;code&gt;std::arch&lt;/code&gt;&lt;/a&gt; module.
You &lt;em&gt;can&lt;/em&gt; build vectorized functions using that, but at the cost of maintaining a different version for each CPU you want to support.
You can also &lt;em&gt;not&lt;/em&gt; write vectorized operations and hope that LLVM&#x27;s optimizations will &amp;quot;auto-vectorize&amp;quot; your code.
However, the auto-vectorizer is easily confused and can fail to optimize &amp;quot;obvious&amp;quot; vector tasks.&lt;/p&gt;
&lt;p&gt;The portable SIMD API will enable writing SIMD code just once using a high-level API.
By explicitly communicating your intent to the compiler, it&#x27;s better able to generate the best possible final code.
This is still only a best-effort process.
If your target doesn&#x27;t support a desired operation in SIMD, the compiler will fall back to using scalar code, processing one lane at a time.
The details of what&#x27;s available depend on the build target.&lt;/p&gt;
&lt;p&gt;We intend to release the Portable SIMD API as &lt;code&gt;std::simd&lt;/code&gt;.
We will cover as many use cases as we can, but it might still be appropriate for you to use &lt;code&gt;std::arch&lt;/code&gt; directly.
For that reason the &lt;code&gt;std::simd&lt;/code&gt; types will also be easily convertable to &lt;code&gt;std::arch&lt;/code&gt; types where needed.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#how-can-i-get-involved&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-can-i-get-involved&quot;&gt;&lt;/a&gt;How can I get involved?&lt;/h2&gt;
&lt;p&gt;Everyone can get involved!
No previous experience necessary.
If you&#x27;d like to help make portable SIMD a reality you can visit our &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-portable-simd&quot;&gt;GitHub repository&lt;/a&gt; or reach out on &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/257879-project-portable-simd&quot;&gt;Zulip&lt;/a&gt; and say hi! :wave:&lt;/p&gt;
</content>

        <author>
            <name>Jubilee and Lokathor</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing the Error Handling Project Group</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/09/18/error-handling-wg-announcement.html" type="text/html" title="Announcing the Error Handling Project Group" />
        <published>2020-09-18T00:00:00+00:00</published>
        <updated>2020-09-18T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/09/18/error-handling-wg-announcement.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/09/18/error-handling-wg-announcement.html">&lt;p&gt;Today we are announcing the formation of a new project group under
the libs team, focused on error handling!&lt;/p&gt;
&lt;p&gt;Some of the goals this project group will be working on include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Defining and codifying common error handling terminology.&lt;/li&gt;
&lt;li&gt;Generating consensus on current error handling best practices.&lt;/li&gt;
&lt;li&gt;Identifying pain points that exist in Rust’s error handling story.&lt;/li&gt;
&lt;li&gt;Communicating current error handling best practices.&lt;/li&gt;
&lt;li&gt;Consolidating the Rust error handling ecosystem.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This new project group is being shepherded by Jane Lusby
(&lt;a href&#x3D;&quot;https://github.com/yaahc&quot;&gt;@yaahc&lt;/a&gt;) and Sean Chen
(&lt;a href&#x3D;&quot;https://github.com/seanchen1991&quot;&gt;@seanchen1991&lt;/a&gt;), with Andrew
Gallant (&lt;a href&#x3D;&quot;https://github.com/burntsushi&quot;&gt;@BurntSushi&lt;/a&gt;) acting in
an advisory capacity and Ashley Mannix
(&lt;a href&#x3D;&quot;https://github.com/KodrAus&quot;&gt;@KodrAus&lt;/a&gt;) acting as the library team
liaison.&lt;/p&gt;
&lt;p&gt;Anyone interested in helping out with the above goals is invited to
come say hi in the group’s  &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/257204-project-error-handling&quot;&gt;Zulip stream&lt;/a&gt;. Feel free to also check
out the group’s &lt;a href&#x3D;&quot;https://github.com/rust-lang/project-error-handling&quot;&gt;GitHub repository&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Sean Chen</name>
        </author>
    </entry>
    
    <entry>
        <title>Intra-doc links close to stabilization</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/09/17/stabilizing-intra-doc-links.html" type="text/html" title="Intra-doc links close to stabilization" />
        <published>2020-09-17T00:00:00+00:00</published>
        <updated>2020-09-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/09/17/stabilizing-intra-doc-links.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/09/17/stabilizing-intra-doc-links.html">&lt;p&gt;We&#x27;re excited to share that intra-doc links are stabilizing soon!&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/rustdoc/unstable-features.html#linking-to-items-by-name&quot;&gt;Intra-doc links&lt;/a&gt; are a feature of &lt;code&gt;rustdoc&lt;/code&gt; that allow you to link to &#x27;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/reference/items.html&quot;&gt;items&lt;/a&gt;&#x27; - functions, types, and more - by their name, instead of a hard-coded URL. This lets you have accurate links even if your types are &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/32129&quot;&gt;re-exported in a different module or crate&lt;/a&gt;. Here is a simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;/// Link to [&#x60;f()&#x60;]
pub struct S;

pub fn f() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Intra-doc links have been around for a while, all the way back &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/43466&quot;&gt;since 2017&lt;/a&gt;! They have been available on &lt;code&gt;nightly&lt;/code&gt; without flags (and thus, on &lt;a href&#x3D;&quot;https://docs.rs&quot;&gt;docs.rs&lt;/a&gt;), so you may be surprised to hear that they weren&#x27;t yet stable. What&#x27;s changing now is that they will be available on stable Rust, which also means we are more confident in the implementation and would strongly encourage their use. We recommend that you switch your libraries to use intra-doc links, which will fix broken links for re-exported types and links to different crates. We hope to add support for automating this process with &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/75805&quot;&gt;&lt;code&gt;cargo fix&lt;/code&gt;&lt;/a&gt; in the future.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-history-of-intra-doc-links&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-history-of-intra-doc-links&quot;&gt;&lt;/a&gt;The history of intra-doc links&lt;/h2&gt;
&lt;p&gt;I (Manish) and &lt;a href&#x3D;&quot;https://github.com/QuietMisdreavus&quot;&gt;QuietMisdreavus&lt;/a&gt; started working on them in December 2017. Mozilla had given the whole company a couple weeks off after the release of &lt;a href&#x3D;&quot;https://blog.mozilla.org/blog/2017/11/14/introducing-firefox-quantum/&quot;&gt;Firefox Quantum&lt;/a&gt;, and I was visiting family in Mumbai. This meant that I had a fair amount of free time, and we were in diametrically opposite timezones. QuietMisdreavus had been working on the feature for a while but was less familiar with rustc&#x27;s path resolution code, so I decided to help. We ended up pairing for those few weeks: during the day I&#x27;d write some code, discuss with QuietMisdreavus in the evening, and then hand it over for her to continue overnight. It was a great experience, pairing in open source can be really fun! This ended up in a &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/47046/commits&quot;&gt;46-commit pull request&lt;/a&gt; with commits from both of us.&lt;/p&gt;
&lt;p&gt;Unfortunately, we were not able to stabilize the feature at the time. The main blocker was &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/65983&quot;&gt;cross-crate re-exports&lt;/a&gt;, things like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// Crate &#x60;inner&#x60;
/// Link to [&#x60;f()&#x60;]
pub struct S;
pub fn f() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// outer crate
pub use inner::S;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The way &lt;code&gt;rustdoc&lt;/code&gt; handles reexports is that it renders the reexport in-situ, parsing and rendering all of the markdown. The issue here is that &lt;code&gt;rustdoc&lt;/code&gt;, when documenting &lt;code&gt;outer&lt;/code&gt;, does not have access to the local scope information of &lt;code&gt;inner::S&lt;/code&gt; and cannot resolve &lt;code&gt;f()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;These links were the original motivation for intra-doc links, so if we couldn&#x27;t get them working, there wasn&#x27;t much point in stabilizing! They also had the downside that they could &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/43466#issuecomment-570100948&quot;&gt;silently break&lt;/a&gt; - the documentation would work when you built it, but any user of your API could re-export your types and cause the links to be broken.&lt;/p&gt;
&lt;p&gt;At the time, persisting local scope information so that &lt;code&gt;rustdoc&lt;/code&gt; invocations on downstream crates could access them would involve a significant amount of work on the compiler. It was work the compiler team wanted to be done anyway, but it was a lot, and neither of us had the bandwidth to do it, so we &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/65983&quot;&gt;filed a bug&lt;/a&gt; and went on our way.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-changed&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-changed&quot;&gt;&lt;/a&gt;What changed?&lt;/h2&gt;
&lt;p&gt;Early in June, I (Joshua) got tired of not being able to use intra-doc links. I started investigating the issue to see if there was a fix. It was marked as &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/labels/E-hard&quot;&gt;&lt;code&gt;E-hard&lt;/code&gt;&lt;/a&gt;, so I wasn&#x27;t expecting miracles, but I thought I might at least make a start on it.&lt;/p&gt;
&lt;p&gt;It turns out there was a simple problem with the implementation - it assumed
all items were in the current crate! Clearly, that&#x27;s not always the case. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/73101&quot;&gt;The fix&lt;/a&gt; turned out to be easy enough that I could implement it as my first contribution to rustdoc.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note from Manish:&lt;/em&gt; Actually, the distinction between &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html&quot;&gt;&lt;code&gt;DefId&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.LocalDefId.html&quot;&gt;&lt;code&gt;LocalDefId&lt;/code&gt;&lt;/a&gt; &lt;em&gt;didn&#x27;t exist&lt;/em&gt; when we wrote the feature, and the code would only resolve paths based on the resolver&#x27;s current internal scope (which can only be within the current crate, since that is the only scope information the resolver had at the time). However, over time the compiler &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/63400&quot;&gt;gained the ability&lt;/a&gt; to store and query resolution scopes of dependencies. We never noticed, and continued to believe that there was a large piece of work blocking stabilization.&lt;/p&gt;
&lt;p&gt;However, my solution had one small problem: on certain &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/71820&quot;&gt;carefully crafted inputs&lt;/a&gt;, it would crash:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#![feature(decl_macro)]
fn main() {
    || {
        macro m() {}
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;thread &#x27;rustc&#x27; panicked at &#x27;called &#x60;Option::unwrap()&#x60; on a &#x60;None&#x60; value&#x27;, /home/joshua/src/rust/src/librustc_hir/definitions.rs:358:9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#hirids-and-defids-and-trees-oh-my&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;hirids-and-defids-and-trees-oh-my&quot;&gt;&lt;/a&gt;HirIds and DefIds and trees, oh my!&lt;/h2&gt;
&lt;p&gt;(If you&#x27;re not interested in the internals of the Rust compiler, feel free to skip this section.)&lt;/p&gt;
&lt;p&gt;The error above came because of a pass called &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/bd49eec3d76d5894b539a28309c2fe24f915ee94/compiler/rustc_interface/src/util.rs#L583&quot;&gt;&lt;code&gt;everybody_loops&lt;/code&gt;&lt;/a&gt;. A compiler &#x27;pass&#x27; is a transformation on the source code, for example &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/e539dd65f8ba80837f7477c0547c61514bceb3ad/src/librustc_lint/builtin.rs#L302&quot;&gt;finding items without documentation&lt;/a&gt;.
The &lt;code&gt;everybody_loops&lt;/code&gt; pass turns the above code into:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn main() {
    {
        macro m { () &#x3D;&amp;gt; { } }
    }
    loop  { }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As part of my changes for resolving cross-crate items, I needed to know the first parent module, so I could tell what items were in scope. Note however, that after &lt;code&gt;everybody_loops&lt;/code&gt; the closure has disappeared! The crash happened because &lt;code&gt;rustdoc&lt;/code&gt; was trying to access a closure that &lt;code&gt;rustc&lt;/code&gt; didn&#x27;t think existed (in compiler jargon, it was turning the &lt;code&gt;DefId&lt;/code&gt; for the closure, which works across crates, into a &lt;code&gt;HirId&lt;/code&gt;, which is specific to the current crate but contains a lot more info).&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#why-is-this-hard&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-is-this-hard&quot;&gt;&lt;/a&gt;Why is this hard?&lt;/h1&gt;
&lt;p&gt;This turned out to be an enormous rabbit hole. &lt;code&gt;everybody_loops&lt;/code&gt; was &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/43348&quot;&gt;introduced&lt;/a&gt; all the way back in 2017 to solve another long-standing issue: &lt;code&gt;rustdoc&lt;/code&gt; doesn&#x27;t know how to deal with &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/1998&quot;&gt;conditional compilation&lt;/a&gt;. What it lets rustdoc (and by extension, the standard library) do is ignore type and name errors in function bodies. This allows documenting both Linux and Windows APIs on the same host, even though the implementations would &lt;a href&#x3D;&quot;https://gist.github.com/jyn514/aee31eb1cc99d012ff674bec7d122b5e&quot;&gt;normally be broken&lt;/a&gt;. As seen above, the way it works is by turning every function body into &lt;code&gt;loop {}&lt;/code&gt; - this is always valid, because &lt;code&gt;loop {}&lt;/code&gt; has type &lt;code&gt;!&lt;/code&gt;, which coerces to any type!&lt;/p&gt;
&lt;!--
However there&#x27;s a problem: [function bodies aren&#x27;t _always_ opaque][preserve-item-decls].
You can implement traits inside a function:

&#x60;&#x60;&#x60;rust
pub struct S;
fn f() {
    impl Default for S {
        fn default() -&gt; Self {
            S
        }
    }
}
&#x60;&#x60;&#x60;

If you replace that trait implementation with a loop, you have a problem.
--&gt;
&lt;p&gt;As we saw above, though, this transformation broke rustdoc. Additionally, it was causing &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/65863&quot;&gt;lots&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/53002&quot;&gt;of&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/43878&quot;&gt;other&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/65252/commits/25cc99fca0650f54828e8ba7ad2bab341b231fcc&quot;&gt;problems&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So I got rid of it! This was &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/73566&quot;&gt;Don&#x27;t run everybody_loops&lt;/a&gt;. It is the single largest PR I&#x27;ve ever made to rustc, and hopefully the largest I will ever make. The issue was that the errors from libstd haven&#x27;t gone away - if anything, it had been expanded since 2017. The hack I came up with was to, instead of running type checking and trying to rewrite the code into something that was valid, never run type checking in function bodies at all! This is both &lt;a href&#x3D;&quot;https://perf.rust-lang.org/compare.html?start&#x3D;6ee1b62c811a6eb68d6db6dfb91f66a49956749b&amp;end&#x3D;5c9e5df3a097e094641f16dab501ab1c4da10e9f&amp;stat&#x3D;instructions:u&quot;&gt;less work&lt;/a&gt; and closer to the semantics rustdoc wants. In particular, it never causes the invalid states that were crashing &lt;code&gt;rustdoc&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#aftermath-no-good-deed-goes-unpunished&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;aftermath-no-good-deed-goes-unpunished&quot;&gt;&lt;/a&gt;Aftermath: No good deed goes unpunished&lt;/h2&gt;
&lt;p&gt;About a month after the PR was merged, rustdoc got a bug report: the docs for &lt;code&gt;async-std&lt;/code&gt; failed to build on the nightly channel. Their code looked something like &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/b146000e910ccd60bdcde89363cb6aa14ecc0d95/src/test/rustdoc-ui/error-in-impl-trait/realistic-async.rs&quot;&gt;the following&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;mod windows {
    pub trait WinFoo {
        fn foo(&amp;amp;self) {}
    }
    impl WinFoo for () {}
}

#[cfg(any(windows, doc))]
use windows::*;

mod unix {
    pub trait UnixFoo {
        fn foo(&amp;amp;self) {}
    }
    impl UnixFoo for () {}
}

#[cfg(any(unix, doc))]
use unix::*;

async fn bar() {
    ().foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In particular, notice that under &lt;code&gt;cfg(doc)&lt;/code&gt;, both traits would be in scope with the same method, so it would be ambiguous which to use for &lt;code&gt;.foo()&lt;/code&gt;. This is exactly the sort of problem meant to be solved by not running type-checking. Unfortunately, since it was used in an &lt;code&gt;async fn&lt;/code&gt;, type checking was still being run; &lt;code&gt;bar&lt;/code&gt; desugars to a closure of the following form:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn bar() -&amp;gt; impl Future&amp;lt;Output &#x3D; ()&amp;gt; {
    async {
        ().foo()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because the function returned &lt;code&gt;impl Future&lt;/code&gt;, that required type-checking the body to infer the return type of the function. That&#x27;s exactly what &lt;code&gt;rustdoc&lt;/code&gt; wanted not to do!&lt;/p&gt;
&lt;p&gt;The &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75127/&quot;&gt;hacky &#x27;fix&#x27;&lt;/a&gt; implemented was to not infer the type of the function at all - rustdoc doesn&#x27;t care about the exact type, only the traits that it implements. This was such a hack there&#x27;s an &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/75100&quot;&gt;issue open to fix it&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#stabilizing-intra-doc-links&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilizing-intra-doc-links&quot;&gt;&lt;/a&gt;Stabilizing intra-doc links&lt;/h2&gt;
&lt;p&gt;Now that cross-crate re-exports work, there isn&#x27;t much standing in the way of stabilizing intra-doc links! There are a &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/74489&quot;&gt;few&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75176&quot;&gt;cleanup&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75079&quot;&gt;PRs&lt;/a&gt;, but for the most part, the path to stabilization seems clear.&lt;/p&gt;
&lt;p&gt;In the meantime, I&#x27;ve been working on various improvements to intra-doc links:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md#linking-to-associated-items&quot;&gt;Resolving associated items&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75176&quot;&gt;Fixing&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75649&quot;&gt;various&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76082&quot;&gt;bugs&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76093&quot;&gt;in&lt;/a&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76467&quot;&gt;the&lt;/a&gt; implementation&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/75080&quot;&gt;Using intra-doc links throughout the standard library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Detecting more cases when &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75815&quot;&gt;links are ambiguous&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/76078&quot;&gt;Removing disambiguators&lt;/a&gt; that only distract from the docs&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/75756&quot;&gt;Improving the errors messages&lt;/a&gt; when a link fails to resolve&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In particular, there have been a ton of people who stepped up to help &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/75080&quot;&gt;convert the standard library to intra-doc links&lt;/a&gt;. A giant thank you to &lt;strong&gt;@camelid&lt;/strong&gt;, &lt;strong&gt;@denisvasilik&lt;/strong&gt;, &lt;strong&gt;@poliorcetics&lt;/strong&gt;, &lt;strong&gt;@nixphix&lt;/strong&gt;, &lt;strong&gt;@EllenNyan&lt;/strong&gt;, &lt;strong&gt;@kolfs&lt;/strong&gt;, &lt;strong&gt;@LeSeulArtichaut&lt;/strong&gt;, &lt;strong&gt;@Amjad50&lt;/strong&gt;, and &lt;strong&gt;@GuillaumeGomez&lt;/strong&gt; for all their help!&lt;/p&gt;
</content>

        <author>
            <name>Manish Goregaokar and Joshua Nelson</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes to x.py defaults</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html" type="text/html" title="Changes to x.py defaults" />
        <published>2020-08-30T00:00:00+00:00</published>
        <updated>2020-08-30T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html">&lt;p&gt;Recently, the defaults for &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/building/how-to-build-and-run.html#what-is-xpy&quot;&gt;&lt;code&gt;x.py&lt;/code&gt;&lt;/a&gt;, the tool used to &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html&quot;&gt;bootstrap&lt;/a&gt; the Rust compiler from source, changed. If you regularly contribute to Rust, this might affect your workflow.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-changes-were-made&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-changes-were-made&quot;&gt;&lt;/a&gt;What changes were made?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The default stage is now dependent on the subcommand:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dist&lt;/code&gt;: stage 2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build&lt;/code&gt;: stage 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt;: stage 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doc&lt;/code&gt;: stage 0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stage 1 &lt;code&gt;rustc&lt;/code&gt; artifacts are no longer built by &lt;code&gt;x.py build --stage 1&lt;/code&gt;. To get the old behavior back, use &lt;code&gt;x.py build --stage 1 src/rustc&lt;/code&gt;. The new behavior for &lt;code&gt;build --stage 1&lt;/code&gt; builds everything except &lt;code&gt;rustc&lt;/code&gt;, which includes the standard library, &lt;code&gt;rustdoc&lt;/code&gt;, and various other tools (if the tools are enabled).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;debuginfo&lt;/code&gt; now defaults to &lt;code&gt;1&lt;/code&gt; when &lt;code&gt;debug &#x3D; true&lt;/code&gt;. Previously, the default was 2.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#why-were-the-changes-made&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-were-the-changes-made&quot;&gt;&lt;/a&gt;Why were the changes made?&lt;/h2&gt;
&lt;p&gt;Previously, &lt;code&gt;x.py build&lt;/code&gt; would build &lt;code&gt;rustc&lt;/code&gt; twice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;build/stage0-std&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage0-rustc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage1-std&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage1-rustc&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Normally, contributors only want to build the compiler once, which lets them test their changes quickly. After this change, that&#x27;s now the default:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;build/stage0-std&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage0-rustc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/stage1-std&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;debuginfo &#x3D; 2&lt;/code&gt; generates several gigabytes of debug information,
making the previous default settings for &lt;code&gt;debug &#x3D; true&lt;/code&gt; very painful.&lt;/p&gt;
&lt;p&gt;For a detailed rationale of the changes, as well as more information about the alternatives considered, see&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/326&quot;&gt;the MCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/73964&quot;&gt;implementation PR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/233931-xxx/topic/Use.20sane.20defaults.20in.20x.py.20compiler-team.23326&quot;&gt;Zulip stream&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Joshua Nelson</name>
        </author>
    </entry>
    
    <entry>
        <title>Upcoming compiler-team design meetings</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/08/28/upcoming-compiler-team-design-meetings.html" type="text/html" title="Upcoming compiler-team design meetings" />
        <published>2020-08-28T00:00:00+00:00</published>
        <updated>2020-08-28T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/08/28/upcoming-compiler-team-design-meetings.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/08/28/upcoming-compiler-team-design-meetings.html">&lt;p&gt;In our &lt;a href&#x3D;&quot;https://zulip-archive.rust-lang.org/238009tcompilermeetings/99475planningmeeting20200828.html&quot;&gt;planning meeting today&lt;/a&gt;, the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/compiler&quot;&gt;compiler team&lt;/a&gt; has scheduled our
next batch of upcoming design meetings. You can find the exact times
on the compiler team&#x27;s &lt;a href&#x3D;&quot;https://rust-lang.github.io/compiler-team/#meeting-calendar&quot;&gt;meeting calendar&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On September 4th (&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;tmeid&#x3D;NTMwYmxwaDRxZG8xdHJkdm1mdW1jMWxwMmYgNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will discuss the results
of the contributor survey that we conducted. See &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/318&quot;&gt;rust-lang/compiler-team#318&lt;/a&gt; for more details.&lt;/li&gt;
&lt;li&gt;On September 18th (&lt;a href&#x3D;&quot;https://calendar.google.com/event?action&#x3D;TEMPLATE&amp;tmeid&#x3D;MzVmbGVvcXVkcTM4MmJxam5lM25wbWEzaG8gNnU1cnJ0Y2U2bHJ0djA3cGZpM2RhbWdqdXNAZw&amp;tmsrc&#x3D;6u5rrtce6lrtv07pfi3damgjus%40group.calendar.google.com&quot;&gt;calendar event&lt;/a&gt;), we will conduct a retrospective
of the &lt;a href&#x3D;&quot;https://forge.rust-lang.org/compiler/mcp.html&quot;&gt;compiler-team MCP process&lt;/a&gt;. See &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/314&quot;&gt;rust-lang/compiler-team#314&lt;/a&gt; for more details.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#did-you-know&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;did-you-know&quot;&gt;&lt;/a&gt;Did you know?&lt;/h3&gt;
&lt;p&gt;Most weeks, the compiler team has some sort of design meeting. These
meetings take place on Zulip and are open to all. Every 4 weeks, we do
a planning meeting to pick the next few meetings from the list of open
proposals. You can find &lt;a href&#x3D;&quot;https://rust-lang.github.io/compiler-team/about/steering-meeting/&quot;&gt;more details about how the compiler-team
steering meeting process here&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>1.46.0 pre-release testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/08/24/1.46.0-prerelease.html" type="text/html" title="1.46.0 pre-release testing" />
        <published>2020-08-24T00:00:00+00:00</published>
        <updated>2020-08-24T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/08/24/1.46.0-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/08/24/1.46.0-prerelease.html">&lt;p&gt;The 1.46.0 pre-release is ready for testing. The release is scheduled for this
Thursday, August 27th. &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1460-2020-08-27&quot;&gt;Release notes can be found here.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;You can try it out locally by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2020-08-24/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2020-08-24/index.html&lt;/a&gt;. You
can leave feedback on the &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/rust-1-46-0-pre-release-testing/12957&quot;&gt;internals thread&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>Lang team design meeting: well-formedness and type aliases</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/07/29/lang-team-design-meeting-wf-types.html" type="text/html" title="Lang team design meeting: well-formedness and type aliases" />
        <published>2020-07-29T00:00:00+00:00</published>
        <updated>2020-07-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/07/29/lang-team-design-meeting-wf-types.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/07/29/lang-team-design-meeting-wf-types.html">&lt;p&gt;Hello! Did you know that the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/lang&quot;&gt;lang team&lt;/a&gt; now has regular design
meetings? We use these meetings to dig deeper into the output of
active project groups. After the meeting, we typically post a
recording to &lt;a href&#x3D;&quot;https://www.youtube.com/playlist?list&#x3D;PL85XCvVPmGQg-gYy7R6a_Y91oQLdsbSpa&quot;&gt;YouTube&lt;/a&gt; as well as some &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/tree/master/design-meeting-minutes&quot;&gt;minutes into the lang-team
repository&lt;/a&gt;. I wanted to write a quick update listing out some of
the meetings we&#x27;ve had recently as well as some of our upcoming
meetings.&lt;/p&gt;
&lt;p&gt;This blog post is about the meeting we held on 2020-07-29. We
discussed the idea of trying to enforce the &amp;quot;well-formedness&amp;quot; rules
for type aliases, as has been floated on and off over the years.&lt;/p&gt;
&lt;p&gt;The context is that the compiler&#x27;s current rules expand type aliases
as if they were a kind of macro, which means that we don&#x27;t wind up
enforcing many sorts of rules about them.&lt;/p&gt;
&lt;p&gt;For example, the following type alias definition is legal even though
it would be an error to ever use it:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct MyType&amp;lt;T: Display&amp;gt; { t: T }

// This alias, perhaps, should err, as &#x60;Vec&amp;lt;u32&amp;gt;: Display&#x60;
// does not hold:
type MyAlias &#x3D; MyType&amp;lt;Vec&amp;lt;u32&amp;gt;&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For more information, check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2020-07-29-wf-checks-and-ty-aliases.md&quot;&gt;minutes from the meeting&lt;/a&gt; or
&lt;a href&#x3D;&quot;https://youtu.be/tIBZYQSA_eM&quot;&gt;watch the recording&lt;/a&gt;. We covered a number of examples of what goes
wrong, as well as various possible &amp;quot;endstates&amp;quot; that we might want to
reach (for example, there is an argument that the above example should
be accepted after all, perhaps with a warning).&lt;/p&gt;
&lt;p&gt;The conclusion during the meeting was that we would not put a lot of
energy into type aliases at this time, and in particular we wouldn&#x27;t
aim for any Edition-related migrations and hard-errors, but we would
accept PRs that introduce warnings for type alias definitions that are
always an error to use. (Like any conclusion that happens in a
meeting, it may be revised if we encounter new evidence that changes
our minds.)&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Lang team design meeting: minimal const generics</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/07/29/lang-team-design-meeting-min-const-generics.html" type="text/html" title="Lang team design meeting: minimal const generics" />
        <published>2020-07-29T00:00:00+00:00</published>
        <updated>2020-07-29T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/07/29/lang-team-design-meeting-min-const-generics.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/07/29/lang-team-design-meeting-min-const-generics.html">&lt;p&gt;Hello! Did you know that the &lt;a href&#x3D;&quot;https://www.rust-lang.org/governance/teams/lang&quot;&gt;lang team&lt;/a&gt; now has regular design
meetings? We use these meetings to dig deeper into the output of
active project groups. After the meeting, we typically post a
recording to &lt;a href&#x3D;&quot;https://www.youtube.com/playlist?list&#x3D;PL85XCvVPmGQg-gYy7R6a_Y91oQLdsbSpa&quot;&gt;YouTube&lt;/a&gt; as well as some &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/tree/master/design-meeting-minutes&quot;&gt;minutes into the lang-team
repository&lt;/a&gt;. I wanted to write a quick update listing out some of
the meetings we&#x27;ve had recently as well as some of our upcoming
meetings.&lt;/p&gt;
&lt;p&gt;This blog post is about the meeting we held on 2020-07-22. We
discussed the idea of creating a &amp;quot;minimal const generics MVP&amp;quot;, as
proposed by boats in &lt;a href&#x3D;&quot;https://without.boats/blog/shipping-const-generics/&quot;&gt;a recent blog
post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can read the &lt;a href&#x3D;&quot;https://github.com/rust-lang/lang-team/blob/master/design-meeting-minutes/2020-07-22-Const-generics-MVP.md&quot;&gt;minutes from the meeting&lt;/a&gt; to learn more details or
to find a link to the recording. In general, though, we were all
pretty excited about the idea. I expect that we will be creating a
project group soon around const generics and that its first goal will
be working towards this MVP.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Opening up the Core Team agenda</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/07/27/opening-up-the-core-team-agenda.html" type="text/html" title="Opening up the Core Team agenda" />
        <published>2020-07-27T00:00:00+00:00</published>
        <updated>2020-07-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/07/27/opening-up-the-core-team-agenda.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/07/27/opening-up-the-core-team-agenda.html">&lt;p&gt;The Core Team works on project-wide policy questions on all sorts of matters,
as well as generally monitoring the overall health of the project. While some
of the discussed topics are sensitive (related to personal issues, finances, or
security) and can’t be shared outside the Core Team, a lot of them are not.&lt;/p&gt;
&lt;p&gt;Much of the activity of the Core Team happens during weekly “triage” calls,
where we discuss and make decisions on the items brought to our attention. Last
year, we started opening up those calls by recording the parts where
non-sensitive topics are discussed and uploading the videos &lt;a href&#x3D;&quot;https://www.youtube.com/playlist?list&#x3D;PL85XCvVPmGQjmo8ivhTMipwQRFl4ZW2cZ&quot;&gt;on our YouTube
channel&lt;/a&gt;. While the videos provide the full context and nuance of the
discussion, they take a good amount of time to watch, and referring to parts of
the discussion is not always practical.&lt;/p&gt;
&lt;p&gt;Continuing with the effort of opening up our meetings, we’re happy to announce
that the public agenda of those calls is now recorded in &lt;a href&#x3D;&quot;https://github.com/rust-lang/core-team/issues&quot;&gt;issues inside the
rust-lang/core-team&lt;/a&gt; repository! Each discussed topic will have its own issue,
and we will provide updates each week with a summary of what we discussed
during the call.&lt;/p&gt;
&lt;p&gt;We hope this setup will allow people to easily follow what’s on the Core Team’s
plate by subscribing to either all the activity in the repository or just to
the issues you care about. We will still continue to publish recordings of the
calls for the people who care to listen to the whole discussion.&lt;/p&gt;
&lt;p&gt;We’ve decided at this time to limit permissions to post on the issues to the
Core Team only, and possibly invited collaborators as relevant to particular
topics. If you have an item you’d like us to discuss or if you have thoughts on
an existing topic, please email &lt;a href&#x3D;&quot;mailto:core-team@rust-lang.org&quot;&gt;core-team@rust-lang.org&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Pietro Albini</name>
        </author>
    </entry>
    
    <entry>
        <title>1.45.1 prerelease testing</title>
        <link rel="alternate" href="https://blog.rust-lang.org/inside-rust/2020/07/27/1.45.1-prerelease.html" type="text/html" title="1.45.1 prerelease testing" />
        <published>2020-07-27T00:00:00+00:00</published>
        <updated>2020-07-27T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/inside-rust/2020/07/27/1.45.1-prerelease.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/inside-rust/2020/07/27/1.45.1-prerelease.html">&lt;p&gt;The 1.45.1 pre-release is ready for testing. The release is scheduled for this
Thursday, the 30th. Release notes can be found here:
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1451-2020-07-30&quot;&gt;https://github.com/rust-lang/rust/blob/stable/RELEASES.md&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can try it out locally with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-plain&quot;&gt;RUSTUP_DIST_SERVER&#x3D;https://dev-static.rust-lang.org rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The index is &lt;a href&#x3D;&quot;https://dev-static.rust-lang.org/dist/2020-07-26/index.html&quot;&gt;https://dev-static.rust-lang.org/dist/2020-07-26/index.html&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Mark Rousskov</name>
        </author>
    </entry>
    
</feed>

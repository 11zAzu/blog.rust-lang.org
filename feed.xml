<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2022-02-03T17:02:36+00:00</updated>

    
    <entry>
        <title>Changes in the Core Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/31/changes-in-the-core-team.html" type="text/html" title="Changes in the Core Team" />
        <published>2022-01-31T00:00:00+00:00</published>
        <updated>2022-01-31T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/31/changes-in-the-core-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/31/changes-in-the-core-team.html">&lt;p&gt;We want to say thanks to three people who recently have decided to step back from the Core Team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Steve Klabnik is leaving the Core Team and the Security Response Working Group.
Steve started with Rust more than 9 years ago.
He was the primary author of the Rust Programming Language book and part of the core team since 2014. He has been running the @rustlang Twitter account and as such formed a lot of the “voice” of the project.
Steve will now be able to focus on &lt;em&gt;using&lt;/em&gt; Rust instead of &lt;em&gt;making&lt;/em&gt; Rust.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Florian Gilcher is stepping back from all of his project positions.&lt;br /&gt;
He became a Core Team observer in 2019 and a full Core Team member in 2020.
He also served as a project director on the Rust foundation board.
Before all of that he was part of the Community Team since 2015.
As he&#x27;s focusing on his company and taking on other business obligations, he is making space for others in the project.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pietro Albini is leaving the Core Team to focus on other parts of the project, including the Infrastructure Team and the Security Response Working Group. He joined the Core Team in late 2019, shortly after becoming a co-lead of the Infrastructure Team, but the amount of work in the Core Team made it hard for him to spend enough time on his other roles in the project.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&#x27;re thankful for Steve&#x27;s, Florian&#x27;s and Pietro&#x27;s contributions to the Core Team &amp;amp; the Rust project in the past and we’re looking forward to any contributions they will still make in the future.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for the standard library (CVE-2022-21658)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html" type="text/html" title="Security advisory for the standard library (CVE-2022-21658)" />
        <published>2022-01-20T00:00:00+00:00</published>
        <updated>2022-01-20T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/R1fZFDhnJVQ&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified that the &lt;code&gt;std::fs::remove_dir_all&lt;/code&gt;
standard library function is vulnerable to a race condition enabling symlink
following (CWE-363). An attacker could use this security issue to trick a
privileged program into deleting files and directories the attacker couldn&#x27;t
otherwise access or delete.&lt;/p&gt;
&lt;p&gt;This issue has been assigned &lt;a href&#x3D;&quot;https://www.cve.org/CVERecord?id&#x3D;CVE-2022-21658&quot;&gt;CVE-2022-21658&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;Let&#x27;s suppose an attacker obtained unprivileged access to a system and needed
to delete a system directory called &lt;code&gt;sensitive/&lt;/code&gt;, but they didn&#x27;t have the
permissions to do so. If &lt;code&gt;std::fs::remove_dir_all&lt;/code&gt; followed symbolic links,
they could find a privileged program that removes a directory they have access
to (called &lt;code&gt;temp/&lt;/code&gt;), create a symlink from &lt;code&gt;temp/foo&lt;/code&gt; to &lt;code&gt;sensitive/&lt;/code&gt;, and wait
for the privileged program to delete &lt;code&gt;foo/&lt;/code&gt;. The privileged program would
follow the symlink from &lt;code&gt;temp/foo&lt;/code&gt; to &lt;code&gt;sensitive/&lt;/code&gt; while recursively deleting,
resulting in &lt;code&gt;sensitive/&lt;/code&gt; being deleted.&lt;/p&gt;
&lt;p&gt;To prevent such attacks, &lt;code&gt;std::fs::remove_dir_all&lt;/code&gt; already includes protection
to avoid recursively deleting symlinks, as described in &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/fs/fn.remove_dir_all.html&quot;&gt;its documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This function does &lt;strong&gt;not&lt;/strong&gt; follow symbolic links and it will simply remove
the symbolic link itself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unfortunately that check was implemented incorrectly in the standard library,
resulting in a TOCTOU (Time-of-check Time-of-use) race condition. Instead of
telling the system not to follow symlinks, the standard library first checked
whether the thing it was about to delete was a symlink, and otherwise it would
proceed to recursively delete the directory.&lt;/p&gt;
&lt;p&gt;This exposed a race condition: an attacker could create a directory and replace
it with a symlink between the check and the actual deletion. While this attack
likely won&#x27;t work the first time it&#x27;s attempted, in our experimentation we were
able to reliably perform it within a couple of seconds.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;Rust 1.0.0 through Rust 1.58.0 is affected by this vulnerability. We&#x27;re going
to release Rust 1.58.1 later today, which will include mitigations for this
vulnerability. Patches to the Rust standard library are also available for
custom-built Rust toolchains &lt;a href&#x3D;&quot;https://github.com/rust-lang/wg-security-response/tree/master/patches/CVE-2022-21658&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that the following targets don&#x27;t have usable APIs to properly mitigate the
attack, and are thus still vulnerable even with a patched toolchain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS before version 10.10 (Yosemite)&lt;/li&gt;
&lt;li&gt;REDOX&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We recommend everyone to update to Rust 1.58.1 as soon as possible, especially
people developing programs expected to run in privileged contexts (including
system daemons and setuid binaries), as those have the highest risk of being
affected by this.&lt;/p&gt;
&lt;p&gt;Note that adding checks in your codebase before calling &lt;code&gt;remove_dir_all&lt;/code&gt; will
&lt;strong&gt;not&lt;/strong&gt; mitigate the vulnerability, as they would also be vulnerable to race
conditions like &lt;code&gt;remove_dir_all&lt;/code&gt; itself. The existing mitigation is working as
intended outside of race conditions.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgments&quot;&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;We want to thank Hans Kratz for independently discovering and disclosing this
issue to us according to the &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;Rust security policy&lt;/a&gt;, for developing the fix
for UNIX-like targets and for reviewing fixes for other platforms.&lt;/p&gt;
&lt;p&gt;We also want to thank Florian Weimer for reviewing the UNIX-like fix and for
reporting the same issue back in 2018, even though the Security Response WG
didn&#x27;t realize the severity of the issue at the time.&lt;/p&gt;
&lt;p&gt;Finally we want to thank Pietro Albini for coordinating the security response
and writing this advisory, Chris Denton for writing the Windows fix, Alex
Crichton for writing the WASI fix, and Mara Bos for reviewing the patches.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.58.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/20/Rust-1.58.1.html" type="text/html" title="Announcing Rust 1.58.1" />
        <published>2022-01-20T00:00:00+00:00</published>
        <updated>2022-01-20T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/20/Rust-1.58.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/20/Rust-1.58.1.html">&lt;p&gt;The Rust team has published a new point release of Rust, 1.58.1. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.58.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1581-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1581-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.58.1 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.58.1 fixes a race condition in the &lt;code&gt;std::fs::remove_dir_all&lt;/code&gt; standard
library function. This security vulnerability is tracked as &lt;a href&#x3D;&quot;https://www.cve.org/CVERecord?id&#x3D;CVE-2022-21658&quot;&gt;CVE-2022-21658&lt;/a&gt;,
and you can read more about it &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html&quot;&gt;on the advisory we published earlier
today&lt;/a&gt;. We recommend all users to update their toolchain immediately
and rebuild their programs with the updated compiler.&lt;/p&gt;
&lt;p&gt;Rust 1.58.1 also addresses several regressions in diagnostics and tooling introduced in Rust 1.58.0:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;non_send_fields_in_send_ty&lt;/code&gt; Clippy lint was discovered to have too many
false positives and has been moved to the experimental lints group (called
&amp;quot;nursery&amp;quot;).&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;useless_format&lt;/code&gt; Clippy lint has been updated to handle captured
identifiers in format strings, introduced in Rust 1.58.0.&lt;/li&gt;
&lt;li&gt;A regression in Rustfmt preventing generated files from being formatted when
passed through the standard input has been fixed.&lt;/li&gt;
&lt;li&gt;An incorrect error message displayed by &lt;code&gt;rustc&lt;/code&gt; in some cases has been fixed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find more detailed information on the specific regressions in the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1581-2022-01-20&quot;&gt;release notes&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1581&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1581&quot;&gt;&lt;/a&gt;Contributors to 1.58.1&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.58.1. We couldn&#x27;t have done it
without all of you. &lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.58.1/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.58.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html" type="text/html" title="Announcing Rust 1.58.0" />
        <published>2022-01-13T00:00:00+00:00</published>
        <updated>2022-01-13T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.58.0.
Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.58.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1580-2022-01-13&quot;&gt;detailed release notes for 1.58.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1580-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1580-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.58.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.58 brings captured identifiers in format strings, a change to the
&lt;code&gt;Command&lt;/code&gt; search path on Windows, more &lt;code&gt;#[must_use]&lt;/code&gt; annotations in the
standard library, and some new library stabilizations.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#captured-identifiers-in-format-strings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;captured-identifiers-in-format-strings&quot;&gt;&lt;/a&gt;Captured identifiers in format strings&lt;/h3&gt;
&lt;p&gt;Format strings can now capture arguments simply by writing &lt;code&gt;{ident}&lt;/code&gt; in the
string. Formats have long accepted positional arguments (optionally by index)
and named arguments, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;println!(&amp;quot;Hello, {}!&amp;quot;, get_person());                // implicit position
println!(&amp;quot;Hello, {0}!&amp;quot;, get_person());               // explicit index
println!(&amp;quot;Hello, {person}!&amp;quot;, person &#x3D; get_person()); // named
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now named arguments can also be captured from the surrounding scope, like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let person &#x3D; get_person();
// ...
println!(&amp;quot;Hello, {person}!&amp;quot;); // captures the local &#x60;person&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This may also be used in formatting parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let (width, precision) &#x3D; get_format();
for (name, score) in get_scores() {
  println!(&amp;quot;{name}: {score:width$.precision$}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Format strings can only capture plain identifiers, not arbitrary paths or
expressions. For more complicated arguments, either assign them to a local name
first, or use the older &lt;code&gt;name &#x3D; expression&lt;/code&gt; style of formatting arguments.&lt;/p&gt;
&lt;p&gt;This feature works in all macros accepting format strings. However, one corner
case is the &lt;code&gt;panic!&lt;/code&gt; macro in 2015 and 2018 editions, where &lt;code&gt;panic!(&amp;quot;{ident}&amp;quot;)&lt;/code&gt;
is still treated as an unformatted string -- the compiler will warn about this
not having the intended effect. Due to the 2021 edition&#x27;s update of panic
macros for &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/edition-guide/rust-2021/panic-macro-consistency.html&quot;&gt;improved consistency&lt;/a&gt;, this works as expected in 2021 &lt;code&gt;panic!&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#reduced-windows-command-search-path&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;reduced-windows-command-search-path&quot;&gt;&lt;/a&gt;Reduced Windows &lt;code&gt;Command&lt;/code&gt; search path&lt;/h3&gt;
&lt;p&gt;On Windows targets, &lt;code&gt;std::process::Command&lt;/code&gt; will no longer search the current
directory for executables. That effect was owed to historical behavior of the
win32 &lt;a href&#x3D;&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa&quot;&gt;&lt;code&gt;CreateProcess&lt;/code&gt;&lt;/a&gt; API, so Rust was effectively searching in this order:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(Rust specific) The directories that are listed in the child&#x27;s &lt;code&gt;PATH&lt;/code&gt;
environment variable, if it was explicitly changed from the parent.&lt;/li&gt;
&lt;li&gt;The directory from which the application loaded.&lt;/li&gt;
&lt;li&gt;The current directory for the parent process.&lt;/li&gt;
&lt;li&gt;The 32-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The 16-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The Windows directory.&lt;/li&gt;
&lt;li&gt;The directories that are listed in the &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, using the current directory can lead to surprising results, or even
malicious behavior when dealing with untrusted directories. For example,
&lt;code&gt;ripgrep&lt;/code&gt; published &lt;a href&#x3D;&quot;https://www.cve.org/CVERecord?id&#x3D;CVE-2021-3013&quot;&gt;CVE-2021-3013&lt;/a&gt; when they learned that their child
processes could be intercepted in this way. Even Microsoft&#x27;s own PowerShell
&lt;a href&#x3D;&quot;https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_command_precedence?view&#x3D;powershell-7.2&quot;&gt;documents&lt;/a&gt; that they do not use the current directory for security.&lt;/p&gt;
&lt;p&gt;Rust now performs its own search without the current directory, and the legacy
16-bit directory is also not included, as there is no API to discover its
location. So the new &lt;code&gt;Command&lt;/code&gt; search order for Rust on Windows is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The directories that are listed in the child&#x27;s &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;li&gt;The directory from which the application loaded.&lt;/li&gt;
&lt;li&gt;The 32-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The Windows directory.&lt;/li&gt;
&lt;li&gt;The directories that are listed in the &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Non-Windows targets continue to use their platform-specific behavior, most
often only considering the child or parent &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#more-must_use-in-the-standard-library&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;more-must_use-in-the-standard-library&quot;&gt;&lt;/a&gt;More &lt;code&gt;#[must_use]&lt;/code&gt; in the standard library&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;#[must_use]&lt;/code&gt; attribute can be applied to types or functions when failing
to explicitly consider them or their output is almost certainly a bug. This has
long been used in the standard library for types like &lt;code&gt;Result&lt;/code&gt;, which should be
checked for error conditions. This also helps catch mistakes such as expecting
a function to mutate a value in-place, when it actually returns a new value.&lt;/p&gt;
&lt;p&gt;Library &lt;a href&#x3D;&quot;https://github.com/rust-lang/libs-team/issues/35&quot;&gt;proposal 35&lt;/a&gt; was approved in October 2021 to audit and expand the
application of &lt;code&gt;#[must_use]&lt;/code&gt; throughout the standard library, covering many
more functions where the primary effect is the return value. This is similar
to the idea of function purity, but looser than a true language feature. Some
of these additions were present in release 1.57.0, and now in 1.58.0 the effort
has completed.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fs/struct.Metadata.html#method.is_symlink&quot;&gt;&lt;code&gt;Metadata::is_symlink&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.is_symlink&quot;&gt;&lt;code&gt;Path::is_symlink&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.saturating_div&quot;&gt;&lt;code&gt;{integer}::saturating_div&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_unchecked&quot;&gt;&lt;code&gt;Option::unwrap_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.unwrap_unchecked&quot;&gt;&lt;code&gt;Result::unwrap_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.unwrap_err_unchecked&quot;&gt;&lt;code&gt;Result::unwrap_err_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.options&quot;&gt;&lt;code&gt;File::options&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.new&quot;&gt;&lt;code&gt;Duration::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_add&quot;&gt;&lt;code&gt;Duration::checked_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_add&quot;&gt;&lt;code&gt;Duration::saturating_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_sub&quot;&gt;&lt;code&gt;Duration::checked_sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_sub&quot;&gt;&lt;code&gt;Duration::saturating_sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_mul&quot;&gt;&lt;code&gt;Duration::checked_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_mul&quot;&gt;&lt;code&gt;Duration::saturating_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_div&quot;&gt;&lt;code&gt;Duration::checked_div&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.58.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1580-2022-01-13&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-158-2022-01-13&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-158&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1580&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1580&quot;&gt;&lt;/a&gt;Contributors to 1.58.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.58.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.58.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Launching the 2021 State of Rust Survey</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/12/08/survey-launch.html" type="text/html" title="Launching the 2021 State of Rust Survey" />
        <published>2021-12-08T00:00:00+00:00</published>
        <updated>2021-12-08T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/12/08/survey-launch.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/12/08/survey-launch.html">&lt;p&gt;It&#x27;s that time again! Time for us to take a look at who the Rust community is composed of, how the Rust project is doing, and how we can improve the Rust programming experience. The Rust Community Team is pleased to announce our &lt;a href&#x3D;&quot;https://surveyhero.com/c/jzesmzph&quot;&gt;2021 State of Rust Survey&lt;/a&gt;! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses, and establish development priorities for the future.&lt;/p&gt;
&lt;p&gt;Completing this survey should take about 10–30 minutes and is anonymous. We will be accepting submissions for the next two weeks (until the 22nd of December), and we will write up our findings afterwards to &lt;a href&#x3D;&quot;https://blog.rust-lang.org&quot;&gt;blog.rust-lang.org&lt;/a&gt;. You can also check out &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html&quot;&gt;last year’s results&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/dauv4jcd&quot;&gt;English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/7rnfv4cf&quot;&gt;Simplified Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/h7guatdt&quot;&gt;Traditional Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/y7hb34nm&quot;&gt;French&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/pq43azn4&quot;&gt;German&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/9pput3ye&quot;&gt;Japanese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/m3bi3nad&quot;&gt;Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/bhdqz3hj&quot;&gt;Portuguese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/xix7rf7d&quot;&gt;Russian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/he7yvafu&quot;&gt;Spanish&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(If you speak multiple languages, please pick one)&lt;/p&gt;
&lt;p&gt;Please help us spread the word by sharing the survey link on your social network feeds, at meetups, around your office, and in other communities.&lt;/p&gt;
&lt;p&gt;If you have any questions, please see our &lt;a href&#x3D;&quot;https://github.com/rust-lang/surveys/blob/main/documents/Community-Survey-FAQ.md&quot;&gt;frequently asked questions&lt;/a&gt; or email the Rust Community team at &lt;a href&#x3D;&quot;mailto:community-team@rust-lang.org&quot;&gt;community-team@rust-lang.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, we wanted to thank everyone who helped develop, polish, and test the survey. In particular, we&#x27;d like to thank all of the volunteers who worked to provide all of the translations available this year and who will help to translate the results.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Community Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.57.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html" type="text/html" title="Announcing Rust 1.57.0" />
        <published>2021-12-02T00:00:00+00:00</published>
        <updated>2021-12-02T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.57.0.
Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.57.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1570-2021-12-02&quot;&gt;detailed release notes for 1.57.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1570-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1570-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.57.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.57 brings &lt;code&gt;panic!&lt;/code&gt; to const contexts, adds support for custom profiles to Cargo, and stabilizes fallible reservation APIs.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#panic-in-const-contexts&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;panic-in-const-contexts&quot;&gt;&lt;/a&gt;&lt;code&gt;panic!&lt;/code&gt; in const contexts&lt;/h3&gt;
&lt;p&gt;With previous versions of Rust, the &lt;code&gt;panic!&lt;/code&gt; macro was not usable in &lt;code&gt;const fn&lt;/code&gt; and other compile-time contexts. Now, this has been stabilized. Together with the stabilization of &lt;code&gt;panic!&lt;/code&gt;, several other standard library APIs are now usable in const, such as &lt;code&gt;assert!&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This stabilization does not yet include the full formatting infrastructure, so the &lt;code&gt;panic!&lt;/code&gt; macro must be called with either a static string (&lt;code&gt;panic!(&amp;quot;...&amp;quot;)&lt;/code&gt;), or with a single &lt;code&gt;&amp;amp;str&lt;/code&gt; interpolated value (&lt;code&gt;panic!(&amp;quot;{}&amp;quot;, a)&lt;/code&gt;) which must be used with &lt;code&gt;{}&lt;/code&gt; (no format specifiers or other traits).&lt;/p&gt;
&lt;p&gt;It is expected that in the future this support will expand, but this minimal stabilization already enables straightforward compile-time assertions, for example to verify the size of a type:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;const _: () &#x3D; assert!(std::mem::size_of::&amp;lt;u64&amp;gt;() &#x3D;&#x3D; 8);
const _: () &#x3D; assert!(std::mem::size_of::&amp;lt;u8&amp;gt;() &#x3D;&#x3D; 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-support-for-custom-profiles&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-support-for-custom-profiles&quot;&gt;&lt;/a&gt;Cargo support for custom profiles&lt;/h3&gt;
&lt;p&gt;Cargo has long supported four profiles: &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;release&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, and &lt;code&gt;bench&lt;/code&gt;. With Rust 1.57, support has been added for arbitrarily named profiles.&lt;/p&gt;
&lt;p&gt;For example, if you want to enable link time optimizations (&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#lto&quot;&gt;LTO&lt;/a&gt;) only when making the final production build, adding the following snippet to Cargo.toml enables the &lt;code&gt;lto&lt;/code&gt; flag when this profile is selected, but avoids enabling it for regular release builds.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[profile.production]
inherits &#x3D; &amp;quot;release&amp;quot;
lto &#x3D; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that custom profiles must specify a profile from which they inherit default settings. Once the profile has been defined, Cargo commands which build code can be asked to use it with &lt;code&gt;--profile production&lt;/code&gt;. Currently, this will build artifacts in a separate directory (&lt;code&gt;target/production&lt;/code&gt; in this case), which means that artifacts are not shared between directories.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#fallible-allocation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;fallible-allocation&quot;&gt;&lt;/a&gt;Fallible allocation&lt;/h3&gt;
&lt;p&gt;Rust 1.57 stabilizes &lt;code&gt;try_reserve&lt;/code&gt; for &lt;code&gt;Vec&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;HashSet&lt;/code&gt;, and &lt;code&gt;VecDeque&lt;/code&gt;. This API enables callers to fallibly allocate the backing storage for these types.&lt;/p&gt;
&lt;p&gt;Rust will usually abort the process if the global allocator fails, which is not always desirable. This API provides a method for avoiding that abort when working with the standard library collections. However, Rust does not guarantee that the returned memory is actually allocated by the kernel: for example, if overcommit is enabled on Linux, the memory may not be available when its use is attempted.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.array.html#method.as_mut_slice&quot;&gt;&lt;code&gt;[T; N]::as_mut_slice&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.array.html#method.as_slice&quot;&gt;&lt;code&gt;[T; N]::as_slice&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.TryReserveError.html&quot;&gt;&lt;code&gt;collections::TryReserveError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.try_reserve&quot;&gt;&lt;code&gt;HashMap::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html#method.try_reserve&quot;&gt;&lt;code&gt;HashSet::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/alloc/string/struct.String.html#method.try_reserve&quot;&gt;&lt;code&gt;String::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/alloc/string/struct.String.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;String::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve&quot;&gt;&lt;code&gt;Vec::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;Vec::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.try_reserve&quot;&gt;&lt;code&gt;VecDeque::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;VecDeque::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map_while&quot;&gt;&lt;code&gt;Iterator::map_while&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/iter/struct.MapWhile.html&quot;&gt;&lt;code&gt;iter::MapWhile&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/proc_macro/fn.is_available.html&quot;&gt;&lt;code&gt;proc_macro::is_available&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.Command.html#method.get_program&quot;&gt;&lt;code&gt;Command::get_program&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.Command.html#method.get_args&quot;&gt;&lt;code&gt;Command::get_args&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.Command.html#method.get_envs&quot;&gt;&lt;code&gt;Command::get_envs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.Command.html#method.get_current_dir&quot;&gt;&lt;code&gt;Command::get_current_dir&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.CommandArgs.html&quot;&gt;&lt;code&gt;CommandArgs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.CommandEnvs.html&quot;&gt;&lt;code&gt;CommandEnvs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html&quot;&gt;&lt;code&gt;hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.57.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1570-2021-12-02&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-157-2021-12-02&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-157&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1570&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1570&quot;&gt;&lt;/a&gt;Contributors to 1.57.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.57.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.57.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for rustc (CVE-2021-42574)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html" type="text/html" title="Security advisory for rustc (CVE-2021-42574)" />
        <published>2021-11-01T00:00:00+00:00</published>
        <updated>2021-11-01T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html">&lt;blockquote&gt;
&lt;p&gt;This is a lightly edited cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/bKPH8XYMvJU&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified of a security concern affecting
source code containing &amp;quot;bidirectional override&amp;quot; Unicode codepoints: in some
cases the use of those codepoints could lead to the reviewed code being
different than the compiled code.&lt;/p&gt;
&lt;p&gt;This is an issue with how source code may be rendered in certain contexts, and
its assigned identifier is &lt;a href&#x3D;&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name&#x3D;CVE-2021-42574&quot;&gt;CVE-2021-42574&lt;/a&gt;. While the issue itself is not a flaw
in rustc, we&#x27;re taking proactive measures to mitigate its impact on Rust developers.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;Unicode has support for both left-to-right and right-to-left languages, and to
aid writing left-to-right words inside a right-to-left sentence (or vice versa)
it also features invisible codepoints called &amp;quot;bidirectional override&amp;quot;.&lt;/p&gt;
&lt;p&gt;These codepoints are normally used across the Internet to embed a word inside a
sentence of another language (with a different text direction), but it was
reported to us that they could be used to manipulate how source code is
displayed in some editors and code review tools, leading to the reviewed code
being different than the compiled code. This is especially bad if the whole
team relies on bidirectional-aware tooling.&lt;/p&gt;
&lt;p&gt;As an example, the following snippet (with &lt;code&gt;{U+NNNN}&lt;/code&gt; replaced with the Unicode
codepoint &lt;code&gt;NNNN&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;if access_level !&#x3D; &amp;quot;user{U+202E} {U+2066}// Check if admin{U+2069} {U+2066}&amp;quot; {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...would be rendered by bidirectional-aware tools as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;if access_level !&#x3D; &amp;quot;user&amp;quot; { // Check if admin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;Rust 1.56.1 introduces two new lints to detect and reject code containing the
affected codepoints. Rust 1.0.0 through Rust 1.56.0 do not include such lints,
leaving your source code vulnerable to this attack if you do not perform
out-of-band checks for the presence of those codepoints.&lt;/p&gt;
&lt;p&gt;To assess the security of the ecosystem we analyzed all crate versions ever
published on crates.io (as of 2021-10-17), and only 5 crates have the affected
codepoints in their source code, with none of the occurrences being malicious.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We will be releasing Rust 1.56.1 today, 2021-11-01, with two new
deny-by-default lints detecting the affected codepoints, respectively in string
literals and in comments. The lints will prevent source code files containing
those codepoints from being compiled, protecting you from the attack.&lt;/p&gt;
&lt;p&gt;If your code has legitimate uses for the codepoints we recommend replacing them
with the related escape sequence. The error messages will suggest the right
escapes to use.&lt;/p&gt;
&lt;p&gt;If you can&#x27;t upgrade your compiler version, or your codebase also includes
non-Rust source code files, we recommend periodically checking that the
following codepoints are not present in your repository and your dependencies:
U+202A, U+202B, U+202C, U+202D, U+202E, U+2066, U+2067, U+2068, U+2069.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#timeline-of-events&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;timeline-of-events&quot;&gt;&lt;/a&gt;Timeline of events&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2021-07-25: we received the report and started working on a fix.&lt;/li&gt;
&lt;li&gt;2021-09-14: the date for the embargo lift (2021-11-01) is communicated to us.&lt;/li&gt;
&lt;li&gt;2021-10-17: performed an analysis of all the source code ever published to
crates.io to check for the presence of this attack.&lt;/li&gt;
&lt;li&gt;2021-11-01: embargo lifts, the vulnerability is disclosed and Rust 1.56.1 is
released.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgments&quot;&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a href&#x3D;&quot;https://github.com/nickboucher&quot;&gt;Nicholas Boucher&lt;/a&gt; and &lt;a href&#x3D;&quot;https://www.cl.cam.ac.uk/~rja14&quot;&gt;Ross Anderson&lt;/a&gt; from the University of
Cambridge for disclosing this to us according to our &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;security policy&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We also want to thank the members of the Rust project who contributed to the
mitigations for this issue. Thanks to Esteban Küber for developing the lints,
Pietro Albini for leading the security response, and many others for their
involvement, insights and feedback: Josh Stone, Josh Triplett, Manish
Goregaokar, Mara Bos, Mark Rousskov, Niko Matsakis, and Steve Klabnik.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#appendix-homoglyph-attacks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;appendix-homoglyph-attacks&quot;&gt;&lt;/a&gt;Appendix: Homoglyph attacks&lt;/h2&gt;
&lt;p&gt;As part of their research, Nicholas Boucher and Ross Anderson also uncovered a
similar security issue identified as &lt;a href&#x3D;&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name&#x3D;CVE-2021-42694&quot;&gt;CVE-2021-42694&lt;/a&gt; involving homoglyphs inside
identifiers. Rust already includes mitigations for that attack since Rust
1.53.0. Rust 1.0.0 through Rust 1.52.1 is not affected due to the lack of
support for non-ASCII identifiers in those releases.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.56.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/11/01/Rust-1.56.1.html" type="text/html" title="Announcing Rust 1.56.1" />
        <published>2021-11-01T00:00:00+00:00</published>
        <updated>2021-11-01T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/2021/11/01/Rust-1.56.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/11/01/Rust-1.56.1.html">&lt;p&gt;The Rust team has published a new point release of Rust, 1.56.1. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.56.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1561-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1561-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.56.1 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.56.1 introduces two new lints to mitigate the impact of a security
concern recently disclosed, &lt;a href&#x3D;&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name&#x3D;CVE-2021-42574&quot;&gt;CVE-2021-42574&lt;/a&gt;. We recommend all users upgrade
immediately to ensure their codebase is not affected by the security issue.&lt;/p&gt;
&lt;p&gt;You can learn more about the security issue in &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html&quot;&gt;the advisory&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.56.0 and Rust 2021</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html" type="text/html" title="Announcing Rust 1.56.0 and Rust 2021" />
        <published>2021-10-21T00:00:00+00:00</published>
        <updated>2021-10-21T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.56.0. This stabilizes the 2021 edition as well.
Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.56.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1560-2021-10-21&quot;&gt;detailed release notes for 1.56.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1560-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1560-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.56.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#rust-2021&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-2021&quot;&gt;&lt;/a&gt;Rust 2021&lt;/h3&gt;
&lt;p&gt;We wrote about plans for the Rust 2021 Edition &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/05/11/edition-2021.html&quot;&gt;in May&lt;/a&gt;.
Editions are a mechanism for opt-in changes that may otherwise pose backwards compatibility risk. See &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/edition-guide/editions/index.html&quot;&gt;the edition guide&lt;/a&gt; for details on how this is achieved.
This is a smaller edition, especially compared to 2018, but there
are still some nice quality-of-life changes that require an edition opt-in to
avoid breaking some corner cases in existing code. See the new chapters of the
edition guide below for more details on each new feature and guidance for
migration.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html&quot;&gt;Disjoint capture&lt;/a&gt;: closures now capture individual named fields rather than always capturing whole identifiers.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt; for arrays&lt;/a&gt;: &lt;code&gt;array.into_iter()&lt;/code&gt; now iterates over items by value instead of by reference.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/or-patterns-macro-rules.html&quot;&gt;Or patterns in macro-rules&lt;/a&gt; now match top-level &lt;code&gt;A|B&lt;/code&gt; in &lt;code&gt;:pat&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/default-cargo-resolver.html&quot;&gt;Default Cargo feature resolver&lt;/a&gt; is now version 2.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/prelude.html&quot;&gt;Additions to the prelude&lt;/a&gt;: &lt;code&gt;TryInto&lt;/code&gt;, &lt;code&gt;TryFrom&lt;/code&gt;, and &lt;code&gt;FromIterator&lt;/code&gt; are now in scope by default.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/panic-macro-consistency.html&quot;&gt;Panic macros&lt;/a&gt; now always expect format strings, just like &lt;code&gt;println!()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/reserving-syntax.html&quot;&gt;Reserving syntax&lt;/a&gt; for &lt;code&gt;ident#&lt;/code&gt;, &lt;code&gt;ident&amp;quot;...&amp;quot;&lt;/code&gt;, and &lt;code&gt;ident&#x27;...&#x27;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/warnings-promoted-to-error.html&quot;&gt;Warnings promoted to errors&lt;/a&gt;: &lt;code&gt;bare_trait_objects&lt;/code&gt; and &lt;code&gt;ellipsis_inclusive_range_patterns&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#disjoint-capture-in-closures&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;disjoint-capture-in-closures&quot;&gt;&lt;/a&gt;Disjoint capture in closures&lt;/h4&gt;
&lt;p&gt;Closures automatically capture values or references to identifiers that are
used in the body, but before 2021, they were always captured as a whole. The new
disjoint-capture feature will likely simplify the way you write closures, so
let&#x27;s look at a quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// 2015 or 2018 edition code
let a &#x3D; SomeStruct::new();

// Move out of one field of the struct
drop(a.x);

// Ok: Still use another field of the struct
println!(&amp;quot;{}&amp;quot;, a.y);

// Error: Before 2021 edition, tries to capture all of &#x60;a&#x60;
let c &#x3D; || println!(&amp;quot;{}&amp;quot;, a.y);
c();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix this, you would have had to extract something like &lt;code&gt;let y &#x3D; &amp;amp;a.y;&lt;/code&gt;
manually before the closure to limit its capture. Starting in Rust 2021,
closures will automatically capture only the fields that they use, so the
above example will compile fine!&lt;/p&gt;
&lt;p&gt;This new behavior is only activated in the new edition, since it can change
the order in which fields are dropped. As for all edition changes, an
automatic migration is available, which will update your closures for which
this matters by inserting &lt;code&gt;let _ &#x3D; &amp;amp;a;&lt;/code&gt; inside the closure to force the
entire struct to be captured as before.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#migrating-to-2021&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;migrating-to-2021&quot;&gt;&lt;/a&gt;Migrating to 2021&lt;/h4&gt;
&lt;p&gt;The guide includes migration instructions for all new features, and in general
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html&quot;&gt;transitioning an existing project to a new edition&lt;/a&gt;.
In many cases &lt;code&gt;cargo fix&lt;/code&gt; can automate the necessary changes. You may even
find that no changes in your code are needed at all for 2021!&lt;/p&gt;
&lt;p&gt;However small this edition appears on the surface, it&#x27;s still the product
of a lot of hard work from many contributors: see our dedicated
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/88623&quot;&gt;celebration and thanks&lt;/a&gt; tracker!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-rust-version&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-rust-version&quot;&gt;&lt;/a&gt;Cargo &lt;code&gt;rust-version&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cargo.toml&lt;/code&gt; now supports a &lt;code&gt;[package]&lt;/code&gt; &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field&quot;&gt;&lt;code&gt;rust-version&lt;/code&gt;&lt;/a&gt; field to specify
the minimum supported Rust version for a crate, and Cargo will exit with an
early error if that is not satisfied. This doesn&#x27;t currently influence the
dependency resolver, but the idea is to catch compatibility problems before
they turn into cryptic compiler errors.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#new-bindings-in-binding--pattern&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;new-bindings-in-binding--pattern&quot;&gt;&lt;/a&gt;New bindings in &lt;code&gt;binding @ pattern&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Rust pattern matching can be written with a single identifier that binds
the entire value, followed by &lt;code&gt;@&lt;/code&gt; and a more refined structural pattern,
but this has not allowed additional bindings in that pattern -- until now!&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct Matrix {
    data: Vec&amp;lt;f64&amp;gt;,
    row_len: usize,
}

// Before, we need separate statements to bind
// the whole struct and also read its parts.
let matrix &#x3D; get_matrix();
let row_len &#x3D; matrix.row_len;
// or with a destructuring pattern:
let Matrix { row_len, .. } &#x3D; matrix;

// Rust 1.56 now lets you bind both at once!
let matrix @ Matrix { row_len, .. } &#x3D; get_matrix();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This actually was allowed in the days before Rust 1.0, but that was removed
due to known &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/16053&quot;&gt;unsoundness&lt;/a&gt; at
the time. With the evolution of the borrow checker since that time, and with
heavy testing, the compiler team determined that this was safe to finally
allow in stable Rust!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/fs/fn.chroot.html&quot;&gt;&lt;code&gt;std::os::unix::fs::chroot&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html#method.raw_get&quot;&gt;&lt;code&gt;UnsafeCell::raw_get&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/struct.BufWriter.html#method.into_parts&quot;&gt;&lt;code&gt;BufWriter::into_parts&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/84662&quot;&gt;&lt;code&gt;core::panic::{UnwindSafe, RefUnwindSafe, AssertUnwindSafe}&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
(previously only in &lt;code&gt;std&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;Vec::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/string/struct.String.html#method.shrink_to&quot;&gt;&lt;code&gt;String::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.shrink_to&quot;&gt;&lt;code&gt;OsString::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.shrink_to&quot;&gt;&lt;code&gt;PathBuf::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.shrink_to&quot;&gt;&lt;code&gt;BinaryHeap::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.shrink_to&quot;&gt;&lt;code&gt;VecDeque::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/hash_map/struct.HashMap.html#method.shrink_to&quot;&gt;&lt;code&gt;HashMap::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html#method.shrink_to&quot;&gt;&lt;code&gt;HashSet::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/fn.transmute.html&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.first&quot;&gt;&lt;code&gt;[T]::first&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_first&quot;&gt;&lt;code&gt;[T]::split_first&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.last&quot;&gt;&lt;code&gt;[T]::last&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_last&quot;&gt;&lt;code&gt;[T]::split_last&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.56.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1560-2021-10-21&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-156-2021-10-21&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-156&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1560&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1560&quot;&gt;&lt;/a&gt;Contributors to 1.56.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.56.0 and the 2021 edition.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.56.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Core team membership updates</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/09/27/Core-team-membership-updates.html" type="text/html" title="Core team membership updates" />
        <published>2021-09-27T00:00:00+00:00</published>
        <updated>2021-09-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/09/27/Core-team-membership-updates.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/09/27/Core-team-membership-updates.html">&lt;p&gt;The Rust Core team is excited to announce the first of a series of changes to
its structure we’ve been planning for 2021, starting today by adding several new
members.&lt;/p&gt;
&lt;p&gt;Originally, the Core team was composed of the leads from each Rust team.
However, as Rust has grown, this has long stopped being true; most members of
the Core team are not team leads in the project. In part, this is because Core’s
duties have evolved significantly away from the original technical focus. Today,
we see the Core team’s purpose as enabling, amplifying, and supporting the
excellent work of every Rust team. Notably, this included setting up and
&lt;a href&#x3D;&quot;https://foundation.rust-lang.org/posts/2021-02-08-hello-world/&quot;&gt;launching the Rust Foundation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We know that our maintainers, and especially team leads, dedicate an enormous
amount of time to their work on Rust. We care deeply that it’s possible for not
just people working full time on Rust to be leaders, but that part time
volunteers can as well. To enable this, we wish to avoid coupling leading a team
with a commitment to stewarding the project as a whole as part of the Core team.
Likewise, it is important that members of the Core team have the option to
dedicate their time to just the Core team’s activities and serve the project in
that capacity only.&lt;/p&gt;
&lt;p&gt;Early in the Rust project, composition of the Core team was made up of almost
entirely Mozilla employees working full time on Rust. Because this team was made
up of team leads, it follows that team leads were also overwhelmingly composed
of Mozilla employees. As Rust has grown, folks previously employed at Mozilla
left for new jobs and new folks appeared. Many of the new folks were not
employed to work on Rust full time so the collective time investment was
decreased and the shape of the core team’s work schedule shifted from 9-5 to a
more volunteer cadence.  Currently, the Core team is composed largely of
volunteers, and no member of the Core team is employed full time to work on
their Core team duties.&lt;/p&gt;
&lt;p&gt;We know that it’s critical to driving this work successfully to have
stakeholders on the team who are actively working in all areas of the project to
help prioritize the Core team’s initiatives. To serve this goal, we are
announcing some changes to the Core team’s membership today: Ryan Levick,
Jan-Erik Rediger, and JT are joining the Core team. To give some context on
their backgrounds and experiences, each new member has written up a brief
introduction.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rylev&quot;&gt;Ryan Levick&lt;/a&gt; began exploring Rust in 2014 always
looking for more and more ways to be involved in the community. Over time he
participated more by co-organizing the Berlin Rust meetup, doing YouTube
tutorials, helping with various project efforts, and more. In 2019, Ryan got
the opportunity to work with Rust full time leading developer advocacy for
Rust at Microsoft and helping build up the case for Rust as an official
language inside of Microsoft. Nowadays he’s an active Rust project member with
some of the highlights including working in the compiler perf team, running
the Rust annual survey, and helping the 2021 edition effort.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/badboy&quot;&gt;Jan-Erik Rediger&lt;/a&gt; started working with Rust
sometime in late 2014 and has been a member of the Rust Community Team since
2016. That same year he co-founded RustFest, one of the first conferences
dedicated to Rust. In the following years seven RustFest conferences have
brought together hundreds of Rust community members all around Europe and
more recently online.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/jntrnr&quot;&gt;JT&lt;/a&gt; has 15 years of programming language
experience. During that time, JT worked at Cray on the Chapel programming
language and at Apple on LLVM/Clang.  In 2012, they joined Microsoft as part
of the TypeScript core team, where they helped to finish and release
TypeScript to the world. They stayed on for over three years, helping direct
TypeScript and grow its community. From there, they joined Mozilla to work on
Rust, where they brought their experience with TypeScript to help the Rust
project transition from a research language to an industrial language. During
this time, they co-created the new Rust compiler error message format and the
Rust Language Server. Their most recent work is with Nushell, a programming
language implemented in Rust.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These new additions will add fresh perspectives along several axes, including
geographic and employment diversity. However, we recognize there are aspects of
diversity we can continue to improve. We see this work as critical to the
ongoing health of the Rust project and is part of the work that will be
coordinated between the Rust core team and the Rust Foundation.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/Manishearth&quot;&gt;Manish Goregaokar&lt;/a&gt; is also leaving the team to be able
to focus better on the dev-tools team. Combining team leadership with Core team
duties is a heavy burden. While Manish has enjoyed his time working on
project-wide initiatives, this coupling isn’t quite fair to the needs of the
devtools team, and he’s glad to be able to spend more time on the devtools team
moving forward.&lt;/p&gt;
&lt;p&gt;The Core team has been doing a lot of work in figuring out how to improve how we
work and how we interface with the rest of the project. We’re excited to be able
to share more on this in future updates.&lt;/p&gt;
&lt;p&gt;We&#x27;re super excited for Manish’s renewed efforts on the dev tools team and for
JT, Ryan, and Jan-Erik to get started on core team work! Congrats and good luck!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This post is part 1 of a multi-part series on updates to the Rust core team.&lt;/em&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
</feed>

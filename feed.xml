<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2022-01-13T20:32:28+00:00</updated>

    
    <entry>
        <title>Announcing Rust 1.58.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html" type="text/html" title="Announcing Rust 1.58.0" />
        <published>2022-01-13T00:00:00+00:00</published>
        <updated>2022-01-13T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.58.0.
Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.58.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1580-2022-01-13&quot;&gt;detailed release notes for 1.58.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1580-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1580-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.58.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.58 brings captured identifiers in format strings, a change to the
&lt;code&gt;Command&lt;/code&gt; search path on Windows, more &lt;code&gt;#[must_use]&lt;/code&gt; annotations in the
standard library, and some new library stabilizations.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#captured-identifiers-in-format-strings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;captured-identifiers-in-format-strings&quot;&gt;&lt;/a&gt;Captured identifiers in format strings&lt;/h3&gt;
&lt;p&gt;Format strings can now capture arguments simply by writing &lt;code&gt;{ident}&lt;/code&gt; in the
string. Formats have long accepted positional arguments (optionally by index)
and named arguments, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;println!(&amp;quot;Hello, {}!&amp;quot;, get_person());                // implicit position
println!(&amp;quot;Hello, {0}!&amp;quot;, get_person());               // explicit index
println!(&amp;quot;Hello, {person}!&amp;quot;, person &#x3D; get_person()); // named
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now named arguments can also be captured from the surrounding scope, like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let person &#x3D; get_person();
// ...
println!(&amp;quot;Hello, {person}!&amp;quot;); // captures the local &#x60;person&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This may also be used in formatting parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let (width, precision) &#x3D; get_format();
for (name, score) in get_scores() {
  println!(&amp;quot;{name}: {score:width$.precision$}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Format strings can only capture plain identifiers, not arbitrary paths or
expressions. For more complicated arguments, either assign them to a local name
first, or use the older &lt;code&gt;name &#x3D; expression&lt;/code&gt; style of formatting arguments.&lt;/p&gt;
&lt;p&gt;This feature works in all macros accepting format strings. However, one corner
case is the &lt;code&gt;panic!&lt;/code&gt; macro in 2015 and 2018 editions, where &lt;code&gt;panic!(&amp;quot;{ident}&amp;quot;)&lt;/code&gt;
is still treated as an unformatted string -- the compiler will warn about this
not having the intended effect. Due to the 2021 edition&#x27;s update of panic
macros for &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/edition-guide/rust-2021/panic-macro-consistency.html&quot;&gt;improved consistency&lt;/a&gt;, this works as expected in 2021 &lt;code&gt;panic!&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#reduced-windows-command-search-path&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;reduced-windows-command-search-path&quot;&gt;&lt;/a&gt;Reduced Windows &lt;code&gt;Command&lt;/code&gt; search path&lt;/h3&gt;
&lt;p&gt;On Windows targets, &lt;code&gt;std::process::Command&lt;/code&gt; will no longer search the current
directory for executables. That effect was owed to historical behavior of the
win32 &lt;a href&#x3D;&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa&quot;&gt;&lt;code&gt;CreateProcess&lt;/code&gt;&lt;/a&gt; API, so Rust was effectively searching in this order:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(Rust specific) The directories that are listed in the child&#x27;s &lt;code&gt;PATH&lt;/code&gt;
environment variable, if it was explicitly changed from the parent.&lt;/li&gt;
&lt;li&gt;The directory from which the application loaded.&lt;/li&gt;
&lt;li&gt;The current directory for the parent process.&lt;/li&gt;
&lt;li&gt;The 32-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The 16-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The Windows directory.&lt;/li&gt;
&lt;li&gt;The directories that are listed in the &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, using the current directory can lead to surprising results, or even
malicious behavior when dealing with untrusted directories. For example,
&lt;code&gt;ripgrep&lt;/code&gt; published &lt;a href&#x3D;&quot;https://www.cve.org/CVERecord?id&#x3D;CVE-2021-3013&quot;&gt;CVE-2021-3013&lt;/a&gt; when they learned that their child
processes could be intercepted in this way. Even Microsoft&#x27;s own PowerShell
&lt;a href&#x3D;&quot;https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_command_precedence?view&#x3D;powershell-7.2&quot;&gt;documents&lt;/a&gt; that they do not use the current directory for security.&lt;/p&gt;
&lt;p&gt;Rust now performs its own search without the current directory, and the legacy
16-bit directory is also not included, as there is no API to discover its
location. So the new &lt;code&gt;Command&lt;/code&gt; search order for Rust on Windows is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The directories that are listed in the child&#x27;s &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;li&gt;The directory from which the application loaded.&lt;/li&gt;
&lt;li&gt;The 32-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The Windows directory.&lt;/li&gt;
&lt;li&gt;The directories that are listed in the &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Non-Windows targets continue to use their platform-specific behavior, most
often only considering the child or parent &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#more-must_use-in-the-standard-library&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;more-must_use-in-the-standard-library&quot;&gt;&lt;/a&gt;More &lt;code&gt;#[must_use]&lt;/code&gt; in the standard library&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;#[must_use]&lt;/code&gt; attribute can be applied to types or functions when failing
to explicitly consider them or their output is almost certainly a bug. This has
long been used in the standard library for types like &lt;code&gt;Result&lt;/code&gt;, which should be
checked for error conditions. This also helps catch mistakes such as expecting
a function to mutate a value in-place, when it actually returns a new value.&lt;/p&gt;
&lt;p&gt;Library &lt;a href&#x3D;&quot;https://github.com/rust-lang/libs-team/issues/35&quot;&gt;proposal 35&lt;/a&gt; was approved in October 2021 to audit and expand the
application of &lt;code&gt;#[must_use]&lt;/code&gt; throughout the standard library, covering many
more functions where the primary effect is the return value. This is similar
to the idea of function purity, but looser than a true language feature. Some
of these additions were present in release 1.57.0, and now in 1.58.0 the effort
has completed.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fs/struct.Metadata.html#method.is_symlink&quot;&gt;&lt;code&gt;Metadata::is_symlink&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.is_symlink&quot;&gt;&lt;code&gt;Path::is_symlink&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.saturating_div&quot;&gt;&lt;code&gt;{integer}::saturating_div&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_unchecked&quot;&gt;&lt;code&gt;Option::unwrap_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.unwrap_unchecked&quot;&gt;&lt;code&gt;Result::unwrap_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.unwrap_err_unchecked&quot;&gt;&lt;code&gt;Result::unwrap_err_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.options&quot;&gt;&lt;code&gt;File::options&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.new&quot;&gt;&lt;code&gt;Duration::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_add&quot;&gt;&lt;code&gt;Duration::checked_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_add&quot;&gt;&lt;code&gt;Duration::saturating_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_sub&quot;&gt;&lt;code&gt;Duration::checked_sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_sub&quot;&gt;&lt;code&gt;Duration::saturating_sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_mul&quot;&gt;&lt;code&gt;Duration::checked_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_mul&quot;&gt;&lt;code&gt;Duration::saturating_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_div&quot;&gt;&lt;code&gt;Duration::checked_div&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.58.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1580-2022-01-13&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-158-2022-01-13&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-158&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1580&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1580&quot;&gt;&lt;/a&gt;Contributors to 1.58.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.58.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.58.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Launching the 2021 State of Rust Survey</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/12/08/survey-launch.html" type="text/html" title="Launching the 2021 State of Rust Survey" />
        <published>2021-12-08T00:00:00+00:00</published>
        <updated>2021-12-08T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/12/08/survey-launch.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/12/08/survey-launch.html">&lt;p&gt;It&#x27;s that time again! Time for us to take a look at who the Rust community is composed of, how the Rust project is doing, and how we can improve the Rust programming experience. The Rust Community Team is pleased to announce our &lt;a href&#x3D;&quot;https://surveyhero.com/c/jzesmzph&quot;&gt;2021 State of Rust Survey&lt;/a&gt;! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses, and establish development priorities for the future.&lt;/p&gt;
&lt;p&gt;Completing this survey should take about 10–30 minutes and is anonymous. We will be accepting submissions for the next two weeks (until the 22nd of December), and we will write up our findings afterwards to &lt;a href&#x3D;&quot;https://blog.rust-lang.org&quot;&gt;blog.rust-lang.org&lt;/a&gt;. You can also check out &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html&quot;&gt;last year’s results&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/dauv4jcd&quot;&gt;English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/7rnfv4cf&quot;&gt;Simplified Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/h7guatdt&quot;&gt;Traditional Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/y7hb34nm&quot;&gt;French&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/pq43azn4&quot;&gt;German&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/9pput3ye&quot;&gt;Japanese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/m3bi3nad&quot;&gt;Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/bhdqz3hj&quot;&gt;Portuguese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/xix7rf7d&quot;&gt;Russian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/he7yvafu&quot;&gt;Spanish&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(If you speak multiple languages, please pick one)&lt;/p&gt;
&lt;p&gt;Please help us spread the word by sharing the survey link on your social network feeds, at meetups, around your office, and in other communities.&lt;/p&gt;
&lt;p&gt;If you have any questions, please see our &lt;a href&#x3D;&quot;https://github.com/rust-lang/surveys/blob/main/documents/Community-Survey-FAQ.md&quot;&gt;frequently asked questions&lt;/a&gt; or email the Rust Community team at &lt;a href&#x3D;&quot;mailto:community-team@rust-lang.org&quot;&gt;community-team@rust-lang.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, we wanted to thank everyone who helped develop, polish, and test the survey. In particular, we&#x27;d like to thank all of the volunteers who worked to provide all of the translations available this year and who will help to translate the results.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Community Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.57.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html" type="text/html" title="Announcing Rust 1.57.0" />
        <published>2021-12-02T00:00:00+00:00</published>
        <updated>2021-12-02T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/12/02/Rust-1.57.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.57.0.
Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.57.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1570-2021-12-02&quot;&gt;detailed release notes for 1.57.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1570-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1570-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.57.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.57 brings &lt;code&gt;panic!&lt;/code&gt; to const contexts, adds support for custom profiles to Cargo, and stabilizes fallible reservation APIs.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#panic-in-const-contexts&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;panic-in-const-contexts&quot;&gt;&lt;/a&gt;&lt;code&gt;panic!&lt;/code&gt; in const contexts&lt;/h3&gt;
&lt;p&gt;With previous versions of Rust, the &lt;code&gt;panic!&lt;/code&gt; macro was not usable in &lt;code&gt;const fn&lt;/code&gt; and other compile-time contexts. Now, this has been stabilized. Together with the stabilization of &lt;code&gt;panic!&lt;/code&gt;, several other standard library APIs are now usable in const, such as &lt;code&gt;assert!&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This stabilization does not yet include the full formatting infrastructure, so the &lt;code&gt;panic!&lt;/code&gt; macro must be called with either a static string (&lt;code&gt;panic!(&amp;quot;...&amp;quot;)&lt;/code&gt;), or with a single &lt;code&gt;&amp;amp;str&lt;/code&gt; interpolated value (&lt;code&gt;panic!(&amp;quot;{}&amp;quot;, a)&lt;/code&gt;) which must be used with &lt;code&gt;{}&lt;/code&gt; (no format specifiers or other traits).&lt;/p&gt;
&lt;p&gt;It is expected that in the future this support will expand, but this minimal stabilization already enables straightforward compile-time assertions, for example to verify the size of a type:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;const _: () &#x3D; assert!(std::mem::size_of::&amp;lt;u64&amp;gt;() &#x3D;&#x3D; 8);
const _: () &#x3D; assert!(std::mem::size_of::&amp;lt;u8&amp;gt;() &#x3D;&#x3D; 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-support-for-custom-profiles&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-support-for-custom-profiles&quot;&gt;&lt;/a&gt;Cargo support for custom profiles&lt;/h3&gt;
&lt;p&gt;Cargo has long supported four profiles: &lt;code&gt;dev&lt;/code&gt;, &lt;code&gt;release&lt;/code&gt;, &lt;code&gt;test&lt;/code&gt;, and &lt;code&gt;bench&lt;/code&gt;. With Rust 1.57, support has been added for arbitrarily named profiles.&lt;/p&gt;
&lt;p&gt;For example, if you want to enable link time optimizations (&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#lto&quot;&gt;LTO&lt;/a&gt;) only when making the final production build, adding the following snippet to Cargo.toml enables the &lt;code&gt;lto&lt;/code&gt; flag when this profile is selected, but avoids enabling it for regular release builds.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[profile.production]
inherits &#x3D; &amp;quot;release&amp;quot;
lto &#x3D; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that custom profiles must specify a profile from which they inherit default settings. Once the profile has been defined, Cargo commands which build code can be asked to use it with &lt;code&gt;--profile production&lt;/code&gt;. Currently, this will build artifacts in a separate directory (&lt;code&gt;target/production&lt;/code&gt; in this case), which means that artifacts are not shared between directories.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#fallible-allocation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;fallible-allocation&quot;&gt;&lt;/a&gt;Fallible allocation&lt;/h3&gt;
&lt;p&gt;Rust 1.57 stabilizes &lt;code&gt;try_reserve&lt;/code&gt; for &lt;code&gt;Vec&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;HashMap&lt;/code&gt;, &lt;code&gt;HashSet&lt;/code&gt;, and &lt;code&gt;VecDeque&lt;/code&gt;. This API enables callers to fallibly allocate the backing storage for these types.&lt;/p&gt;
&lt;p&gt;Rust will usually abort the process if the global allocator fails, which is not always desirable. This API provides a method for avoiding that abort when working with the standard library collections. However, Rust does not guarantee that the returned memory is actually allocated by the kernel: for example, if overcommit is enabled on Linux, the memory may not be available when its use is attempted.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.array.html#method.as_mut_slice&quot;&gt;&lt;code&gt;[T; N]::as_mut_slice&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.array.html#method.as_slice&quot;&gt;&lt;code&gt;[T; N]::as_slice&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.TryReserveError.html&quot;&gt;&lt;code&gt;collections::TryReserveError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.try_reserve&quot;&gt;&lt;code&gt;HashMap::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/hash_set/struct.HashSet.html#method.try_reserve&quot;&gt;&lt;code&gt;HashSet::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/alloc/string/struct.String.html#method.try_reserve&quot;&gt;&lt;code&gt;String::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/alloc/string/struct.String.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;String::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve&quot;&gt;&lt;code&gt;Vec::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;Vec::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.try_reserve&quot;&gt;&lt;code&gt;VecDeque::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;VecDeque::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map_while&quot;&gt;&lt;code&gt;Iterator::map_while&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/iter/struct.MapWhile.html&quot;&gt;&lt;code&gt;iter::MapWhile&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/proc_macro/fn.is_available.html&quot;&gt;&lt;code&gt;proc_macro::is_available&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.Command.html#method.get_program&quot;&gt;&lt;code&gt;Command::get_program&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.Command.html#method.get_args&quot;&gt;&lt;code&gt;Command::get_args&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.Command.html#method.get_envs&quot;&gt;&lt;code&gt;Command::get_envs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.Command.html#method.get_current_dir&quot;&gt;&lt;code&gt;Command::get_current_dir&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.CommandArgs.html&quot;&gt;&lt;code&gt;CommandArgs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/process/struct.CommandEnvs.html&quot;&gt;&lt;code&gt;CommandEnvs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/hint/fn.unreachable_unchecked.html&quot;&gt;&lt;code&gt;hint::unreachable_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.57.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1570-2021-12-02&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-157-2021-12-02&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-157&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1570&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1570&quot;&gt;&lt;/a&gt;Contributors to 1.57.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.57.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.57.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for rustc (CVE-2021-42574)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html" type="text/html" title="Security advisory for rustc (CVE-2021-42574)" />
        <published>2021-11-01T00:00:00+00:00</published>
        <updated>2021-11-01T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html">&lt;blockquote&gt;
&lt;p&gt;This is a lightly edited cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/bKPH8XYMvJU&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified of a security concern affecting
source code containing &amp;quot;bidirectional override&amp;quot; Unicode codepoints: in some
cases the use of those codepoints could lead to the reviewed code being
different than the compiled code.&lt;/p&gt;
&lt;p&gt;This is an issue with how source code may be rendered in certain contexts, and
its assigned identifier is &lt;a href&#x3D;&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name&#x3D;CVE-2021-42574&quot;&gt;CVE-2021-42574&lt;/a&gt;. While the issue itself is not a flaw
in rustc, we&#x27;re taking proactive measures to mitigate its impact on Rust developers.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;Unicode has support for both left-to-right and right-to-left languages, and to
aid writing left-to-right words inside a right-to-left sentence (or vice versa)
it also features invisible codepoints called &amp;quot;bidirectional override&amp;quot;.&lt;/p&gt;
&lt;p&gt;These codepoints are normally used across the Internet to embed a word inside a
sentence of another language (with a different text direction), but it was
reported to us that they could be used to manipulate how source code is
displayed in some editors and code review tools, leading to the reviewed code
being different than the compiled code. This is especially bad if the whole
team relies on bidirectional-aware tooling.&lt;/p&gt;
&lt;p&gt;As an example, the following snippet (with &lt;code&gt;{U+NNNN}&lt;/code&gt; replaced with the Unicode
codepoint &lt;code&gt;NNNN&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;if access_level !&#x3D; &amp;quot;user{U+202E} {U+2066}// Check if admin{U+2069} {U+2066}&amp;quot; {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;...would be rendered by bidirectional-aware tools as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;if access_level !&#x3D; &amp;quot;user&amp;quot; { // Check if admin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;Rust 1.56.1 introduces two new lints to detect and reject code containing the
affected codepoints. Rust 1.0.0 through Rust 1.56.0 do not include such lints,
leaving your source code vulnerable to this attack if you do not perform
out-of-band checks for the presence of those codepoints.&lt;/p&gt;
&lt;p&gt;To assess the security of the ecosystem we analyzed all crate versions ever
published on crates.io (as of 2021-10-17), and only 5 crates have the affected
codepoints in their source code, with none of the occurrences being malicious.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We will be releasing Rust 1.56.1 today, 2021-11-01, with two new
deny-by-default lints detecting the affected codepoints, respectively in string
literals and in comments. The lints will prevent source code files containing
those codepoints from being compiled, protecting you from the attack.&lt;/p&gt;
&lt;p&gt;If your code has legitimate uses for the codepoints we recommend replacing them
with the related escape sequence. The error messages will suggest the right
escapes to use.&lt;/p&gt;
&lt;p&gt;If you can&#x27;t upgrade your compiler version, or your codebase also includes
non-Rust source code files, we recommend periodically checking that the
following codepoints are not present in your repository and your dependencies:
U+202A, U+202B, U+202C, U+202D, U+202E, U+2066, U+2067, U+2068, U+2069.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#timeline-of-events&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;timeline-of-events&quot;&gt;&lt;/a&gt;Timeline of events&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;2021-07-25: we received the report and started working on a fix.&lt;/li&gt;
&lt;li&gt;2021-09-14: the date for the embargo lift (2021-11-01) is communicated to us.&lt;/li&gt;
&lt;li&gt;2021-10-17: performed an analysis of all the source code ever published to
crates.io to check for the presence of this attack.&lt;/li&gt;
&lt;li&gt;2021-11-01: embargo lifts, the vulnerability is disclosed and Rust 1.56.1 is
released.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgments&quot;&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;Thanks to &lt;a href&#x3D;&quot;https://github.com/nickboucher&quot;&gt;Nicholas Boucher&lt;/a&gt; and &lt;a href&#x3D;&quot;https://www.cl.cam.ac.uk/~rja14&quot;&gt;Ross Anderson&lt;/a&gt; from the University of
Cambridge for disclosing this to us according to our &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;security policy&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We also want to thank the members of the Rust project who contributed to the
mitigations for this issue. Thanks to Esteban Küber for developing the lints,
Pietro Albini for leading the security response, and many others for their
involvement, insights and feedback: Josh Stone, Josh Triplett, Manish
Goregaokar, Mara Bos, Mark Rousskov, Niko Matsakis, and Steve Klabnik.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#appendix-homoglyph-attacks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;appendix-homoglyph-attacks&quot;&gt;&lt;/a&gt;Appendix: Homoglyph attacks&lt;/h2&gt;
&lt;p&gt;As part of their research, Nicholas Boucher and Ross Anderson also uncovered a
similar security issue identified as &lt;a href&#x3D;&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name&#x3D;CVE-2021-42694&quot;&gt;CVE-2021-42694&lt;/a&gt; involving homoglyphs inside
identifiers. Rust already includes mitigations for that attack since Rust
1.53.0. Rust 1.0.0 through Rust 1.52.1 is not affected due to the lack of
support for non-ASCII identifiers in those releases.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.56.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/11/01/Rust-1.56.1.html" type="text/html" title="Announcing Rust 1.56.1" />
        <published>2021-11-01T00:00:00+00:00</published>
        <updated>2021-11-01T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/2021/11/01/Rust-1.56.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/11/01/Rust-1.56.1.html">&lt;p&gt;The Rust team has published a new point release of Rust, 1.56.1. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.56.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1561-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1561-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.56.1 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.56.1 introduces two new lints to mitigate the impact of a security
concern recently disclosed, &lt;a href&#x3D;&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name&#x3D;CVE-2021-42574&quot;&gt;CVE-2021-42574&lt;/a&gt;. We recommend all users upgrade
immediately to ensure their codebase is not affected by the security issue.&lt;/p&gt;
&lt;p&gt;You can learn more about the security issue in &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/11/01/cve-2021-42574.html&quot;&gt;the advisory&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.56.0 and Rust 2021</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html" type="text/html" title="Announcing Rust 1.56.0 and Rust 2021" />
        <published>2021-10-21T00:00:00+00:00</published>
        <updated>2021-10-21T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/10/21/Rust-1.56.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.56.0. This stabilizes the 2021 edition as well.
Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.56.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1560-2021-10-21&quot;&gt;detailed release notes for 1.56.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1560-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1560-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.56.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#rust-2021&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-2021&quot;&gt;&lt;/a&gt;Rust 2021&lt;/h3&gt;
&lt;p&gt;We wrote about plans for the Rust 2021 Edition &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/05/11/edition-2021.html&quot;&gt;in May&lt;/a&gt;.
Editions are a mechanism for opt-in changes that may otherwise pose backwards compatibility risk. See &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/edition-guide/editions/index.html&quot;&gt;the edition guide&lt;/a&gt; for details on how this is achieved.
This is a smaller edition, especially compared to 2018, but there
are still some nice quality-of-life changes that require an edition opt-in to
avoid breaking some corner cases in existing code. See the new chapters of the
edition guide below for more details on each new feature and guidance for
migration.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/disjoint-capture-in-closures.html&quot;&gt;Disjoint capture&lt;/a&gt;: closures now capture individual named fields rather than always capturing whole identifiers.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/IntoIterator-for-arrays.html&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt; for arrays&lt;/a&gt;: &lt;code&gt;array.into_iter()&lt;/code&gt; now iterates over items by value instead of by reference.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/or-patterns-macro-rules.html&quot;&gt;Or patterns in macro-rules&lt;/a&gt; now match top-level &lt;code&gt;A|B&lt;/code&gt; in &lt;code&gt;:pat&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/default-cargo-resolver.html&quot;&gt;Default Cargo feature resolver&lt;/a&gt; is now version 2.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/prelude.html&quot;&gt;Additions to the prelude&lt;/a&gt;: &lt;code&gt;TryInto&lt;/code&gt;, &lt;code&gt;TryFrom&lt;/code&gt;, and &lt;code&gt;FromIterator&lt;/code&gt; are now in scope by default.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/panic-macro-consistency.html&quot;&gt;Panic macros&lt;/a&gt; now always expect format strings, just like &lt;code&gt;println!()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/reserving-syntax.html&quot;&gt;Reserving syntax&lt;/a&gt; for &lt;code&gt;ident#&lt;/code&gt;, &lt;code&gt;ident&amp;quot;...&amp;quot;&lt;/code&gt;, and &lt;code&gt;ident&#x27;...&#x27;&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/rust-2021/warnings-promoted-to-error.html&quot;&gt;Warnings promoted to errors&lt;/a&gt;: &lt;code&gt;bare_trait_objects&lt;/code&gt; and &lt;code&gt;ellipsis_inclusive_range_patterns&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#disjoint-capture-in-closures&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;disjoint-capture-in-closures&quot;&gt;&lt;/a&gt;Disjoint capture in closures&lt;/h4&gt;
&lt;p&gt;Closures automatically capture values or references to identifiers that are
used in the body, but before 2021, they were always captured as a whole. The new
disjoint-capture feature will likely simplify the way you write closures, so
let&#x27;s look at a quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// 2015 or 2018 edition code
let a &#x3D; SomeStruct::new();

// Move out of one field of the struct
drop(a.x);

// Ok: Still use another field of the struct
println!(&amp;quot;{}&amp;quot;, a.y);

// Error: Before 2021 edition, tries to capture all of &#x60;a&#x60;
let c &#x3D; || println!(&amp;quot;{}&amp;quot;, a.y);
c();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix this, you would have had to extract something like &lt;code&gt;let y &#x3D; &amp;amp;a.y;&lt;/code&gt;
manually before the closure to limit its capture. Starting in Rust 2021,
closures will automatically capture only the fields that they use, so the
above example will compile fine!&lt;/p&gt;
&lt;p&gt;This new behavior is only activated in the new edition, since it can change
the order in which fields are dropped. As for all edition changes, an
automatic migration is available, which will update your closures for which
this matters by inserting &lt;code&gt;let _ &#x3D; &amp;amp;a;&lt;/code&gt; inside the closure to force the
entire struct to be captured as before.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#migrating-to-2021&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;migrating-to-2021&quot;&gt;&lt;/a&gt;Migrating to 2021&lt;/h4&gt;
&lt;p&gt;The guide includes migration instructions for all new features, and in general
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html&quot;&gt;transitioning an existing project to a new edition&lt;/a&gt;.
In many cases &lt;code&gt;cargo fix&lt;/code&gt; can automate the necessary changes. You may even
find that no changes in your code are needed at all for 2021!&lt;/p&gt;
&lt;p&gt;However small this edition appears on the surface, it&#x27;s still the product
of a lot of hard work from many contributors: see our dedicated
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/88623&quot;&gt;celebration and thanks&lt;/a&gt; tracker!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-rust-version&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-rust-version&quot;&gt;&lt;/a&gt;Cargo &lt;code&gt;rust-version&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cargo.toml&lt;/code&gt; now supports a &lt;code&gt;[package]&lt;/code&gt; &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/manifest.html#the-rust-version-field&quot;&gt;&lt;code&gt;rust-version&lt;/code&gt;&lt;/a&gt; field to specify
the minimum supported Rust version for a crate, and Cargo will exit with an
early error if that is not satisfied. This doesn&#x27;t currently influence the
dependency resolver, but the idea is to catch compatibility problems before
they turn into cryptic compiler errors.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#new-bindings-in-binding--pattern&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;new-bindings-in-binding--pattern&quot;&gt;&lt;/a&gt;New bindings in &lt;code&gt;binding @ pattern&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Rust pattern matching can be written with a single identifier that binds
the entire value, followed by &lt;code&gt;@&lt;/code&gt; and a more refined structural pattern,
but this has not allowed additional bindings in that pattern -- until now!&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct Matrix {
    data: Vec&amp;lt;f64&amp;gt;,
    row_len: usize,
}

// Before, we need separate statements to bind
// the whole struct and also read its parts.
let matrix &#x3D; get_matrix();
let row_len &#x3D; matrix.row_len;
// or with a destructuring pattern:
let Matrix { row_len, .. } &#x3D; matrix;

// Rust 1.56 now lets you bind both at once!
let matrix @ Matrix { row_len, .. } &#x3D; get_matrix();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This actually was allowed in the days before Rust 1.0, but that was removed
due to known &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/16053&quot;&gt;unsoundness&lt;/a&gt; at
the time. With the evolution of the borrow checker since that time, and with
heavy testing, the compiler team determined that this was safe to finally
allow in stable Rust!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/fs/fn.chroot.html&quot;&gt;&lt;code&gt;std::os::unix::fs::chroot&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html#method.raw_get&quot;&gt;&lt;code&gt;UnsafeCell::raw_get&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/struct.BufWriter.html#method.into_parts&quot;&gt;&lt;code&gt;BufWriter::into_parts&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/84662&quot;&gt;&lt;code&gt;core::panic::{UnwindSafe, RefUnwindSafe, AssertUnwindSafe}&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
(previously only in &lt;code&gt;std&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#method.shrink_to&quot;&gt;&lt;code&gt;Vec::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/string/struct.String.html#method.shrink_to&quot;&gt;&lt;code&gt;String::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.shrink_to&quot;&gt;&lt;code&gt;OsString::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.shrink_to&quot;&gt;&lt;code&gt;PathBuf::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.shrink_to&quot;&gt;&lt;code&gt;BinaryHeap::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.VecDeque.html#method.shrink_to&quot;&gt;&lt;code&gt;VecDeque::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/hash_map/struct.HashMap.html#method.shrink_to&quot;&gt;&lt;code&gt;HashMap::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/hash_set/struct.HashSet.html#method.shrink_to&quot;&gt;&lt;code&gt;HashSet::shrink_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/fn.transmute.html&quot;&gt;&lt;code&gt;std::mem::transmute&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.first&quot;&gt;&lt;code&gt;[T]::first&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_first&quot;&gt;&lt;code&gt;[T]::split_first&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.last&quot;&gt;&lt;code&gt;[T]::last&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_last&quot;&gt;&lt;code&gt;[T]::split_last&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.56.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1560-2021-10-21&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-156-2021-10-21&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-156&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1560&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1560&quot;&gt;&lt;/a&gt;Contributors to 1.56.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.56.0 and the 2021 edition.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.56.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Core team membership updates</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/09/27/Core-team-membership-updates.html" type="text/html" title="Core team membership updates" />
        <published>2021-09-27T00:00:00+00:00</published>
        <updated>2021-09-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/09/27/Core-team-membership-updates.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/09/27/Core-team-membership-updates.html">&lt;p&gt;The Rust Core team is excited to announce the first of a series of changes to
its structure we’ve been planning for 2021, starting today by adding several new
members.&lt;/p&gt;
&lt;p&gt;Originally, the Core team was composed of the leads from each Rust team.
However, as Rust has grown, this has long stopped being true; most members of
the Core team are not team leads in the project. In part, this is because Core’s
duties have evolved significantly away from the original technical focus. Today,
we see the Core team’s purpose as enabling, amplifying, and supporting the
excellent work of every Rust team. Notably, this included setting up and
&lt;a href&#x3D;&quot;https://foundation.rust-lang.org/posts/2021-02-08-hello-world/&quot;&gt;launching the Rust Foundation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We know that our maintainers, and especially team leads, dedicate an enormous
amount of time to their work on Rust. We care deeply that it’s possible for not
just people working full time on Rust to be leaders, but that part time
volunteers can as well. To enable this, we wish to avoid coupling leading a team
with a commitment to stewarding the project as a whole as part of the Core team.
Likewise, it is important that members of the Core team have the option to
dedicate their time to just the Core team’s activities and serve the project in
that capacity only.&lt;/p&gt;
&lt;p&gt;Early in the Rust project, composition of the Core team was made up of almost
entirely Mozilla employees working full time on Rust. Because this team was made
up of team leads, it follows that team leads were also overwhelmingly composed
of Mozilla employees. As Rust has grown, folks previously employed at Mozilla
left for new jobs and new folks appeared. Many of the new folks were not
employed to work on Rust full time so the collective time investment was
decreased and the shape of the core team’s work schedule shifted from 9-5 to a
more volunteer cadence.  Currently, the Core team is composed largely of
volunteers, and no member of the Core team is employed full time to work on
their Core team duties.&lt;/p&gt;
&lt;p&gt;We know that it’s critical to driving this work successfully to have
stakeholders on the team who are actively working in all areas of the project to
help prioritize the Core team’s initiatives. To serve this goal, we are
announcing some changes to the Core team’s membership today: Ryan Levick,
Jan-Erik Rediger, and JT are joining the Core team. To give some context on
their backgrounds and experiences, each new member has written up a brief
introduction.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rylev&quot;&gt;Ryan Levick&lt;/a&gt; began exploring Rust in 2014 always
looking for more and more ways to be involved in the community. Over time he
participated more by co-organizing the Berlin Rust meetup, doing YouTube
tutorials, helping with various project efforts, and more. In 2019, Ryan got
the opportunity to work with Rust full time leading developer advocacy for
Rust at Microsoft and helping build up the case for Rust as an official
language inside of Microsoft. Nowadays he’s an active Rust project member with
some of the highlights including working in the compiler perf team, running
the Rust annual survey, and helping the 2021 edition effort.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/badboy&quot;&gt;Jan-Erik Rediger&lt;/a&gt; started working with Rust
sometime in late 2014 and has been a member of the Rust Community Team since
2016. That same year he co-founded RustFest, one of the first conferences
dedicated to Rust. In the following years seven RustFest conferences have
brought together hundreds of Rust community members all around Europe and
more recently online.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/jntrnr&quot;&gt;JT&lt;/a&gt; has 15 years of programming language
experience. During that time, JT worked at Cray on the Chapel programming
language and at Apple on LLVM/Clang.  In 2012, they joined Microsoft as part
of the TypeScript core team, where they helped to finish and release
TypeScript to the world. They stayed on for over three years, helping direct
TypeScript and grow its community. From there, they joined Mozilla to work on
Rust, where they brought their experience with TypeScript to help the Rust
project transition from a research language to an industrial language. During
this time, they co-created the new Rust compiler error message format and the
Rust Language Server. Their most recent work is with Nushell, a programming
language implemented in Rust.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These new additions will add fresh perspectives along several axes, including
geographic and employment diversity. However, we recognize there are aspects of
diversity we can continue to improve. We see this work as critical to the
ongoing health of the Rust project and is part of the work that will be
coordinated between the Rust core team and the Rust Foundation.&lt;/p&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://github.com/Manishearth&quot;&gt;Manish Goregaokar&lt;/a&gt; is also leaving the team to be able
to focus better on the dev-tools team. Combining team leadership with Core team
duties is a heavy burden. While Manish has enjoyed his time working on
project-wide initiatives, this coupling isn’t quite fair to the needs of the
devtools team, and he’s glad to be able to spend more time on the devtools team
moving forward.&lt;/p&gt;
&lt;p&gt;The Core team has been doing a lot of work in figuring out how to improve how we
work and how we interface with the rest of the project. We’re excited to be able
to share more on this in future updates.&lt;/p&gt;
&lt;p&gt;We&#x27;re super excited for Manish’s renewed efforts on the dev tools team and for
JT, Ryan, and Jan-Erik to get started on core team work! Congrats and good luck!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This post is part 1 of a multi-part series on updates to the Rust core team.&lt;/em&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.55.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html" type="text/html" title="Announcing Rust 1.55.0" />
        <published>2021-09-09T00:00:00+00:00</published>
        <updated>2021-09-09T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.55.0. Rust is a programming language empowering everyone
to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.55.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-55-2021-09-09&quot;&gt;detailed release notes for 1.55.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1550-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1550-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.55.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-deduplicates-compiler-errors&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-deduplicates-compiler-errors&quot;&gt;&lt;/a&gt;Cargo deduplicates compiler errors&lt;/h3&gt;
&lt;p&gt;In past releases, when running &lt;code&gt;cargo test&lt;/code&gt;, &lt;code&gt;cargo check --all-targets&lt;/code&gt;, or similar commands which built the same Rust crate in multiple configurations, errors and warnings could show up duplicated as the rustc&#x27;s were run in parallel and both showed the same warning.&lt;/p&gt;
&lt;p&gt;For example, in 1.54.0, output like this was common:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo +1.54.0 check --all-targets
    Checking foo v0.1.0
warning: function is never used: &#x60;foo&#x60;
 --&amp;gt; src/lib.rs:9:4
  |
9 | fn foo() {}
  |    ^^^
  |
  &#x3D; note: &#x60;#[warn(dead_code)]&#x60; on by default

warning: 1 warning emitted

warning: function is never used: &#x60;foo&#x60;
 --&amp;gt; src/lib.rs:9:4
  |
9 | fn foo() {}
  |    ^^^
  |
  &#x3D; note: &#x60;#[warn(dead_code)]&#x60; on by default

warning: 1 warning emitted

    Finished dev [unoptimized + debuginfo] target(s) in 0.10s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In 1.55, this behavior has been adjusted to deduplicate and print a report at the end of compilation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cargo +1.55.0 check --all-targets
    Checking foo v0.1.0
warning: function is never used: &#x60;foo&#x60;
 --&amp;gt; src/lib.rs:9:4
  |
9 | fn foo() {}
  |    ^^^
  |
  &#x3D; note: &#x60;#[warn(dead_code)]&#x60; on by default

warning: &#x60;foo&#x60; (lib) generated 1 warning
warning: &#x60;foo&#x60; (lib test) generated 1 warning (1 duplicate)
    Finished dev [unoptimized + debuginfo] target(s) in 0.84s
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#faster-more-correct-float-parsing&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;faster-more-correct-float-parsing&quot;&gt;&lt;/a&gt;Faster, more correct float parsing&lt;/h3&gt;
&lt;p&gt;The standard library&#x27;s implementation of float parsing has been updated to use the Eisel-Lemire algorithm, which brings both speed improvements and improved correctness. In the past, certain edge cases failed to parse, and this has now been fixed.&lt;/p&gt;
&lt;p&gt;You can read more details on the new implementation &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/86761&quot;&gt;in the pull request description&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stdioerrorkind-variants-updated&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stdioerrorkind-variants-updated&quot;&gt;&lt;/a&gt;&lt;code&gt;std::io::ErrorKind&lt;/code&gt; variants updated&lt;/h3&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/enum.ErrorKind.html&quot;&gt;&lt;code&gt;std::io::ErrorKind&lt;/code&gt;&lt;/a&gt; is a &lt;a href&#x3D;&quot;https://doc.rust-lang.org/reference/attributes/type_system.html#the-non_exhaustive-attribute&quot;&gt;&lt;code&gt;#[non_exhaustive]&lt;/code&gt;&lt;/a&gt; enum that classifies errors into portable categories, such as &lt;code&gt;NotFound&lt;/code&gt; or &lt;code&gt;WouldBlock&lt;/code&gt;. Rust code that has a &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/io/struct.Error.html&quot;&gt;&lt;code&gt;std::io::Error&lt;/code&gt;&lt;/a&gt; can call the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/io/struct.Error.html#method.kind&quot;&gt;&lt;code&gt;kind&lt;/code&gt; method&lt;/a&gt; to obtain a &lt;code&gt;std::io::ErrorKind&lt;/code&gt; and match on that to handle a specific error.&lt;/p&gt;
&lt;p&gt;Not all errors are categorized into &lt;code&gt;ErrorKind&lt;/code&gt; values; some are left uncategorized and placed in a catch-all variant. In previous versions of Rust, uncategorized errors used &lt;code&gt;ErrorKind::Other&lt;/code&gt;; however, user-created &lt;code&gt;std::io::Error&lt;/code&gt; values also commonly used &lt;code&gt;ErrorKind::Other&lt;/code&gt;. In 1.55, uncategorized errors now use the internal variant &lt;code&gt;ErrorKind::Uncategorized&lt;/code&gt;, which we intend to leave hidden and never available for stable Rust code to name explicitly; this leaves &lt;code&gt;ErrorKind::Other&lt;/code&gt; exclusively for constructing &lt;code&gt;std::io::Error&lt;/code&gt; values that don&#x27;t come from the standard library. This enforces the &lt;code&gt;#[non_exhaustive]&lt;/code&gt; nature of &lt;code&gt;ErrorKind&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Rust code should never match &lt;code&gt;ErrorKind::Other&lt;/code&gt; and expect any particular underlying error code; only match &lt;code&gt;ErrorKind::Other&lt;/code&gt; if you&#x27;re catching a constructed &lt;code&gt;std::io::Error&lt;/code&gt; that uses that error kind. Rust code matching on &lt;code&gt;std::io::Error&lt;/code&gt; should always use &lt;code&gt;_&lt;/code&gt; for any error kinds it doesn&#x27;t know about, in which case it can match the underlying error code, or report the error, or bubble it up to calling code.&lt;/p&gt;
&lt;p&gt;We&#x27;re making this change to smooth the way for introducing new ErrorKind variants in the future; those new variants will start out nightly-only, and only become stable later. This change ensures that code matching variants it doesn&#x27;t know about must use a catch-all &lt;code&gt;_&lt;/code&gt; pattern, which will work both with &lt;code&gt;ErrorKind::Uncategorized&lt;/code&gt; and with future nightly-only variants.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#open-range-patterns-added&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;open-range-patterns-added&quot;&gt;&lt;/a&gt;Open range patterns added&lt;/h3&gt;
&lt;p&gt;Rust 1.55 stabilized using open ranges in patterns:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;match x as u32 {
      0 &#x3D;&amp;gt; println!(&amp;quot;zero!&amp;quot;),
      1.. &#x3D;&amp;gt; println!(&amp;quot;positive number!&amp;quot;),
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Read more details &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/83918&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ops/enum.Bound.html#method.cloned&quot;&gt;&lt;code&gt;Bound::cloned&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/string/struct.Drain.html#method.as_str&quot;&gt;&lt;code&gt;Drain::as_str&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/struct.IntoInnerError.html#method.into_error&quot;&gt;&lt;code&gt;IntoInnerError::into_error&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/struct.IntoInnerError.html#method.into_parts&quot;&gt;&lt;code&gt;IntoInnerError::into_parts&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_mut&quot;&gt;&lt;code&gt;MaybeUninit::assume_init_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_ref&quot;&gt;&lt;code&gt;MaybeUninit::assume_init_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.write&quot;&gt;&lt;code&gt;MaybeUninit::write&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.array.html#method.map&quot;&gt;&lt;code&gt;array::map&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html&quot;&gt;&lt;code&gt;ops::ControlFlow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/x86/fn._bittest.html&quot;&gt;&lt;code&gt;x86::_bittest&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/x86/fn._bittestandcomplement.html&quot;&gt;&lt;code&gt;x86::_bittestandcomplement&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/x86/fn._bittestandreset.html&quot;&gt;&lt;code&gt;x86::_bittestandreset&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/x86/fn._bittestandset.html&quot;&gt;&lt;code&gt;x86::_bittestandset&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/x86_64/fn._bittest64.html&quot;&gt;&lt;code&gt;x86_64::_bittest64&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/x86_64/fn._bittestandcomplement64.html&quot;&gt;&lt;code&gt;x86_64::_bittestandcomplement64&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/x86_64/fn._bittestandreset64.html&quot;&gt;&lt;code&gt;x86_64::_bittestandreset64&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/x86_64/fn._bittestandset64.html&quot;&gt;&lt;code&gt;x86_64::_bittestandset64&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/str/fn.from_utf8_unchecked.html&quot;&gt;&lt;code&gt;str::from_utf8_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.55.0 release:
check out what changed in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-55-2021-09-09&quot;&gt;Rust&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-155-2021-09-09&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-155&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1550&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1550&quot;&gt;&lt;/a&gt;Contributors to 1.55.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.55.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.55.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#dedication&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;dedication&quot;&gt;&lt;/a&gt;Dedication&lt;/h3&gt;
&lt;p&gt;Anna Harren was a member of the community and contributor to Rust known for coining the term &amp;quot;Turbofish&amp;quot; to describe &lt;code&gt;::&amp;lt;&amp;gt;&lt;/code&gt; syntax. Anna recently passed away after living with cancer. Her contribution will forever be remembered and be part of the language, and we dedicate this release to her memory.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>The push for GATs stabilization</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html" type="text/html" title="The push for GATs stabilization" />
        <published>2021-08-03T00:00:00+00:00</published>
        <updated>2021-08-03T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html">&lt;h1&gt;&lt;a href&#x3D;&quot;#the-push-for-gats-stabilization&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-push-for-gats-stabilization&quot;&gt;&lt;/a&gt;The push for GATs stabilization&lt;/h1&gt;
&lt;p&gt;Where to start, where to start...&lt;/p&gt;
&lt;p&gt;Let&#x27;s begin by saying: this is a very exciting post. Some people reading this will be overwhelmingly thrilled; some will have no idea what GATs (generic associated types) are; others might be in disbelief. The &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;RFC&lt;/a&gt; for this feature did get opened in April of &lt;em&gt;2016&lt;/em&gt; (and merged about a year and a half later). In fact, this RFC even predates const generics (which an MVP of was &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#const-generics-mvp&quot;&gt;recently stabilized&lt;/a&gt;). Don&#x27;t let this fool you though: it is a powerful feature; and the reactions to the tracking issue on Github should maybe give you an idea of its popularity (it is &lt;em&gt;the&lt;/em&gt; most upvoted issue on the Rust repository):
&lt;img src&#x3D;&quot;/images/2021-08-03-GATs-stabilization-push/gats-reactions.png&quot; alt&#x3D;&quot;GATs reactions&quot; /&gt;&lt;/p&gt;
&lt;p&gt;If you&#x27;re not familiar with GATs, they allow you to define type, lifetime, or const generics on associated types. Like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Foo {
    type Bar&amp;lt;&#x27;a&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, this may seem underwhelming, but I&#x27;ll go into more detail later as to &lt;em&gt;why&lt;/em&gt; this really is a powerful feature.&lt;/p&gt;
&lt;p&gt;But for now: what exactly &lt;em&gt;is&lt;/em&gt; happening? Well, nearly four years after its RFC was merged, the &lt;code&gt;generic_associated_types&lt;/code&gt; feature is no longer &amp;quot;incomplete.&amp;quot;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;crickets chirping&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Wait...that&#x27;s it?? Well, yes! I&#x27;ll go into a bit of detail later in this blog post as to why this &lt;em&gt;is&lt;/em&gt; a big deal. But, long story short, there have been a good amount of changes that have had to have been made to the compiler to get GATs to work. And, while there are still a few small remaining diagnostics issues, the feature is finally in a space that we feel comfortable making it no longer &amp;quot;incomplete&amp;quot;.&lt;/p&gt;
&lt;p&gt;So, what does that mean? Well, all it &lt;em&gt;really&lt;/em&gt; means is that when you use this feature on nightly, you&#x27;ll no longer get the &amp;quot;&lt;code&gt;generic_associated_types&lt;/code&gt; is incomplete&amp;quot; warning. However, the real reason this is a big deal: we want to stabilize this feature. But we need your help. We need you to test this feature, to file issues for any bugs you find or for potential diagnostic improvements. Also, we&#x27;d love for you to just tell us about some interesting patterns that GATs enable over on &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits&quot;&gt;Zulip&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Without making promises that we aren&#x27;t 100% sure we can keep, we have high hopes we can stabilize this feature within the next couple months. But, we want to make sure we aren&#x27;t missing glaringly obvious bugs or flaws. We want this to be a smooth stabilization.&lt;/p&gt;
&lt;p&gt;Okay. Phew. That&#x27;s the main point of this post and the most exciting news. But as I said before, I think it&#x27;s also reasonable for me to explain &lt;em&gt;what&lt;/em&gt; this feature is, what you can do with it, and some of the background and how we got here.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#so-what-are-gats&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;so-what-are-gats&quot;&gt;&lt;/a&gt;So what are GATs?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Note: this will only be a brief overview. The &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;RFC&lt;/a&gt; contains many more details.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GATs (generic associated types) were originally proposed in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;RFC 1598&lt;/a&gt;. As said before, they allow you to define type, lifetime, or const generics on associated types. If you&#x27;re familiar with languages that have &amp;quot;higher-kinded types&amp;quot;, then you could call GATs &lt;em&gt;type constructors on traits&lt;/em&gt;. Perhaps the easiest way for you to get a sense of how you might use GATs is to jump into an example.&lt;/p&gt;
&lt;p&gt;Here is a popular use case: a &lt;code&gt;LendingIterator&lt;/code&gt; (formerly known as a &lt;code&gt;StreamingIterator&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;lt;&#x27;a&amp;gt;&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#x27;s go through one implementation of this, a hypothetical &lt;code&gt;&amp;lt;[T]&amp;gt;::windows_mut&lt;/code&gt;, which allows for iterating through overlapping mutable windows on a slice. If you were to try to implement this with &lt;code&gt;Iterator&lt;/code&gt; today like&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct WindowsMut&amp;lt;&#x27;t, T&amp;gt; {
    slice: &amp;amp;&#x27;t mut [T],
    start: usize,
    window_size: usize,
}

impl&amp;lt;&#x27;t, T&amp;gt; Iterator for WindowsMut&amp;lt;&#x27;t, T&amp;gt; {
    type Item &#x3D; &amp;amp;&#x27;t mut [T];

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt; {
        let retval &#x3D; self.slice[self.start..].get_mut(..self.window_size)?;
        self.start +&#x3D; 1;
        Some(retval)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then you would get an error.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error[E0495]: cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements
  --&amp;gt; src/lib.rs:9:22
   |
9  |         let retval &#x3D; self.slice[self.start..].get_mut(..self.window_size)?;
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: first, the lifetime cannot outlive the lifetime &#x60;&#x27;a&#x60; as defined on the method body at 8:13...
  --&amp;gt; src/lib.rs:8:13
   |
8  |     fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;gt; {
   |             ^^
note: ...so that reference does not outlive borrowed content
  --&amp;gt; src/lib.rs:9:22
   |
9  |         let retval &#x3D; self.slice[self.start..].get_mut(..self.window_size)?;
   |                      ^^^^^^^^^^
note: but, the lifetime must be valid for the lifetime &#x60;&#x27;t&#x60; as defined on the impl at 6:6...
  --&amp;gt; src/lib.rs:6:6
   |
6  | impl&amp;lt;&#x27;t, T: &#x27;t&amp;gt; Iterator for WindowsMut&amp;lt;&#x27;t, T&amp;gt; {
   |      ^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Put succinctly, this error is essentially telling us that in order for us to be able to return a reference to &lt;code&gt;self.slice&lt;/code&gt;, it must live as long as &lt;code&gt;&#x27;a&lt;/code&gt;, which would require a &lt;code&gt;&#x27;a: &#x27;t&lt;/code&gt; bound (which we can&#x27;t provide). Without this, we could call &lt;code&gt;next&lt;/code&gt; while already holding a reference to the slice, creating overlapping mutable references. However, it does compile fine if you were to implement this using the &lt;code&gt;LendingIterator&lt;/code&gt; trait from before:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl&amp;lt;&#x27;t, T&amp;gt; LendingIterator for WindowsMut&amp;lt;&#x27;t, T&amp;gt; {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a &#x3D; &amp;amp;&#x27;a mut [T];

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;lt;&#x27;a&amp;gt;&amp;gt; {
        let retval &#x3D; self.slice[self.start..].get_mut(..self.window_size)?;
        self.start +&#x3D; 1;
        Some(retval)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As an aside, there&#x27;s one thing to note about this trait and impl that you might be curious about: the &lt;code&gt;where Self: &#x27;a&lt;/code&gt; clause on &lt;code&gt;Item&lt;/code&gt;. Briefly, this allows us to use &lt;code&gt;&amp;amp;&#x27;a mut [T]&lt;/code&gt;; without this where clause, someone could try to return &lt;code&gt;Self::Item&amp;lt;&#x27;static&amp;gt;&lt;/code&gt; and extend the lifetime of the slice. We understand that this is a point of confusion sometimes and are considering potential alternatives, such as always assuming this bound or implying it based on usage within the trait (see &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/87479&quot;&gt;this issue&lt;/a&gt;). We definitely would love to hear about your use cases here, particularly when assuming this bound would be a hindrance.&lt;/p&gt;
&lt;p&gt;As another example, imagine you wanted a struct to be generic over a pointer to a specific type. You might write the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait PointerFamily {
    type Pointer&amp;lt;T&amp;gt;: Deref&amp;lt;Target &#x3D; T&amp;gt;;

    fn new&amp;lt;T&amp;gt;(value: T) -&amp;gt; Self::Pointer&amp;lt;T&amp;gt;;
}

struct ArcFamily;
struct RcFamily;

impl PointerFamily for ArcFamily {
    type Pointer&amp;lt;T&amp;gt; &#x3D; Arc&amp;lt;T&amp;gt;;
    ...
}
impl PointerFamily for RcFamily {
    type Pointer&amp;lt;T&amp;gt; &#x3D; Rc&amp;lt;T&amp;gt;;
    ...
}

struct MyStruct&amp;lt;P: PointerFamily&amp;gt; {
    pointer: P::Pointer&amp;lt;String&amp;gt;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We won&#x27;t go in-depth on the details here, but this example is nice in that it not only highlights the use of types in GATs, but also shows that you can still use the trait bounds that you already can use on associated types.&lt;/p&gt;
&lt;p&gt;These two examples only scratch the surface of the patterns that GATs support. If you find any that seem particularly interesting or clever, we would love to hear about them over on &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits&quot;&gt;Zulip&lt;/a&gt;!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#why-has-it-taken-so-long-to-implement-this&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-has-it-taken-so-long-to-implement-this&quot;&gt;&lt;/a&gt;Why has it taken so long to implement this?&lt;/h2&gt;
&lt;p&gt;So what has caused us to have taken nearly four years to get to the point that we are now? Well, it&#x27;s hard to put into words how much the existing trait solver has had to change and adapt; but, consider this: for a while, it was thought that to support GATs, we would have to transition rustc to use &lt;a href&#x3D;&quot;https://github.com/rust-lang/chalk&quot;&gt;Chalk&lt;/a&gt;, a potential future trait solver that uses logical predicates to solve trait goals (though, while some progress has been made, it&#x27;s still very experimental even now).&lt;/p&gt;
&lt;p&gt;For reference, here are some various implementation additions and changes that have been made that have furthered GAT support in some way or another:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parsing GATs in AST (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/45904&quot;&gt;#45904&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Resolving lifetimes in GATs (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/46706&quot;&gt;#46706&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Initial trait solver work to support lifetimes (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/67160&quot;&gt;#67160&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Validating projection bounds (and making changes that allow type and const GATs) (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/72788&quot;&gt;#72788&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Separating projection bounds and predicates (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/73905&quot;&gt;#73905&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Allowing GATs in trait paths (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79554&quot;&gt;#79554&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Partially replace leak check with universes (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/65232&quot;&gt;#65232&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Move leak check to later in trait solving (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/72493&quot;&gt;#72493&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Replacing bound vars in GATs with placeholders when projecting (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/86993&quot;&gt;#86993&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And to further emphasize the work above: many of these PRs are large and have considerable design work behind them. There are also several smaller PRs along the way. &lt;em&gt;But&lt;/em&gt;, we made it. And I just want to congratulate everyone who&#x27;s put effort into this one way or another. You rock.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-limitations-are-there-currently&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-limitations-are-there-currently&quot;&gt;&lt;/a&gt;What limitations are there currently?&lt;/h2&gt;
&lt;p&gt;Ok, so now comes the part that nobody likes hearing about: the limitations. Fortunately, in this case, there&#x27;s really only one GAT limitation: traits with GATs are not object safe. This means you won&#x27;t be able to do something like&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn takes_iter(_: &amp;amp;mut dyn for&amp;lt;&#x27;a&amp;gt; LendingIterator&amp;lt;Item&amp;lt;&#x27;a&amp;gt; &#x3D; &amp;amp;&#x27;a i32&amp;gt;) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The biggest reason for this decision is that there&#x27;s still a bit of design and implementation work to actually make this usable. And while this is a nice feature, adding this in the future would be a backward-compatible change. We feel that it&#x27;s better to get &lt;em&gt;most&lt;/em&gt; of GATs stabilized and then come back and try to tackle this later than to block GATs for even longer. Also, GATs without object safety are still very powerful, so we don&#x27;t lose much by defering this.&lt;/p&gt;
&lt;p&gt;As was mentioned earlier in this post, there are still a couple remaining diagnostics &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/labels/F-generic_associated_types&quot;&gt;issues&lt;/a&gt;. If you do find bugs though, please file issues!&lt;/p&gt;
</content>

        <author>
            <name>Jack Huey</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.54.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/07/29/Rust-1.54.0.html" type="text/html" title="Announcing Rust 1.54.0" />
        <published>2021-07-29T00:00:00+00:00</published>
        <updated>2021-07-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/07/29/Rust-1.54.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/07/29/Rust-1.54.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.54.0. Rust is a programming language empowering everyone
to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.54.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1540-2021-07-29&quot;&gt;detailed release notes for 1.54.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1540-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1540-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.54.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#attributes-can-invoke-function-like-macros&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;attributes-can-invoke-function-like-macros&quot;&gt;&lt;/a&gt;Attributes can invoke function-like macros&lt;/h3&gt;
&lt;p&gt;Rust 1.54 supports invoking function-like macros inside attributes. Function-like macros can be either &lt;code&gt;macro_rules!&lt;/code&gt; based or procedural macros which are invoked like &lt;code&gt;macro!(...)&lt;/code&gt;. One notable use case for this is including documentation from other files into Rust doc comments. For example, if your project&#x27;s README represents a good documentation comment, you can use &lt;code&gt;include_str!&lt;/code&gt; to directly incorporate the contents. Previously, various workarounds allowed similar functionality, but from 1.54 this is much more ergonomic.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&#x3D;&quot;&gt;#![doc &#x3D; include_str!(&amp;quot;README.md&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Macros can be nested inside the attribute as well.
For example, the &lt;code&gt;concat!&lt;/code&gt; macro can be used to construct a doc comment from within a macro that uses &lt;code&gt;stringify!&lt;/code&gt; to include substitutions:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;macro_rules! make_function {
    ($name:ident, $value:expr) &#x3D;&amp;gt; {
        #[doc &#x3D; concat!(&amp;quot;The &#x60;&amp;quot;, stringify!($name), &amp;quot;&#x60; example.&amp;quot;)]
        ///
        /// # Example
        ///
        /// &#x60;&#x60;&#x60;
        #[doc &#x3D; concat!(
            &amp;quot;assert_eq!(&amp;quot;, module_path!(), &amp;quot;::&amp;quot;, stringify!($name), &amp;quot;(), &amp;quot;,
            stringify!($value), &amp;quot;);&amp;quot;)
        ]
        /// &#x60;&#x60;&#x60;
        pub fn $name() -&amp;gt; i32 {
            $value
        }
    };
}

make_function! {func_name, 123}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Read &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/83366&quot;&gt;here&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#wasm32-intrinsics-stabilized&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;wasm32-intrinsics-stabilized&quot;&gt;&lt;/a&gt;wasm32 intrinsics stabilized&lt;/h3&gt;
&lt;p&gt;A number of intrinsics for the wasm32 platform have been stabilized, which gives access to the SIMD instructions in WebAssembly.&lt;/p&gt;
&lt;p&gt;Notably, unlike the previously stabilized &lt;code&gt;x86&lt;/code&gt; and &lt;code&gt;x86_64&lt;/code&gt; intrinsics, these do not have a safety requirement to only be called when the appropriate target feature is enabled. This is because WebAssembly was written from the start to validate code safely before executing it, so instructions are guaranteed to be decoded correctly (or not at all).&lt;/p&gt;
&lt;p&gt;This means that we can expose some of the intrinsics as entirely safe functions, for example &lt;a href&#x3D;&quot;https://doc.rust-lang.org/beta/core/arch/wasm32/fn.v128_bitselect.html&quot;&gt;&lt;code&gt;v128_bitselect&lt;/code&gt;&lt;/a&gt;. However, there are still some intrinsics which are unsafe because they use raw pointers, such as &lt;a href&#x3D;&quot;https://doc.rust-lang.org/beta/core/arch/wasm32/fn.v128_load.html&quot;&gt;&lt;code&gt;v128_load&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#incremental-compilation-is-re-enabled-by-default&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;incremental-compilation-is-re-enabled-by-default&quot;&gt;&lt;/a&gt;Incremental Compilation is re-enabled by default&lt;/h3&gt;
&lt;p&gt;Incremental compilation has been re-enabled by default in this release, after it being disabled by default in 1.52.1.&lt;/p&gt;
&lt;p&gt;In Rust 1.52, additional validation was added when loading incremental compilation data from the on-disk cache.
This resulted in a number of pre-existing potential soundness issues being uncovered as the validation changed these silent bugs into internal compiler errors (ICEs).
In response, the Compiler Team decided to disable incremental compilation in the 1.52.1 patch, allowing users to avoid encountering the ICEs and the underlying unsoundness, at the expense of longer compile times. &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Since then, we&#x27;ve conducted a &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/435&quot;&gt;series of retrospectives&lt;/a&gt; and contributors have been hard at work resolving the reported issues, with some fixes landing in 1.53 and the majority landing in this release. &lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn2&quot; id&#x3D;&quot;fnref2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;There are currently still two known issues which can result in an ICE.
Due to the lack of automated crash reporting, we can&#x27;t be certain of the full extent of impact of the outstanding issues. However, based on the feedback we received from users affected by the 1.52 release, we believe the remaining issues to be rare in practice.&lt;/p&gt;
&lt;p&gt;Therefore, incremental compilation has been re-enabled in this release!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.into_keys&quot;&gt;&lt;code&gt;BTreeMap::into_keys&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.into_values&quot;&gt;&lt;code&gt;BTreeMap::into_values&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.into_keys&quot;&gt;&lt;code&gt;HashMap::into_keys&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.into_values&quot;&gt;&lt;code&gt;HashMap::into_values&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/arch/wasm32/index.html&quot;&gt;&lt;code&gt;arch::wasm32&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.binary_search&quot;&gt;&lt;code&gt;VecDeque::binary_search&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.binary_search_by&quot;&gt;&lt;code&gt;VecDeque::binary_search_by&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.binary_search_by_key&quot;&gt;&lt;code&gt;VecDeque::binary_search_by_key&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.partition_point&quot;&gt;&lt;code&gt;VecDeque::partition_point&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.54.0 release:
check out what changed in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1540-2021-07-29&quot;&gt;Rust&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-154-2021-07-29&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-154&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;rustfmt has also been fixed in the 1.54.0 release to properly format nested
out-of-line modules. This may cause changes in formatting to files that were
being ignored by the 1.53.0 rustfmt. See details &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/86424&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1540&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1540&quot;&gt;&lt;/a&gt;Contributors to 1.54.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.54.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.54.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;The &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/05/10/Rust-1.52.1.html&quot;&gt;1.52.1 release notes&lt;/a&gt; contain a more detailed description of these events. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id&#x3D;&quot;fn2&quot;&gt;
&lt;p&gt;The tracking issue for the issues is &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/84970&quot;&gt;#84970&lt;/a&gt;. &lt;a href&#x3D;&quot;#fnref2&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
</feed>

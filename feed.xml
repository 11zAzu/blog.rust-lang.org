<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2023-01-10T16:41:02+00:00</updated>

    
    <entry>
        <title>Security advisory for Cargo (CVE-2022-46176)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2023/01/10/cve-2022-46176.html" type="text/html" title="Security advisory for Cargo (CVE-2022-46176)" />
        <published>2023-01-10T00:00:00+00:00</published>
        <updated>2023-01-10T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2023/01/10/cve-2022-46176.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2023/01/10/cve-2022-46176.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/v5cFFJ7T0RY&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified that Cargo did not perform SSH host
key verification when cloning indexes and dependencies via SSH. An attacker
could exploit this to perform man-in-the-middle (MITM) attacks.&lt;/p&gt;
&lt;p&gt;This vulnerability has been assigned CVE-2022-46176.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;When an SSH client establishes communication with a server, to prevent MITM
attacks the client should check whether it already communicated with that
server in the past and what the server&#x27;s public key was back then. If the key
changed since the last connection, the connection must be aborted as a MITM
attack is likely taking place.&lt;/p&gt;
&lt;p&gt;It was discovered that Cargo never implemented such checks, and performed no
validation on the server&#x27;s public key, leaving Cargo users vulnerable to MITM
attacks.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;All Rust versions containing Cargo before 1.66.1 are vulnerable.&lt;/p&gt;
&lt;p&gt;Note that even if you don&#x27;t explicitly use SSH for alternate registry indexes
or crate dependencies, you might be affected by this vulnerability if you have
configured git to replace HTTPS connections to GitHub with SSH (through git&#x27;s
&lt;a href&#x3D;&quot;https://git-scm.com/docs/git-config#Documentation/git-config.txt-urlltbasegtinsteadOf&quot;&gt;&lt;code&gt;url.&amp;lt;base&amp;gt;.insteadOf&lt;/code&gt;&lt;/a&gt; setting), as that&#x27;d cause you to clone the
crates.io index through SSH.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We will be releasing Rust 1.66.1 today, 2023-01-10, changing Cargo to check the
SSH host key and abort the connection if the server&#x27;s public key is not already
trusted. We recommend everyone to upgrade as soon as possible.&lt;/p&gt;
&lt;p&gt;Patch files for Rust 1.66.0 are also available &lt;a href&#x3D;&quot;https://github.com/rust-lang/wg-security-response/tree/main/patches/CVE-2022-46176&quot;&gt;here&lt;/a&gt; for custom-built
toolchains.&lt;/p&gt;
&lt;p&gt;For the time being Cargo will not ask the user whether to trust a server&#x27;s
public key during the first connection. Instead, Cargo will show an error
message detailing how to add that public key to the list of trusted keys. Note
that this might break your automated builds if the hosts you clone dependencies
or indexes from are not already trusted.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgments&quot;&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;Thanks to the Julia Security Team for disclosing this to us according to our
&lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;security policy&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;We also want to thank the members of the Rust project who contributed to fixing
this issue. Thanks to Eric Huss and Weihang Lo for writing and reviewing the
patch, Pietro Albini for coordinating the disclosure and writing this advisory,
and Josh Stone, Josh Triplett and Jacob Finkelman for advising during the
disclosure.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Updating the Android NDK in Rust 1.68</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html" type="text/html" title="Updating the Android NDK in Rust 1.68" />
        <published>2023-01-09T00:00:00+00:00</published>
        <updated>2023-01-09T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2023/01/09/android-ndk-update-r25.html">&lt;p&gt;We are pleased to announce that Android platform support in Rust will be
modernized in Rust 1.68 as we update the target NDK from r17 to r25.  As a
consequence the minimum supported API level will increase from 15 (Ice Cream
Sandwich) to 19 (KitKat).&lt;/p&gt;
&lt;p&gt;In NDK r23 Android switched to using LLVM&#x27;s &lt;code&gt;libunwind&lt;/code&gt; for all architectures.
This meant that&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If a project were to target NDK r23 or newer with previous versions of Rust
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/85806#issuecomment-1096266946&quot;&gt;a workaround&lt;/a&gt;
would be required to redirect attempts to link against &lt;code&gt;libgcc&lt;/code&gt; to instead
link against &lt;code&gt;libunwind&lt;/code&gt;.  Following this update this workaround will no
longer be necessary.&lt;/li&gt;
&lt;li&gt;If a project uses NDK r22 or older it will need to be updated to use &lt;a href&#x3D;&quot;https://developer.android.com/ndk/downloads&quot;&gt;r23 or
newer&lt;/a&gt;.  Information about the
layout of the NDK&#x27;s toolchain can be found
&lt;a href&#x3D;&quot;https://developer.android.com/ndk/guides/other_build_systems&quot;&gt;here&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Going forward the Android platform will target the most recent LTS NDK, allowing
Rust developers to access platform features sooner.  These updates should occur
yearly and will be announced in release notes.&lt;/p&gt;
</content>

        <author>
            <name>Android Platform Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.66.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html" type="text/html" title="Announcing Rust 1.66.0" />
        <published>2022-12-15T00:00:00+00:00</published>
        <updated>2022-12-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/12/15/Rust-1.66.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.66.0. Rust is a
programming language empowering everyone to build reliable and efficient
software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.66.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get
&lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on
our website, and check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1660-2022-12-15&quot;&gt;detailed release notes for
1.66.0&lt;/a&gt;
on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider
updating locally to use the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly
channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you
might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1660-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1660-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.66.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#explicit-discriminants-on-enums-with-fields&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;explicit-discriminants-on-enums-with-fields&quot;&gt;&lt;/a&gt;Explicit discriminants on enums with fields&lt;/h3&gt;
&lt;p&gt;Enums with integer representations can now use explicit discriminants, even when they have fields.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[repr(u8)]
enum Foo {
    A(u8),
    B(i8),
    C(bool) &#x3D; 42,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Previously, you could use explicit discriminants on enums with representations, but only if none of their variants had fields. Explicit discriminants are useful when passing values across language boundaries where the representation of the enum needs to match in both languages. For example,&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[repr(u8)]
enum Bar {
    A,
    B,
    C &#x3D; 42,
    D,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here the &lt;code&gt;Bar&lt;/code&gt; enum is guaranteed to have the same layout as &lt;code&gt;u8&lt;/code&gt;. In addition, the &lt;code&gt;Bar::C&lt;/code&gt; variant is guaranteed to have a discriminant of 42. Variants without explicitly-specified values will have discriminants that are automatically assigned according to their order in the source code, so &lt;code&gt;Bar::A&lt;/code&gt; will have a discriminant of 0, &lt;code&gt;Bar::B&lt;/code&gt; will have a discriminant of 1, and &lt;code&gt;Bar::D&lt;/code&gt; will have a discriminant of 43. Without this feature, the only way to set the explicit value of &lt;code&gt;Bar::C&lt;/code&gt; would be to add 41 unnecessary variants before it!&lt;/p&gt;
&lt;p&gt;Note: whereas for field-less enums it is possible to inspect a discriminant via &lt;code&gt;as&lt;/code&gt; casting (e.g. &lt;code&gt;Bar::C as u8&lt;/code&gt;), Rust provides no language-level way to access the raw discriminant of an enum with fields. Instead, currently unsafe code must be used to inspect the discriminant of an enum with fields. Since this feature is intended for use with cross-language FFI where unsafe code is already necessary, this should hopefully not be too much of an extra burden. In the meantime, if all you need is an opaque handle to the discriminant, please see the &lt;code&gt;std::mem::discriminant&lt;/code&gt; function.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#corehintblack_box&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;corehintblack_box&quot;&gt;&lt;/a&gt;&lt;code&gt;core::hint::black_box&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;When benchmarking or examining the machine code produced by a compiler, it&#x27;s often useful to prevent optimizations from occurring in certain places. In the following example, the function &lt;code&gt;push_cap&lt;/code&gt; executes &lt;code&gt;Vec::push&lt;/code&gt; 4 times in a loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn push_cap(v: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) {
    for i in 0..4 {
        v.push(i);
    }
}

pub fn bench_push() -&amp;gt; Duration { 
    let mut v &#x3D; Vec::with_capacity(4);
    let now &#x3D; Instant::now();
    push_cap(&amp;amp;mut v);
    now.elapsed()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you inspect the optimized output of the compiler on x86_64, you&#x27;ll notice that it looks rather short:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-asm&quot;&gt;example::bench_push:
  sub rsp, 24
  call qword ptr [rip + std::time::Instant::now@GOTPCREL]
  lea rdi, [rsp + 8]
  mov qword ptr [rsp + 8], rax
  mov dword ptr [rsp + 16], edx
  call qword ptr [rip + std::time::Instant::elapsed@GOTPCREL]
  add rsp, 24
  ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In fact, the entire function &lt;code&gt;push_cap&lt;/code&gt; we wanted to benchmark has been optimized away!&lt;/p&gt;
&lt;p&gt;We can work around this using the newly stabilized &lt;code&gt;black_box&lt;/code&gt; function. Functionally, &lt;code&gt;black_box&lt;/code&gt; is not very interesting: it takes the value you pass it and passes it right back. Internally, however, the compiler treats &lt;code&gt;black_box&lt;/code&gt; as a function that could do anything with its input and return any value (as its name implies).&lt;/p&gt;
&lt;p&gt;This is very useful for disabling optimizations like the one we see above. For example, we can hint to the compiler that the vector will actually be used for something after every iteration of the for loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::hint::black_box;

fn push_cap(v: &amp;amp;mut Vec&amp;lt;i32&amp;gt;) {
    for i in 0..4 {
        v.push(i);
        black_box(v.as_ptr());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can find the unrolled for loop in our &lt;a href&#x3D;&quot;https://rust.godbolt.org/z/Ws1GGbY6Y&quot;&gt;optimized assembly output&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-asm&quot;&gt;  mov dword ptr [rbx], 0
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 4], 1
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 8], 2
  mov qword ptr [rsp + 8], rbx
  mov dword ptr [rbx + 12], 3
  mov qword ptr [rsp + 8], rbx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also see a side effect of calling &lt;code&gt;black_box&lt;/code&gt; in this assembly output. The instruction &lt;code&gt;mov qword ptr [rsp + 8], rbx&lt;/code&gt; is uselessly repeated after every iteration. This instruction writes the address &lt;code&gt;v.as_ptr()&lt;/code&gt; as the first argument of the function, which is never actually called.&lt;/p&gt;
&lt;p&gt;Notice that the generated code is not at all concerned with the possibility of allocations introduced by the &lt;code&gt;push&lt;/code&gt; call. This is because the compiler is still using the fact that we called &lt;code&gt;Vec::with_capacity(4)&lt;/code&gt; in the &lt;code&gt;bench_push&lt;/code&gt; function. You can play around with the placement of &lt;code&gt;black_box&lt;/code&gt;, or try using it in multiple places, to see its effects on compiler optimizations.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-remove&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-remove&quot;&gt;&lt;/a&gt;cargo remove&lt;/h3&gt;
&lt;p&gt;In Rust 1.62.0 we introduced &lt;code&gt;cargo add&lt;/code&gt;, a command line utility to add dependencies to your project. Now you can use &lt;code&gt;cargo remove&lt;/code&gt; to remove dependencies.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.source_text&quot;&gt;&lt;code&gt;proc_macro::Span::source_text&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.checked_add_signed&quot;&gt;&lt;code&gt;u*::{checked_add_signed, overflowing_add_signed, saturating_add_signed, wrapping_add_signed}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_add_unsigned&quot;&gt;&lt;code&gt;i*::{checked_add_unsigned, overflowing_add_unsigned, saturating_add_unsigned, wrapping_add_unsigned}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.checked_sub_unsigned&quot;&gt;&lt;code&gt;i*::{checked_sub_unsigned, overflowing_sub_unsigned, saturating_sub_unsigned, wrapping_sub_unsigned}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.first&quot;&gt;&lt;code&gt;BTreeSet::{first, last, pop_first, pop_last}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.first_key_value&quot;&gt;&lt;code&gt;BTreeMap::{first_key_value, last_key_value, first_entry, last_entry, pop_first, pop_last}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/101768/&quot;&gt;Add &lt;code&gt;AsFd&lt;/code&gt; implementations for stdio lock types on WASI.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#impl-TryFrom%3CVec%3CT%2C%20Global%3E%3E-for-Box%3C%5BT%3B%20N%5D%2C%20Global%3E&quot;&gt;&lt;code&gt;impl TryFrom&amp;lt;Vec&amp;lt;T&amp;gt;&amp;gt; for Box&amp;lt;[T; N]&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/hint/fn.black_box.html&quot;&gt;&lt;code&gt;core::hint::black_box&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.try_from_secs_f32&quot;&gt;&lt;code&gt;Duration::try_from_secs_{f32,f64}&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unzip&quot;&gt;&lt;code&gt;Option::unzip&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/fd/index.html&quot;&gt;&lt;code&gt;std::os::fd&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.66 release, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can now use &lt;code&gt;..&#x3D;X&lt;/code&gt; ranges in patterns.&lt;/li&gt;
&lt;li&gt;Linux builds now optimize the rustc frontend and LLVM backend with LTO and BOLT, respectively, improving both runtime performance and memory usage.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out everything that changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1660-2022-12-15&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-166-2022-12-15&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-166&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1660&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1660&quot;&gt;&lt;/a&gt;Contributors to 1.66.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.66.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.66.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Launching the 2022 State of Rust Survey</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/12/05/survey-launch.html" type="text/html" title="Launching the 2022 State of Rust Survey" />
        <published>2022-12-05T00:00:00+00:00</published>
        <updated>2022-12-05T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/12/05/survey-launch.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/12/05/survey-launch.html">&lt;p&gt;The &lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd&quot;&gt;2022 State of Rust Survey&lt;/a&gt; is here!&lt;/p&gt;
&lt;p&gt;It&#x27;s that time again! Time for us to take a look at who the Rust community is composed of, how the Rust project is doing, and how we can improve the Rust programming experience. The Rust Survey working group is pleased to announce our &lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd&quot;&gt;2022 State of Rust Survey&lt;/a&gt;! Whether or not you use Rust today, we want to know your opinions. Your responses will help the project understand its strengths and weaknesses, and establish development priorities for the future.&lt;/p&gt;
&lt;p&gt;Completing this survey should take about 5–20 minutes and is anonymous. We will be accepting submissions for the next two weeks (until the 19th of December), and we will share our findings on &lt;a href&#x3D;&quot;https://blog.rust-lang.org&quot;&gt;blog.rust-lang.org&lt;/a&gt; sometime in early 2023. You can also check out &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html&quot;&gt;last year’s results&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We&#x27;re happy to be offering the survey in the following languages. If you speak multiple languages, please pick one.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;en&quot;&gt;English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;zh-cn&quot;&gt;Simplified Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;zh-tw&quot;&gt;Traditional Chinese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;fr&quot;&gt;French&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;de&quot;&gt;German&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;ja&quot;&gt;Japanese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;ko&quot;&gt;Korean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;pt&quot;&gt;Portuguese&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;ru&quot;&gt;Russian&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;es&quot;&gt;Spanish&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://surveyhero.com/c/sfhmgxgd?lang&#x3D;uk&quot;&gt;Ukrainian&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please help us spread the word by sharing the survey link on your social network feeds, at meetups, around your office, and in other communities.&lt;/p&gt;
&lt;p&gt;If you have any questions, please see our &lt;a href&#x3D;&quot;https://github.com/rust-lang/surveys/blob/main/documents/Community-Survey-FAQ.md&quot;&gt;frequently asked questions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, we wanted to thank everyone who helped develop, polish, and test the survey.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Survey Working Group</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.65.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html" type="text/html" title="Announcing Rust 1.65.0" />
        <published>2022-11-03T00:00:00+00:00</published>
        <updated>2022-11-03T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/11/03/Rust-1.65.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.65.0. Rust is a
programming language empowering everyone to build reliable and efficient
software.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Before going into the details of the new Rust release, we&#x27;d like to draw
attention to the tragic &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Death_of_Mahsa_Amini&quot;&gt;death of Mahsa
Amini&lt;/a&gt; and the death and
violent suppression of many others, by the religious morality police of Iran.
See &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Mahsa_Amini_protests&quot;&gt;https://en.wikipedia.org/wiki/Mahsa_Amini_protests&lt;/a&gt; for more details. We
stand in solidarity with the people in Iran struggling for human rights.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.65.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get
&lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on
our website, and check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1650-2022-11-03&quot;&gt;detailed release notes for
1.65.0&lt;/a&gt;
on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider
updating locally to use the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly
channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you
might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1650-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1650-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.65.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#generic-associated-types-gats&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;generic-associated-types-gats&quot;&gt;&lt;/a&gt;Generic associated types (GATs)&lt;/h3&gt;
&lt;p&gt;Lifetime, type, and const generics can now be defined on associated types, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Foo {
    type Bar&amp;lt;&#x27;x&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#x27;s hard to put into few words just how useful these can be, so here are a
few example traits, to get a sense of their power:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;/// An &#x60;Iterator&#x60;-like trait that can borrow from &#x60;Self&#x60;
trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Option&amp;lt;Self::Item&amp;lt;&#x27;a&amp;gt;&amp;gt;;
}

/// Can be implemented over smart pointers, like &#x60;Rc&#x60; or &#x60;Arc&#x60;,
/// in order to allow being generic over the pointer type
trait PointerFamily {
    type Pointer&amp;lt;T&amp;gt;: Deref&amp;lt;Target &#x3D; T&amp;gt;;

    fn new&amp;lt;T&amp;gt;(value: T) -&amp;gt; Self::Pointer&amp;lt;T&amp;gt;;
}

/// Allows borrowing an array of items. Useful for
/// &#x60;NdArray&#x60;-like types that don&#x27;t necessarily store
/// data contiguously.
trait BorrowArray&amp;lt;T&amp;gt; {
    type Array&amp;lt;&#x27;x, const N: usize&amp;gt; where Self: &#x27;x;

    fn borrow_array&amp;lt;&#x27;a, const N: usize&amp;gt;(&amp;amp;&#x27;a self) -&amp;gt; Self::Array&amp;lt;&#x27;a, N&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, GATs are quite versatile and enable a number
of patterns that are not currently able to be written. For more
information, check out the post announcing the
&lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html&quot;&gt;push for stabilization&lt;/a&gt;
published last year or the
&lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/10/28/gats-stabilization.html&quot;&gt;stabilization announcement post&lt;/a&gt;
published last week. The former goes into a bit more depth
of a couple of the examples above, while the latter talks
about some of the known limitations of this stabilization.&lt;/p&gt;
&lt;p&gt;More in depth reading can be found in the associated types
section of the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/reference/items/associated-items.html#associated-types&quot;&gt;nightly reference&lt;/a&gt;
or the &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/1598-generic_associated_types.html&quot;&gt;original RFC&lt;/a&gt; (which was initially opened over 6.5 years ago!).&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#let-else-statements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;let-else-statements&quot;&gt;&lt;/a&gt;&lt;code&gt;let&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; statements&lt;/h3&gt;
&lt;p&gt;This introduces a new type of &lt;code&gt;let&lt;/code&gt; statement with a refutable pattern and a
diverging &lt;code&gt;else&lt;/code&gt; block that executes when that pattern doesn&#x27;t match.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let PATTERN: TYPE &#x3D; EXPRESSION else {
    DIVERGING_CODE;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Normal &lt;code&gt;let&lt;/code&gt; statements can only use &lt;em&gt;irrefutable&lt;/em&gt; patterns, statically known
to always match. That pattern is often just a single variable binding, but may
also unpack compound types like structs, tuples, and arrays. However, that was
not usable for conditional matches, like pulling out a variant of an enum --
until now! With &lt;code&gt;let&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, a refutable pattern can match and bind variables
in the surrounding scope like a normal &lt;code&gt;let&lt;/code&gt;, or else diverge (e.g. &lt;code&gt;break&lt;/code&gt;,
&lt;code&gt;return&lt;/code&gt;, &lt;code&gt;panic!&lt;/code&gt;) when the pattern doesn&#x27;t match.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn get_count_item(s: &amp;amp;str) -&amp;gt; (u64, &amp;amp;str) {
    let mut it &#x3D; s.split(&#x27; &#x27;);
    let (Some(count_str), Some(item)) &#x3D; (it.next(), it.next()) else {
        panic!(&amp;quot;Can&#x27;t segment count item pair: &#x27;{s}&#x27;&amp;quot;);
    };
    let Ok(count) &#x3D; u64::from_str(count_str) else {
        panic!(&amp;quot;Can&#x27;t parse integer: &#x27;{count_str}&#x27;&amp;quot;);
    };
    (count, item)
}
assert_eq!(get_count_item(&amp;quot;3 chairs&amp;quot;), (3, &amp;quot;chairs&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The scope of name bindings is the main thing that makes this different from
&lt;code&gt;match&lt;/code&gt; or &lt;code&gt;if let&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; expressions. You could previously approximate these
patterns with an unfortunate bit of repetition and an outer &lt;code&gt;let&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;    let (count_str, item) &#x3D; match (it.next(), it.next()) {
        (Some(count_str), Some(item)) &#x3D;&amp;gt; (count_str, item),
        _ &#x3D;&amp;gt; panic!(&amp;quot;Can&#x27;t segment count item pair: &#x27;{s}&#x27;&amp;quot;),
    };
    let count &#x3D; if let Ok(count) &#x3D; u64::from_str(count_str) {
        count
    } else {
        panic!(&amp;quot;Can&#x27;t parse integer: &#x27;{count_str}&#x27;&amp;quot;);
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#break-from-labeled-blocks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;break-from-labeled-blocks&quot;&gt;&lt;/a&gt;&lt;code&gt;break&lt;/code&gt; from labeled blocks&lt;/h3&gt;
&lt;p&gt;Plain block expressions can now be labeled as a &lt;code&gt;break&lt;/code&gt; target, terminating
that block early. This may sound a little like a &lt;code&gt;goto&lt;/code&gt; statement, but it&#x27;s not
an arbitrary jump, only from within a block to its end. This was already
possible with &lt;code&gt;loop&lt;/code&gt; blocks, and you may have seen people write loops that
always execute only once, just to get a labeled &lt;code&gt;break&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now there&#x27;s a language feature specifically for that! Labeled &lt;code&gt;break&lt;/code&gt; may also
include an expression value, just as with loops, letting a multi-statement
block have an early &amp;quot;return&amp;quot; value.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let result &#x3D; &#x27;block: {
    do_thing();
    if condition_not_met() {
        break &#x27;block 1;
    }
    do_next_thing();
    if condition_not_met() {
        break &#x27;block 2;
    }
    do_last_thing();
    3
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#splitting-linux-debuginfo&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;splitting-linux-debuginfo&quot;&gt;&lt;/a&gt;Splitting Linux debuginfo&lt;/h3&gt;
&lt;p&gt;Back in Rust 1.51, the compiler team added support for &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#splitting-debug-information&quot;&gt;split debug
information&lt;/a&gt;
on macOS, and now this option is stable for use on Linux as well.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-Csplit-debuginfo&#x3D;unpacked&lt;/code&gt; will split debuginfo out into multiple &lt;code&gt;.dwo&lt;/code&gt;
DWARF object files.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Csplit-debuginfo&#x3D;packed&lt;/code&gt; will produce a single &lt;code&gt;.dwp&lt;/code&gt; DWARF package
alongside your output binary with all the debuginfo packaged together.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-Csplit-debuginfo&#x3D;off&lt;/code&gt; is still the default behavior, which includes DWARF
data in &lt;code&gt;.debug_*&lt;/code&gt; ELF sections of the objects and final binary.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Split DWARF lets the linker avoid processing the debuginfo (because it isn&#x27;t in
the object files being linked anymore), which can speed up link times!&lt;/p&gt;
&lt;p&gt;Other targets now also accept &lt;code&gt;-Csplit-debuginfo&lt;/code&gt; as a stable option with their
platform-specific default value, but specifying other values is still unstable.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/backtrace/struct.Backtrace.html&quot;&gt;&lt;code&gt;std::backtrace::Backtrace&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ops/enum.Bound.html#method.as_ref&quot;&gt;&lt;code&gt;Bound::as_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/fn.read_to_string.html&quot;&gt;&lt;code&gt;std::io::read_to_string&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_mut&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::cast_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.cast_const&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::cast_const&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of particular note, the &lt;code&gt;Backtrace&lt;/code&gt; API allows capturing a stack backtrace at
any time, using the same platform-specific implementation that usually serves
panic backtraces. This may be useful for adding runtime context to error types,
for example.&lt;/p&gt;
&lt;p&gt;These APIs are now usable in const contexts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::offset_from&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset_from&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::offset_from&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#compatibility-notes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;compatibility-notes&quot;&gt;&lt;/a&gt;Compatibility notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;As the final step of the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html&quot;&gt;RLS
deprecation&lt;/a&gt;,
this release has replaced RLS with a small LSP server showing a deprecation
warning, advising users to migrate to &lt;code&gt;rust-analyzer&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.65 release, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MIR inlining is now enabled for optimized compilations. This provides a 3-10%
improvement in compiletimes for real world crates.&lt;/li&gt;
&lt;li&gt;When scheduling builds, Cargo now sorts the queue of pending jobs to improve performance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out everything that changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1650-2022-11-03&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-165-2022-11-03&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-165&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1650&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1650&quot;&gt;&lt;/a&gt;Contributors to 1.65.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.65.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.65.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Generic associated types to be stable in Rust 1.65</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/10/28/gats-stabilization.html" type="text/html" title="Generic associated types to be stable in Rust 1.65" />
        <published>2022-10-28T00:00:00+00:00</published>
        <updated>2022-10-28T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/10/28/gats-stabilization.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/10/28/gats-stabilization.html">&lt;p&gt;As of Rust 1.65, which is set to release on November 3rd, generic associated types (GATs) will be stable — over six and a half years after the original &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;RFC&lt;/a&gt; was opened. This is truly a monumental achievement; however, as with a few of the other monumental features of Rust, like &lt;code&gt;async&lt;/code&gt; or const generics, there are limitations in the initial stabilization that we plan to remove in the future.&lt;/p&gt;
&lt;p&gt;The goal of this post is not to teach about GATs, but rather to briefly introduce them to any readers that might not know what they are and to enumerate a few of the limitations in initial stabilization that users are most likely to run into. More detailed information can be found in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/1598&quot;&gt;RFC&lt;/a&gt;, in the &lt;a href&#x3D;&quot;https://rust-lang.github.io/generic-associated-types-initiative/index.html&quot;&gt;GATs initiative repository&lt;/a&gt;, in the previous &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html&quot;&gt;blog post&lt;/a&gt; during the start of the stabilization push, in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/reference/items/associated-items.html&quot;&gt;associated items section in the nightly reference&lt;/a&gt;, or in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aopen+is%3Aissue+label%3AF-generic_associated_types&quot;&gt;open issues on Github for GATs&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-are-gats&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-are-gats&quot;&gt;&lt;/a&gt;What are GATs&lt;/h2&gt;
&lt;p&gt;At its core, generic associated types allow you to have &lt;em&gt;generics&lt;/em&gt; (type, lifetime, or const) on &lt;em&gt;associated types&lt;/em&gt;. Note that this is really just rounding out the places where you can put generics: for example, you can already have generics on freestanding type aliases and on functions in traits. Now you can just have generics on type aliases in traits (which we just call associated types). Here&#x27;s an example of what a trait with a GAT would look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Self::Item&amp;lt;&#x27;a&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Most of this should look familiar; this trait looks &lt;em&gt;very&lt;/em&gt; similar to the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt; trait from the standard library. Fundamentally, this version of the trait allows the &lt;code&gt;next&lt;/code&gt; function to return an item that &lt;em&gt;borrows&lt;/em&gt; from &lt;code&gt;self&lt;/code&gt;. For more detail about the example, as well as some info on what that &lt;code&gt;where Self: &#x27;a&lt;/code&gt; is for, check out the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html&quot;&gt;push for stabilization post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In general, GATs provide a foundational basis for a vast range of patterns and APIs. If you really want to get a feel for how many projects have been blocked on GATs being stable, go scroll through either the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/44265&quot;&gt;tracking issue&lt;/a&gt;: you will find numerous issues from other projects linking to those threads over the years saying something along the lines of &amp;quot;we want the API to look like X, but for that we need GATs&amp;quot; (or see &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/96709#issuecomment-1173170243&quot;&gt;this comment&lt;/a&gt; that has some of these put together already). If you&#x27;re interested in how GATs enable a library to do zero-copy parsing, resulting in nearly a ten-fold performance increase, you might be interested in checking out a &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2022/06/27/many-modes-a-gats-pattern/&quot;&gt;blog post&lt;/a&gt; on it by Niko Matsakis.&lt;/p&gt;
&lt;p&gt;All in all, even if &lt;em&gt;you&lt;/em&gt; won&#x27;t need to use GATs directly, it&#x27;s very possible that the &lt;em&gt;libraries&lt;/em&gt; you use will use GATs either internally or publically for ergonomics, performance, or just because that&#x27;s the only way the implementation works.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#when-gats-go-wrong---a-few-current-bugs-and-limitations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;when-gats-go-wrong---a-few-current-bugs-and-limitations&quot;&gt;&lt;/a&gt;When GATs go wrong - a few current bugs and limitations&lt;/h2&gt;
&lt;p&gt;As alluded to before, this stabilization is not without its bugs and limitations. This is not atypical compared to prior large language features. We plan to fix these bugs and remove these limitations as part of ongoing efforts driven by the newly-formed types team. (Stayed tuned for more details in an official announcement soon!)&lt;/p&gt;
&lt;p&gt;Here, we&#x27;ll go over just a couple of the limitations that we&#x27;ve identified that users might run into.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#implied-static-requirement-from-higher-ranked-trait-bounds&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;implied-static-requirement-from-higher-ranked-trait-bounds&quot;&gt;&lt;/a&gt;Implied &lt;code&gt;&#x27;static&lt;/code&gt; requirement from higher-ranked trait bounds&lt;/h3&gt;
&lt;p&gt;Consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;
}

pub struct WindowsMut&amp;lt;&#x27;x, T&amp;gt; {
    slice: &amp;amp;&#x27;x mut [T],
}

impl&amp;lt;&#x27;x, T&amp;gt; LendingIterator for WindowsMut&amp;lt;&#x27;x, T&amp;gt; {
    type Item&amp;lt;&#x27;a&amp;gt; &#x3D; &amp;amp;&#x27;a mut [T] where Self: &#x27;a;
}

fn print_items&amp;lt;I&amp;gt;(iter: I)
where
    I: LendingIterator,
    for&amp;lt;&#x27;a&amp;gt; I::Item&amp;lt;&#x27;a&amp;gt;: Debug,
{ ... }

fn main() {
    let mut array &#x3D; [0; 16];
    let slice &#x3D; &amp;amp;mut array;
    let windows &#x3D; WindowsMut { slice };
    print_items::&amp;lt;WindowsMut&amp;lt;&#x27;_, usize&amp;gt;&amp;gt;(windows);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, imagine we wanted to have a &lt;code&gt;LendingIterator&lt;/code&gt; where the items are overlapping slices of an array. We also have a function &lt;code&gt;print_items&lt;/code&gt; that prints every item of a &lt;code&gt;LendingIterator&lt;/code&gt;, as long as they implement &lt;code&gt;Debug&lt;/code&gt;. This all seems innocent enough, but the above code doesn&#x27;t compile — even though it should. Without going into details here, the &lt;code&gt;for&amp;lt;&#x27;a&amp;gt; I::Item&amp;lt;&#x27;a&amp;gt;: Debug&lt;/code&gt; currently implies that &lt;code&gt;I::Item&amp;lt;&#x27;a&amp;gt;&lt;/code&gt; must outlive &lt;code&gt;&#x27;static&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is not really a nice bug. And of all the ones we&#x27;ll mention today, this will likely be the one that is most limiting, annoying, and tough to figure out. This pops up much more often with GATs, but can be found with code that doesn&#x27;t use GATs at all. Unfortunately, fixing this requires some refactorings to the compiler that isn&#x27;t a short-term project. It is on the horizon though. The good news is that, in the meantime, we are working on improving the error message you get from this code. This is what it will look like in the upcoming stabilization:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error[E0597]: &#x60;array&#x60; does not live long enough
   |
   |     let slice &#x3D; &amp;amp;mut array;
   |                 ^^^^^^^^^^ borrowed value does not live long enough
   |     let windows &#x3D; WindowsMut { slice };
   |     print_items::&amp;lt;WindowsMut&amp;lt;&#x27;_, usize&amp;gt;&amp;gt;(windows);
   |     -------------------------------------------- argument requires that &#x60;array&#x60; is borrowed for &#x60;&#x27;static&#x60;
   | }
   | - &#x60;array&#x60; dropped here while still borrowed
   |
note: due to current limitations in the borrow checker, this implies a &#x60;&#x27;static&#x60; lifetime
   |
   |     for&amp;lt;&#x27;a&amp;gt; I::Item&amp;lt;&#x27;a&amp;gt;: Debug,
   |                          ^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#x27;s not perfect, but it&#x27;s something. It might not cover all cases, but if have a &lt;code&gt;for&amp;lt;&#x27;a&amp;gt; I::Item&amp;lt;&#x27;a&amp;gt;: Trait&lt;/code&gt; bound somewhere and get an error that says something doesn&#x27;t live long enough, you might be running into this bug. We&#x27;re actively working to fix this. However, this error doesn&#x27;t actually come up as often as you might expect while reading this (from our experience), so we feel the feature is still immensely useful enough even with it around.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#traits-with-gats-are-not-object-safe&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;traits-with-gats-are-not-object-safe&quot;&gt;&lt;/a&gt;Traits with GATs are not object safe&lt;/h3&gt;
&lt;p&gt;So, this one is a simple one. Making traits with GATs object safe is going to take a little bit of design work for its implementation. To get an idea of the work left to do here, let&#x27;s start with a bit of code that you could write on stable today:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn takes_iter(_: &amp;amp;dyn Iterator) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well, you can write this, but it doesn&#x27;t compile:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error[E0191]: the value of the associated type &#x60;Item&#x60; (from trait &#x60;Iterator&#x60;) must be specified
 --&amp;gt; src/lib.rs:1:23
  |
1 | fn takes_iter(_: &amp;amp;dyn Iterator) {}
  |                       ^^^^^^^^ help: specify the associated type: &#x60;Iterator&amp;lt;Item &#x3D; Type&amp;gt;&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a trait object to be well-formed, it must specify a value for all associated types. For the same reason, we don&#x27;t want to accept the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn no_associated_type(_: &amp;amp;dyn LendingIterator) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, GATs introduce an extra bit of complexity. Take this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn not_fully_generic(_: &amp;amp;dyn LendingIterator&amp;lt;Item&amp;lt;&#x27;static&amp;gt; &#x3D; &amp;amp;&#x27;static str&amp;gt;) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, we&#x27;ve specified the value of the associated type for &lt;em&gt;one&lt;/em&gt; value of of the &lt;code&gt;Item&lt;/code&gt;&#x27;s lifetime (&lt;code&gt;&#x27;static&lt;/code&gt;), but not for &lt;em&gt;any&lt;/em&gt; value, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn fully_generic(_: &amp;amp;dyn for&amp;lt;&#x27;a&amp;gt; LendingIterator&amp;lt;Item&amp;lt;&#x27;a&amp;gt; &#x3D; &amp;amp;&#x27;a str&amp;gt;) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While we have a solid idea of how to implement requirement in some &lt;em&gt;future&lt;/em&gt; iterations of the trait solver (that uses more logical formulations), implementing it in the current trait solver is more difficult. Thus, we&#x27;ve chosen to hold off on this for now.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#the-borrow-checker-isnt-perfect-and-it-shows&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-borrow-checker-isnt-perfect-and-it-shows&quot;&gt;&lt;/a&gt;The borrow checker isn&#x27;t perfect and it shows&lt;/h3&gt;
&lt;p&gt;Keeping with the &lt;code&gt;LendingIterator&lt;/code&gt; example, let&#x27;s start by looking at two methods on &lt;code&gt;Iterator&lt;/code&gt;: &lt;code&gt;for_each&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait Iterator {
    type Item;

    fn for_each&amp;lt;F&amp;gt;(self, f: F)
    where
        Self: Sized,
        F: FnMut(Self::Item);
    
    fn filter&amp;lt;P&amp;gt;(self, predicate: P) -&amp;gt; Filter&amp;lt;Self, P&amp;gt;
    where
        Self: Sized,
        P: FnMut(&amp;amp;Self::Item) -&amp;gt; bool;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both of these take a function as an argument. Closures are often used these. Now, let&#x27;s look at the &lt;code&gt;LendingIterator&lt;/code&gt; definitions:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a;

    fn for_each&amp;lt;F&amp;gt;(mut self, mut f: F)
    where
        Self: Sized,
        F: FnMut(Self::Item&amp;lt;&#x27;_&amp;gt;);

    fn filter&amp;lt;P&amp;gt;(self, predicate: P) -&amp;gt; Filter&amp;lt;Self, P&amp;gt;
    where
        Self: Sized,
        P: FnMut(&amp;amp;Self::Item&amp;lt;&#x27;_&amp;gt;) -&amp;gt; bool;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks simple enough, but if it really was, would it be here? Let&#x27;s start by looking at what happens when we try to use &lt;code&gt;for_each&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn iterate&amp;lt;T, I: for&amp;lt;&#x27;a&amp;gt; LendingIterator&amp;lt;Item&amp;lt;&#x27;a&amp;gt; &#x3D; &amp;amp;&#x27;a T&amp;gt;&amp;gt;(iter: I) {
    iter.for_each(|_: &amp;amp;T| {})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error: &#x60;I&#x60; does not live long enough
   |
   |     iter.for_each(|_: &amp;amp;T| {})
   |                   ^^^^^^^^^^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well, that isn&#x27;t great. Turns out, this is pretty closely related to the first limitation we talked about earlier, even
though the borrow checker does play a role here.&lt;/p&gt;
&lt;p&gt;On the other hand, let&#x27;s look at something that&#x27;s very clearly a borrow checker problem, by looking at an implementation
of the &lt;code&gt;Filter&lt;/code&gt; struct returned by the &lt;code&gt;filter&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl&amp;lt;I: LendingIterator, P&amp;gt; LendingIterator for Filter&amp;lt;I, P&amp;gt;
where
    P: FnMut(&amp;amp;I::Item&amp;lt;&#x27;_&amp;gt;) -&amp;gt; bool, // &amp;lt;- the bound from above, a function
{
    type Item&amp;lt;&#x27;a&amp;gt; &#x3D; I::Item&amp;lt;&#x27;a&amp;gt; where Self: &#x27;a; // &amp;lt;- Use the underlying type

    fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;I::Item&amp;lt;&#x27;_&amp;gt;&amp;gt; {
        // Loop through each item in the underlying &#x60;LendingIterator&#x60;...
        while let Some(item) &#x3D; self.iter.next() {
            // ...check if the predicate holds for the item...
            if (self.predicate)(&amp;amp;item) {
                // ...and return it if it does
                return Some(item);
            }
        }
        // Return &#x60;None&#x60; when we&#x27;re out of items
        return None;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, the implementation here shouldn&#x27;t seem surprising. We, of course, run into a borrow checker error:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error[E0499]: cannot borrow &#x60;self.iter&#x60; as mutable more than once at a time
  --&amp;gt; src/main.rs:28:32
   |
27 |     fn next(&amp;amp;mut self) -&amp;gt; Option&amp;lt;I::Item&amp;lt;&#x27;_&amp;gt;&amp;gt; {
   |             - let&#x27;s call the lifetime of this reference &#x60;&#x27;1&#x60;
28 |         while let Some(item) &#x3D; self.iter.next() {
   |                                ^^^^^^^^^^^^^^^^ &#x60;self.iter&#x60; was mutably borrowed here in the previous iteration of the loop
29 |             if (self.predicate)(&amp;amp;item) {
30 |                 return Some(item);
   |                        ---------- returning this value requires that &#x60;self.iter&#x60; is borrowed for &#x60;&#x27;1&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a known limitation in the current borrow checker and should be solved in some future iteration (like &lt;a href&#x3D;&quot;https://github.com/rust-lang/polonius&quot;&gt;Polonius&lt;/a&gt;).&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#non-local-requirements-for-where-clauses-on-gats&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;non-local-requirements-for-where-clauses-on-gats&quot;&gt;&lt;/a&gt;Non-local requirements for where clauses on GATs&lt;/h3&gt;
&lt;p&gt;The last limitation we&#x27;ll talk about today is a bit different than the others; it&#x27;s not a bug and it shouldn&#x27;t prevent any programs from compiling. But it all comes back to that &lt;code&gt;where Self: &#x27;a&lt;/code&gt; clause you&#x27;ve seen in several parts of this post. As mentioned before, if you&#x27;re interested in digging a bit into why that clause is required, see the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html&quot;&gt;push for stabilization post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There is one not-so-ideal requirement about this clause: you must write it on the trait. Like with where clauses on functions, you cannot add clauses to associated types in impls that aren&#x27;t there in the trait. However, if you &lt;em&gt;didn&#x27;t&lt;/em&gt; add this clause, a large set of potential impls of the trait would be disallowed.&lt;/p&gt;
&lt;p&gt;To help users not fall into the pitfall of accidentally forgetting to add this (or similar clauses that end up with the same effect for a different set of generics), we&#x27;ve implemented a set of rules that must be followed for a trait with GATs to compile. Let&#x27;s first look at the error without writing the clause:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;trait LendingIterator {
    type Item&amp;lt;&#x27;a&amp;gt;;

    fn next&amp;lt;&#x27;a&amp;gt;(&amp;amp;&#x27;a mut self) -&amp;gt; Self::Item&amp;lt;&#x27;a&amp;gt;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;error: missing required bound on &#x60;Item&#x60;
 --&amp;gt; src/lib.rs:2:5
  |
2 |     type Item&amp;lt;&#x27;a&amp;gt;;
  |     ^^^^^^^^^^^^^-
  |                  |
  |                  help: add the required where clause: &#x60;where Self: &#x27;a&#x60;
  |
  &#x3D; note: this bound is currently required to ensure that impls have maximum flexibility
  &#x3D; note: we are soliciting feedback, see issue #87479 &amp;lt;https://github.com/rust-lang/rust/issues/87479&amp;gt; for more information
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This error should hopefully be helpful (you can even &lt;code&gt;cargo fix&lt;/code&gt; it!). But, what exactly are these rules? Well, ultimately, they end up being somewhat simple: &lt;em&gt;for methods that use the GAT, any bounds that can be proven must also be present on the GAT itself&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Okay, so how did we end up with the required &lt;code&gt;Self: &#x27;a&lt;/code&gt; bound. Well, let&#x27;s take a look at the &lt;code&gt;next&lt;/code&gt; method. It returns &lt;code&gt;Self::Item&amp;lt;&#x27;a&amp;gt;&lt;/code&gt;, and we have an argument &lt;code&gt;&amp;amp;&#x27;a mut self&lt;/code&gt;. We&#x27;re getting a bit into the details of the Rust language, but because of that argument, we know that &lt;code&gt;Self: &#x27;a&lt;/code&gt; must hold. So, we require that bound.&lt;/p&gt;
&lt;p&gt;We&#x27;re requiring these bounds now to leave room in the future to potentially imply these automatically (and of course because it should help users write traits with GATs). They shouldn&#x27;t interfere with any real use-cases, but if you do encounter a problem, check out the issue mentioned in the error above. And if you want to see a fairly comprehensive testing of different scenarios on what bounds are required and when, check out the relevant &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/f2702e922ba31e49d6167f5651d4545646dcf22d/src/test/ui/generic-associated-types/self-outlives-lint.rs&quot;&gt;test file&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Hopefully the limitations brought up here and explanations thereof don&#x27;t detract from overall excitement of GATs stabilization. Sure, these limitations do, well, &lt;em&gt;limit&lt;/em&gt; the number of things you can do with GATs. &lt;em&gt;However&lt;/em&gt;, we would not be stabilizing GATs if we didn&#x27;t feel that GATs are not still &lt;em&gt;very&lt;/em&gt; useful. Additionally, we wouldn&#x27;t be stabilizing GATs if we didn&#x27;t feel that the limitations weren&#x27;t solvable (and in a backwards-compatible manner).&lt;/p&gt;
&lt;p&gt;To conclude things, all the various people involved in getting this stabilization to happen deserve the utmost thanks. As said before, it&#x27;s been 6.5 years coming and it couldn&#x27;t have happened without everyone&#x27;s support and dedication. Thanks all!&lt;/p&gt;
</content>

        <author>
            <name>Jack Huey</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.64.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html" type="text/html" title="Announcing Rust 1.64.0" />
        <published>2022-09-22T00:00:00+00:00</published>
        <updated>2022-09-22T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.64.0. Rust is a
programming language empowering everyone to build reliable and efficient
software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.64.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get
&lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on
our website, and check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22&quot;&gt;detailed release notes for
1.64.0&lt;/a&gt;
on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider
updating locally to use the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly
channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you
might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1640-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1640-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.64.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#enhancing-await-with-intofuture&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;enhancing-await-with-intofuture&quot;&gt;&lt;/a&gt;Enhancing &lt;code&gt;.await&lt;/code&gt; with &lt;code&gt;IntoFuture&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Rust 1.64 stabilizes the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/future/trait.IntoFuture.html&quot;&gt;&lt;code&gt;IntoFuture&lt;/code&gt;&lt;/a&gt;
trait. &lt;code&gt;IntoFuture&lt;/code&gt; is a trait similar to
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/iter/trait.IntoIterator.html&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;,
but rather than supporting &lt;code&gt;for ... in ...&lt;/code&gt; loops, &lt;code&gt;IntoFuture&lt;/code&gt; changes how
&lt;code&gt;.await&lt;/code&gt; works. With &lt;code&gt;IntoFuture&lt;/code&gt;, the &lt;code&gt;.await&lt;/code&gt; keyword can await more than
just futures; it can await &lt;em&gt;anything which can be converted into a &lt;code&gt;Future&lt;/code&gt; via
&lt;code&gt;IntoFuture&lt;/code&gt;&lt;/em&gt; - which can help make your APIs more user-friendly!&lt;/p&gt;
&lt;p&gt;Take for example a builder which constructs requests to some storage provider
over the network:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub struct Error { ... }
pub struct StorageResponse { ... }:
pub struct StorageRequest(bool);

impl StorageRequest {
    /// Create a new instance of &#x60;StorageRequest&#x60;.
    pub fn new() -&amp;gt; Self { ... }
    /// Decide whether debug mode should be enabled.
    pub fn set_debug(self, b: bool) -&amp;gt; Self { ... }
    /// Send the request and receive a response.
    pub async fn send(self) -&amp;gt; Result&amp;lt;StorageResponse, Error&amp;gt; { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typical usage would likely look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let response &#x3D; StorageRequest::new()  // 1. create a new instance
    .set_debug(true)                  // 2. set some option
    .send()                           // 3. construct the future
    .await?;                          // 4. run the future + propagate errors
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is not bad, but we can do better here. Using &lt;code&gt;IntoFuture&lt;/code&gt; we can combine
&lt;em&gt;&amp;quot;construct the future&amp;quot;&lt;/em&gt; (line 3) and &lt;em&gt;&amp;quot;run the future&amp;quot;&lt;/em&gt; (line 4) into a single
step:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let response &#x3D; StorageRequest::new()  // 1. create a new instance
    .set_debug(true)                  // 2. set some option
    .await?;                          // 3. construct + run the future + propagate errors
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can do this by implementing &lt;code&gt;IntoFuture&lt;/code&gt; for &lt;code&gt;StorageRequest&lt;/code&gt;. &lt;code&gt;IntoFuture&lt;/code&gt;
requires us to have a named future we can return, which we can do by creating a
&amp;quot;boxed future&amp;quot; and defining a type alias for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// First we must import some new types into the scope.
use std::pin::Pin;
use std::future::{Future, IntoFuture};

pub struct Error { ... }
pub struct StorageResponse { ... }
pub struct StorageRequest(bool);

impl StorageRequest {
    /// Create a new instance of &#x60;StorageRequest&#x60;.
    pub fn new() -&amp;gt; Self { ... }
    /// Decide whether debug mode should be enabled.
    pub fn set_debug(self, b: bool) -&amp;gt; Self { ... }
    /// Send the request and receive a response.
    pub async fn send(self) -&amp;gt; Result&amp;lt;StorageResponse, Error&amp;gt; { ... }
}

// The new implementations:
// 1. create a new named future type
// 2. implement &#x60;IntoFuture&#x60; for &#x60;StorageRequest&#x60;
pub type StorageRequestFuture &#x3D; Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output &#x3D; Result&amp;lt;StorageResponse, Error&amp;gt;&amp;gt; + Send + &#x27;static&amp;gt;&amp;gt;
impl IntoFuture for StorageRequest {
    type IntoFuture &#x3D; StorageRequestFuture;
    type Output &#x3D; &amp;lt;StorageRequestFuture as Future&amp;gt;::Output;
    fn into_future(self) -&amp;gt; Self::IntoFuture {
        Box::pin(self.send())
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This takes a bit more code to implement, but provides a simpler API for users.&lt;/p&gt;
&lt;p&gt;In the future, the Rust Async WG hopes to simplify the creating new named
futures by supporting &lt;a href&#x3D;&quot;https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt; in &lt;code&gt;type&lt;/code&gt; aliases (Type Alias Impl Trait or
TAIT)&lt;/a&gt;.
This should make implementing &lt;code&gt;IntoFuture&lt;/code&gt; easier by simplifying the type
alias&#x27; signature, and make it more performant by removing the &lt;code&gt;Box&lt;/code&gt; from the
type alias.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#c-compatible-ffi-types-in-core-and-alloc&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;c-compatible-ffi-types-in-core-and-alloc&quot;&gt;&lt;/a&gt;C-compatible FFI types in core and alloc&lt;/h3&gt;
&lt;p&gt;When calling or being called by C ABIs, Rust code can use type aliases like
&lt;code&gt;c_uint&lt;/code&gt; or &lt;code&gt;c_ulong&lt;/code&gt; to match the corresponding types from C on any target,
without requiring target-specific code or conditionals.&lt;/p&gt;
&lt;p&gt;Previously, these type aliases were only available in &lt;code&gt;std&lt;/code&gt;, so code written
for embedded targets and other scenarios that could only use &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;alloc&lt;/code&gt;
could not use these types.&lt;/p&gt;
&lt;p&gt;Rust 1.64 now provides all of the &lt;code&gt;c_*&lt;/code&gt; type aliases in
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/ffi/index.html&quot;&gt;&lt;code&gt;core::ffi&lt;/code&gt;&lt;/a&gt;, as well as
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/ffi/struct.CStr.html&quot;&gt;&lt;code&gt;core::ffi::CStr&lt;/code&gt;&lt;/a&gt; for
working with C strings. Rust 1.64 also provides
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/alloc/ffi/struct.CString.html&quot;&gt;&lt;code&gt;alloc::ffi::CString&lt;/code&gt;&lt;/a&gt;
for working with owned C strings using only the &lt;code&gt;alloc&lt;/code&gt; crate, rather than the
full &lt;code&gt;std&lt;/code&gt; library.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#rust-analyzer-is-now-available-via-rustup&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-analyzer-is-now-available-via-rustup&quot;&gt;&lt;/a&gt;rust-analyzer is now available via rustup&lt;/h3&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://rust-analyzer.github.io/&quot;&gt;rust-analyzer&lt;/a&gt; is now included as part of
the collection of tools included with Rust. This makes it easier to download
and access rust-analyzer, and makes it available on more platforms. It is
available as a &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/concepts/components.html&quot;&gt;rustup
component&lt;/a&gt; which
can be installed with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup component add rust-analyzer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this time, to run the rustup-installed version, you need to invoke it this
way:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup run stable rust-analyzer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next release of rustup will provide a built-in proxy so that running the
executable &lt;code&gt;rust-analyzer&lt;/code&gt; will launch the appropriate version.&lt;/p&gt;
&lt;p&gt;Most users should continue to use the releases provided by the rust-analyzer
team (available on the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-analyzer/releases&quot;&gt;rust-analyzer releases
page&lt;/a&gt;), which are
published more frequently. Users of the &lt;a href&#x3D;&quot;https://marketplace.visualstudio.com/items?itemName&#x3D;rust-lang.rust-analyzer&quot;&gt;official VSCode
extension&lt;/a&gt;
are not affected since it automatically downloads and updates releases in the
background.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-improvements-workspace-inheritance-and-multi-target-builds&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-improvements-workspace-inheritance-and-multi-target-builds&quot;&gt;&lt;/a&gt;Cargo improvements: workspace inheritance and multi-target builds&lt;/h3&gt;
&lt;p&gt;When working with collections of related libraries or binary crates in one
Cargo workspace, you can now avoid duplication of common field values between
crates, such as common version numbers, repository URLs, or &lt;code&gt;rust-version&lt;/code&gt;.
This also helps keep these values in sync between crates when updating them.
For more details, see
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table&quot;&gt;&lt;code&gt;workspace.package&lt;/code&gt;&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-dependencies-table&quot;&gt;&lt;code&gt;workspace.dependencies&lt;/code&gt;&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace&quot;&gt;&amp;quot;inheriting a dependency from a
workspace&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When building for multiple targets, you can now pass multiple &lt;code&gt;--target&lt;/code&gt;
options to &lt;code&gt;cargo build&lt;/code&gt;, to build all of those targets at once. You can also
set
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/config.html#buildtarget&quot;&gt;&lt;code&gt;build.target&lt;/code&gt;&lt;/a&gt;
to an array of multiple targets in &lt;code&gt;.cargo/config.toml&lt;/code&gt; to build for multiple
targets by default.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/future/trait.IntoFuture.html&quot;&gt;&lt;code&gt;future::IntoFuture&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_mul&quot;&gt;&lt;code&gt;num::NonZero*::checked_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_pow&quot;&gt;&lt;code&gt;num::NonZero*::checked_pow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_mul&quot;&gt;&lt;code&gt;num::NonZero*::saturating_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_pow&quot;&gt;&lt;code&gt;num::NonZero*::saturating_pow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.abs&quot;&gt;&lt;code&gt;num::NonZeroI*::abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.checked_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::checked_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.overflowing_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::overflowing_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.saturating_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::saturating_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.unsigned_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::unsigned_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.wrapping_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::wrapping_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_add&quot;&gt;&lt;code&gt;num::NonZeroU*::checked_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_next_power_of_two&quot;&gt;&lt;code&gt;num::NonZeroU*::checked_next_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_add&quot;&gt;&lt;code&gt;num::NonZeroU*::saturating_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/process/trait.CommandExt.html#tymethod.process_group&quot;&gt;&lt;code&gt;os::unix::process::CommandExt::process_group&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_dir&quot;&gt;&lt;code&gt;os::windows::fs::FileTypeExt::is_symlink_dir&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_file&quot;&gt;&lt;code&gt;os::windows::fs::FileTypeExt::is_symlink_file&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These types were previously stable in &lt;code&gt;std::ffi&lt;/code&gt;, but are now also available in
&lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/ffi/struct.CStr.html&quot;&gt;&lt;code&gt;core::ffi::CStr&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/ffi/struct.FromBytesWithNulError.html&quot;&gt;&lt;code&gt;core::ffi::FromBytesWithNulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.CString.html&quot;&gt;&lt;code&gt;alloc::ffi::CString&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.FromVecWithNulError.html&quot;&gt;&lt;code&gt;alloc::ffi::FromVecWithNulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.IntoStringError.html&quot;&gt;&lt;code&gt;alloc::ffi::IntoStringError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.NulError.html&quot;&gt;&lt;code&gt;alloc::ffi::NulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These types were previously stable in &lt;code&gt;std::os::raw&lt;/code&gt;, but are now also
available in &lt;code&gt;core::ffi&lt;/code&gt; and &lt;code&gt;std::ffi&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_char.html&quot;&gt;&lt;code&gt;ffi::c_char&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_double.html&quot;&gt;&lt;code&gt;ffi::c_double&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_float.html&quot;&gt;&lt;code&gt;ffi::c_float&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_int.html&quot;&gt;&lt;code&gt;ffi::c_int&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_long.html&quot;&gt;&lt;code&gt;ffi::c_long&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_longlong.html&quot;&gt;&lt;code&gt;ffi::c_longlong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_schar.html&quot;&gt;&lt;code&gt;ffi::c_schar&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_short.html&quot;&gt;&lt;code&gt;ffi::c_short&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_uchar.html&quot;&gt;&lt;code&gt;ffi::c_uchar&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_uint.html&quot;&gt;&lt;code&gt;ffi::c_uint&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ulong.html&quot;&gt;&lt;code&gt;ffi::c_ulong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ulonglong.html&quot;&gt;&lt;code&gt;ffi::c_ulonglong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ushort.html&quot;&gt;&lt;code&gt;ffi::c_ushort&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&#x27;ve stabilized some helpers for use with &lt;code&gt;Poll&lt;/code&gt;, the low-level implementation
underneath futures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/future/fn.poll_fn.html&quot;&gt;&lt;code&gt;future::poll_fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/task/macro.ready.html&quot;&gt;&lt;code&gt;task::ready!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future, we hope to provide simpler APIs that require less use of
low-level details like &lt;code&gt;Poll&lt;/code&gt; and &lt;code&gt;Pin&lt;/code&gt;, but in the meantime, these helpers
make it easier to write such code.&lt;/p&gt;
&lt;p&gt;These APIs are now usable in const contexts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/slice/fn.from_raw_parts.html&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#compatibility-notes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;compatibility-notes&quot;&gt;&lt;/a&gt;Compatibility notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;As &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/08/01/Increasing-glibc-kernel-requirements.html&quot;&gt;previously
announced&lt;/a&gt;,
&lt;code&gt;linux&lt;/code&gt; targets now require at least Linux kernel 3.2 (except for targets which
already required a newer kernel), and &lt;code&gt;linux-gnu&lt;/code&gt; targets now require glibc
2.17 (except for targets which already required a newer glibc).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rust 1.64.0 changes the memory layout of &lt;code&gt;Ipv4Addr&lt;/code&gt;, &lt;code&gt;Ipv6Addr&lt;/code&gt;,
&lt;code&gt;SocketAddrV4&lt;/code&gt; and &lt;code&gt;SocketAddrV6&lt;/code&gt; to be more compact and memory efficient.
This internal representation was never exposed, but some crates relied on
it anyway by using &lt;code&gt;std::mem::transmute&lt;/code&gt;, resulting in invalid memory
accesses. Such internal implementation details of the standard library are
&lt;em&gt;never&lt;/em&gt; considered a stable interface. To limit the damage, we worked with
the authors of all of the still-maintained crates doing so to release fixed
versions, which have been out for more than a year. The vast majority of
impacted users should be able to mitigate with a &lt;code&gt;cargo update&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As part of the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html&quot;&gt;RLS
deprecation&lt;/a&gt;,
this is also the last release containing a copy of RLS. Starting from Rust
1.65.0, RLS will be replaced by a small LSP server showing the deprecation
warning.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.64 release, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Windows builds of the Rust compiler now use profile-guided optimization,
providing performance improvements of 10-20% for compiling Rust code on
Windows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you define a struct containing fields that are never used, rustc will warn
about the unused fields. Now, in Rust 1.64, you can enable the
&lt;code&gt;unused_tuple_struct_fields&lt;/code&gt; lint to get the same warnings about unused
fields in a tuple struct. In future versions, we plan to make this lint
warn by default.  Fields of type unit (&lt;code&gt;()&lt;/code&gt;) do not produce this warning,
to make it easier to migrate existing code without having to change tuple
indices.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out everything that changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-164-2022-09-22&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-164&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1640&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1640&quot;&gt;&lt;/a&gt;Contributors to 1.64.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.64.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.64.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Const Eval (Un)Safety Rules</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html" type="text/html" title="Const Eval (Un)Safety Rules" />
        <published>2022-09-15T00:00:00+00:00</published>
        <updated>2022-09-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html">&lt;p&gt;In a recent Rust issue (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt;), a developer noted that the upcoming
1.64-beta version of Rust had started signalling errors on their crate,
&lt;a href&#x3D;&quot;https://github.com/unicode-org/icu4x&quot;&gt;&lt;code&gt;icu4x&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;icu4x&lt;/code&gt; crate uses unsafe code during const evaluation.
&lt;em&gt;Const evaluation&lt;/em&gt;, or just &amp;quot;const-eval&amp;quot;,
runs at compile-time but produces values that may end up embedded in the
final object code that executes at runtime.&lt;/p&gt;
&lt;p&gt;Rust&#x27;s const-eval system supports both safe and unsafe Rust, but the rules for
what unsafe code is allowed to do during const-eval are even more strict than
what is allowed for unsafe code at runtime. This post is going to go into detail
about one of those rules.&lt;/p&gt;
&lt;p&gt;(Note: If your &lt;code&gt;const&lt;/code&gt; code does not use any &lt;code&gt;unsafe&lt;/code&gt; blocks or call any &lt;code&gt;const fn&lt;/code&gt;
with an &lt;code&gt;unsafe&lt;/code&gt; block, then you do not need to worry about this!)&lt;/p&gt;
&lt;!--

(This is distinct from procedural macros, which are Rust code that runs at
compile-time to manipulate *program syntax*; syntactic values are not usually
embedded into the final object code.)

--&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-new-diagnostic-to-watch-for&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-new-diagnostic-to-watch-for&quot;&gt;&lt;/a&gt;A new diagnostic to watch for&lt;/h2&gt;
&lt;p&gt;The problem, reduced over the course of the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923#issuecomment-1200284482&quot;&gt;comment thread of #99923&lt;/a&gt;, is that certain static initialization expressions (see below) are
defined as having undefined behavior (UB) &lt;em&gt;at compile time&lt;/em&gt; (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;beta&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;67a917fc4f2a4bf2eb72aebf8dad0fe9&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: () &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    let _copy &#x3D; illegal_ptr2int;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Many thanks to &lt;code&gt;@eddyb&lt;/code&gt; for the minimal reproduction!)&lt;/p&gt;
&lt;p&gt;The code above was accepted by Rust versions 1.63 and earlier, but in the Rust
1.64-beta, it now causes a compile time error with the following message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0080]: could not evaluate static initializer
 --&amp;gt; demo.rs:3:17
  |
3 |     let _copy &#x3D; illegal_ptr2int;
  |                 ^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes
  |
  &#x3D; help: this code performed an operation that depends on the underlying bytes representing a pointer
  &#x3D; help: the absolute address of a pointer is not known at compile-time, so such operations are not supported
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the message says, this operation is not supported: the &lt;code&gt;transmute&lt;/code&gt;
above is trying to reinterpret the memory address &lt;code&gt;&amp;amp;()&lt;/code&gt; as an integer of type
&lt;code&gt;usize&lt;/code&gt;. The compiler cannot predict what memory address the &lt;code&gt;()&lt;/code&gt; would be
associated with at execution time, so it refuses to allow that reinterpretation.&lt;/p&gt;
&lt;p&gt;When you write safe Rust, then the compiler is responsible for preventing
undefined behavior. When you write any unsafe code (be it const or non-const),
you are responsible for preventing UB, and during const-eval, the rules about
what unsafe code has defined behavior are even more strict than the analogous
rules governing Rust&#x27;s runtime semantics. (In other words, &lt;em&gt;more&lt;/em&gt; code is
classified as &amp;quot;UB&amp;quot; than you may have otherwise realized.)&lt;/p&gt;
&lt;p&gt;If you hit undefined behavior during const-eval, the Rust compiler will protect
itself from &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/3016-const-ub.md#guide-level-explanation&quot;&gt;adverse effects&lt;/a&gt; such as the undefined
behavior leaking into the type system, but there are few guarantees
other than that. For example, compile-time UB could lead to runtime UB.
Furthermore, if you have UB at const-eval time, there is no guarantee that your
code will be accepted from one compiler version to another.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-new-here&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-new-here&quot;&gt;&lt;/a&gt;What is new here&lt;/h2&gt;
&lt;p&gt;You might be thinking: &amp;quot;it &lt;em&gt;used to be&lt;/em&gt; accepted; therefore, there must be some
value for the memory address that the previous version of the compiler was using
here.&amp;quot;&lt;/p&gt;
&lt;p&gt;But such reasoning would be based on an imprecise view of what the Rust compiler
was doing here.&lt;/p&gt;
&lt;p&gt;The const-eval machinery of the Rust compiler  (also known as &amp;quot;the &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/const-eval.html&quot;&gt;CTFE&lt;/a&gt; engine&amp;quot;)
is built upon a &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/mir/index.html&quot;&gt;MIR&lt;/a&gt; interpreter which uses an &lt;em&gt;abstract model&lt;/em&gt; of a hypothetical machine as the
foundation for evaluating such expressions. This abstract model doesn&#x27;t have to
represent memory addresses as mere integers; in fact, to support
fine-grained checking for UB, it uses a much richer datatype for
the values that are held in the abstract memory store.&lt;/p&gt;
&lt;p&gt;(The aforementioned MIR interpreter is also the basis for &lt;a href&#x3D;&quot;https://github.com/rust-lang/miri#readme&quot;&gt;Miri&lt;/a&gt;, a research
tool that interprets &lt;em&gt;non-const&lt;/em&gt; Rust code, with a focus on
explicit detection of undefined behavior. The Miri developers are the primary
contributors to the CTFE engine in the Rust compiler.)&lt;/p&gt;
&lt;p&gt;The details of the CTFE engine&#x27;s value representation do not matter too much for our
discussion here. We merely note that earlier versions of the compiler silently
accepted expressions that &lt;em&gt;seemed to&lt;/em&gt; transmute memory addresses into integers,
copied them around, and then transmuted them back into addresses; but that was
not what was acutally happening under the hood. Instead, what was happening was
that the values were passed around blindly (after all, the whole point of
transmute is that it does no transformation on its input value, so it is a no-op
in terms of its operational semantics).&lt;/p&gt;
&lt;p&gt;The fact that it was passing a memory address into a context where you would
expect there to always be an integer value would only be caught, if at all, at
some later point.&lt;/p&gt;
&lt;p&gt;For example, the const-eval machinery rejects code that attempts to embed the
transmuted pointer into a value that could be used by runtime code, like so (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;48456e8bd028c6aa5c80a1962d7e4fb8&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: usize &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    illegal_ptr2int
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Likewise, it rejects code that attempts to &lt;em&gt;perform arithmetic&lt;/em&gt; on that
non-integer value, like so (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;74a35dd6ff93c86bd38c1a0006f2fc41&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: () &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    let _incremented &#x3D; illegal_ptr2int + 1;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both of the latter two variants are rejected in stable Rust, and have been for
as long as Rust has accepted pointer-to-integer conversions in static
initializers (see e.g. Rust 1.52).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#more-similar-than-different&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;more-similar-than-different&quot;&gt;&lt;/a&gt;More similar than different&lt;/h2&gt;
&lt;p&gt;In fact, &lt;em&gt;all&lt;/em&gt; of the examples provided above are exhibiting &lt;em&gt;undefined
behavior&lt;/em&gt; according to the semantics of Rust&#x27;s const-eval system.&lt;/p&gt;
&lt;p&gt;The first example with &lt;code&gt;_copy&lt;/code&gt; was accepted in Rust versions 1.46 through 1.63
because of CTFE implementation artifacts. The CTFE engine puts considerable effort into
detecting UB, but does not catch all instances of it. Furthermore, by default,
such detection can be delayed to a point far after where the actual
problematic expression is found.&lt;/p&gt;
&lt;p&gt;But with nightly Rust, we can opt into extra checks for UB that the engine provides,
by passing the unstable flag &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt;. If we do that, then for
&lt;em&gt;all&lt;/em&gt; of the above examples we get the same result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0080]: could not evaluate static initializer
 --&amp;gt; demo.rs:2:34
  |
2 |     let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes
  |
  &#x3D; help: this code performed an operation that depends on the underlying bytes representing a pointer
  &#x3D; help: the absolute address of a pointer is not known at compile-time, so such operations are not supported
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The earlier examples had diagnostic output that put the blame in a misleading
place. With the more precise checking &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt; enabled, the
compiler highlights the expression where we can first witness UB: the original
transmute itself! (Which was stated at the outset of this post; here we are just
pointing out that these tools can pinpoint the injection point more precisely.)&lt;/p&gt;
&lt;p&gt;Why not have these extra const-ub checks on by default? Well, the checks
introduce performance overhead upon Rust compilation time, and we do not know if
that overhead can be made acceptable. (However, &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bsteering.20meeting.5D.202022-09-02.20const-eval.20and.20future-compa.2E.2E.2E/near/296853344&quot;&gt;recent debate&lt;/a&gt;
among Miri developers indicates that the inherent cost here might not be as bad
as they had originally thought. Perhaps a future version of the compiler will
have these extra checks on by default.)&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#change-is-hard&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;change-is-hard&quot;&gt;&lt;/a&gt;Change is hard&lt;/h2&gt;
&lt;p&gt;You might well be wondering at this point: &amp;quot;Wait, when &lt;em&gt;is&lt;/em&gt; it okay to transmute
a pointer to a &lt;code&gt;usize&lt;/code&gt; during const evaluation?&amp;quot; And the answer is simple:
&amp;quot;Never.&amp;quot;&lt;/p&gt;
&lt;p&gt;Transmuting a pointer to a usize during const-eval has always been undefined behavior,
ever since const-eval added support for
&lt;code&gt;transmute&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt;. You can read more about this in the
&lt;code&gt;const_fn_transmute&lt;/code&gt; / &lt;code&gt;const_fn_union&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/85769#issuecomment-854363720&quot;&gt;stabilization report&lt;/a&gt;,
specifically the subsection entitled &amp;quot;Pointer-integer-transmutes&amp;quot;.
(It is also mentioned in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/mem/fn.transmute.html&quot;&gt;documentation&lt;/a&gt; for &lt;code&gt;transmute&lt;/code&gt;&lt;!--,
though with less discussion than what you see in the stabilization report --&gt;.)&lt;/p&gt;
&lt;p&gt;Thus, we can see that the classification of the above examples as UB during const evaluation
is not a new thing at all. The only change here was that the CTFE engine had some internal
changes that made it start detecting the UB rather than silently ignoring it.&lt;/p&gt;
&lt;p&gt;This means the Rust compiler has a shifting notion of what UB it will
explicitly catch. We anticipated this: RFC 3016, &amp;quot;const UB&amp;quot;, explicitly
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/3016-const-ub.md#guide-level-explanation&quot;&gt;says&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] there is no guarantee that UB is reliably detected during CTFE. This can
change from compiler version to compiler version: CTFE code that causes UB
could build fine with one compiler and fail to build with another. (This is in
accordance with the general policy that unsound code is not subject to
stability guarantees.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Having said that: So much of Rust&#x27;s success has been built around the trust that
we have earned with our community. Yes, the project has always reserved the
right to make breaking changes when resolving soundness bugs; but we have also
strived to mitigate such breakage &lt;em&gt;whenever feasible&lt;/em&gt;, via things like
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/rustc/lints/index.html#future-incompatible-lints&quot;&gt;future-incompatible lints&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Today, with our current const-eval architecture, it is not
feasible to ensure that changes such as the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/97684&quot;&gt;one that injected&lt;/a&gt; issue
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt; go through a future-incompat warning cycle.
The compiler team plans to keep our eye on issues in this space. If we see
evidence that these kinds of changes do cause breakage to a non-trivial number
of crates, then we will investigate further how we might smooth the transition
path between compiler releases. However, we need to balance any such goal
against the fact that Miri has very a limited set of developers: the researchers
determining how to define the semantics of unsafe languages like Rust. We do not
want to slow their work down!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-you-can-do-for-safetys-sake&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-you-can-do-for-safetys-sake&quot;&gt;&lt;/a&gt;What you can do for safety&#x27;s sake&lt;/h2&gt;
&lt;p&gt;If you observe the &lt;code&gt;could not evaluate static initializer&lt;/code&gt; message on your crate
atop Rust 1.64, and it was compiling with previous versions of Rust, we want you
to let us know: &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;file an issue&lt;/a&gt;!&lt;/p&gt;
&lt;!--

(Of course we always want to hear about such cases where a crate regresses
between Rust releases; this is just a case that was particularly subtle for us
to tease apart within the project community itself.)

--&gt;
&lt;p&gt;We have &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/100327#issuecomment-1214457275&quot;&gt;performed&lt;/a&gt; a &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/tests/crater.html&quot;&gt;crater run&lt;/a&gt; for the 1.64-beta and that did not find any other
instances of this particular problem.
If you can test compiling your crate atop the 1.64-beta before the stable
release goes out on September 22nd, all the better! One easy way to try the beta
is to use &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/overrides.html#toolchain-override-shorthand&quot;&gt;rustup&#x27;s override shortand&lt;/a&gt; for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&quot;&gt;$ rustup update beta
$ cargo +beta build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As Rust&#x27;s const-eval evolves, we may see another case like this arise again. If
you want to defend against future instances of const-eval UB, we recommend that
you set up a continuous integration service to invoke the nightly &lt;code&gt;rustc&lt;/code&gt; with
the unstable &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt; flag on your code.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#want-to-help&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;want-to-help&quot;&gt;&lt;/a&gt;Want to help?&lt;/h2&gt;
&lt;p&gt;As you might imagine, a lot of us are pretty interested in questions such as
&amp;quot;what should be undefined behavior?&amp;quot;&lt;/p&gt;
&lt;p&gt;See for example Ralf Jung&#x27;s excellent blog series on why pointers are
complicated (parts &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html&quot;&gt;I&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2020/12/14/provenance.html&quot;&gt;II&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html&quot;&gt;III&lt;/a&gt;), which contain some of
the details elided above about the representation of pointer values, and spell out reasons why
you might want to be concerned about pointer-to-usize transmutes even &lt;em&gt;outside&lt;/em&gt;
of const-eval.&lt;/p&gt;
&lt;p&gt;If you are interested in trying to help us figure out answers to those kinds of
questions, please join us in the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines&quot;&gt;unsafe code guidelines zulip&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are interested in learning more about Miri, or contributing to it, you
can say Hello in the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/269128-miri&quot;&gt;miri zulip&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;To sum it all up: When you write safe Rust, then the compiler is responsible for
preventing undefined behavior. When you write any unsafe code, &lt;em&gt;you&lt;/em&gt; are
responsible for preventing undefined behavior. Rust&#x27;s const-eval system has a
stricter set of rules governing what unsafe code has defined behavior:
specifically, reinterpreting (aka &amp;quot;transmuting&amp;quot;) a pointer value as a &lt;code&gt;usize&lt;/code&gt; is
undefined behavior during const-eval. If you have undefined behavior at
const-eval time, there is no guarantee that your code will be accepted from one
compiler version to another.&lt;/p&gt;
&lt;p&gt;The compiler team is hoping that issue &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt; is an exceptional fluke and
that the 1.64 stable release will not encounter any other surprises related to
the aforementioned change to the const-eval machinery.&lt;/p&gt;
&lt;p&gt;But fluke or not, the issue provided excellent motivation to spend some time
exploring facets of Rust&#x27;s const-eval architecture and the interpreter
that underlies it.
We hope you enjoyed reading this as much as we did writing it.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisories for Cargo (CVE-2022-36113, CVE-2022-36114)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/09/14/cargo-cves.html" type="text/html" title="Security advisories for Cargo (CVE-2022-36113, CVE-2022-36114)" />
        <published>2022-09-14T00:00:00+00:00</published>
        <updated>2022-09-14T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/09/14/cargo-cves.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/09/14/cargo-cves.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/ldvsemwk_VY&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified that Cargo did not prevent
extracting some malformed packages downloaded from alternate registries. An
attacker able to upload packages to an alternate registry could fill the
filesystem or corrupt arbitary files when Cargo downloaded the package.&lt;/p&gt;
&lt;p&gt;These issues have been assigned CVE-2022-36113 and CVE-2022-36114. The severity
of these vulnerabilities is &amp;quot;low&amp;quot; for users of alternate registries. Users
relying on crates.io are not affected.&lt;/p&gt;
&lt;p&gt;Note that &lt;strong&gt;by design&lt;/strong&gt; Cargo allows code execution at build time, due to build
scripts and procedural macros. The vulnerabilities in this advisory allow
performing a subset of the possible damage in a harder to track down way. Your
dependencies must still be trusted if you want to be protected from attacks, as
it&#x27;s possible to perform the same attacks with build scripts and procedural
macros.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#arbitrary-file-corruption-cve-2022-36113&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;arbitrary-file-corruption-cve-2022-36113&quot;&gt;&lt;/a&gt;Arbitrary file corruption (CVE-2022-36113)&lt;/h2&gt;
&lt;p&gt;After a package is downloaded, Cargo extracts its source code in the &lt;code&gt;~/.cargo&lt;/code&gt;
folder on disk, making it available to the Rust projects it builds. To record
when an extraction is successfull, Cargo writes &amp;quot;ok&amp;quot; to the &lt;code&gt;.cargo-ok&lt;/code&gt; file at
the root of the extracted source code once it extracted all the files.&lt;/p&gt;
&lt;p&gt;It was discovered that Cargo allowed packages to contain a &lt;code&gt;.cargo-ok&lt;/code&gt;
&lt;em&gt;symbolic link&lt;/em&gt;, which Cargo would extract. Then, when Cargo attempted to write
&amp;quot;ok&amp;quot; into &lt;code&gt;.cargo-ok&lt;/code&gt;, it would actually replace the first two bytes of the
file the symlink pointed to with &lt;code&gt;ok&lt;/code&gt;. This would allow an attacker to corrupt
one file on the machine using Cargo to extract the package.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#disk-space-exhaustion-cve-2022-36114&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;disk-space-exhaustion-cve-2022-36114&quot;&gt;&lt;/a&gt;Disk space exhaustion (CVE-2022-36114)&lt;/h2&gt;
&lt;p&gt;It was discovered that Cargo did not limit the amount of data extracted from
compressed archives. An attacker could upload to an alternate registry a
specially crafted package that extracts way more data than its size (also known
as a &amp;quot;zip bomb&amp;quot;), exhausting the disk space on the machine using Cargo to
download the package.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected versions&lt;/h2&gt;
&lt;p&gt;Both vulnerabilities are present in all versions of Cargo. Rust 1.64, to be
released on September 22nd, will include fixes for both of them.&lt;/p&gt;
&lt;p&gt;Since these vulnerabilities are just a more limited way to accomplish what a
malicious build scripts or procedural macros can do, we decided not to publish
Rust point releases backporting the security fix. Patch files for Rust 1.63.0
are available &lt;a href&#x3D;&quot;https://github.com/rust-lang/wg-security-response/tree/master/patches&quot;&gt;in the wg-security-response repository&lt;/a&gt; for people building
their own toolchains.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We recommend users of alternate registries to excercise care in which package
they download, by only including trusted dependencies in their projects. Please
note that even with these vulnerabilities fixed, by design Cargo allows
arbitrary code execution at build time thanks to build scripts and procedural
macros: a malicious dependency will be able to cause damage regardless of these
vulnerabilities.&lt;/p&gt;
&lt;p&gt;crates.io implemented server-side checks to reject these kinds of packages
years ago, and there are no packages on crates.io exploiting these
vulnerabilities. crates.io users still need to excercise care in choosing their
dependencies though, as the same concerns about build scripts and procedural
macros apply here.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;We want to thank Ori Hollander from JFrog Security Research for responsibly
disclosing this to us according to the &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;Rust security policy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We also want to thank Josh Triplett for developing the fixes, Weihang Lo for
developing the tests, and Pietro Albini for writing this advisory. The
disclosure was coordinated by Pietro Albini and Josh Stone.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.63.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html" type="text/html" title="Announcing Rust 1.63.0" />
        <published>2022-08-11T00:00:00+00:00</published>
        <updated>2022-08-11T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.63.0. Rust is a programming language
empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.63.0 with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1630-2022-08-11&quot;&gt;detailed release notes for 1.63.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider updating locally to use
the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly channel (&lt;code&gt;rustup default nightly&lt;/code&gt;).
Please &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1630-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1630-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.63.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#scoped-threads&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;scoped-threads&quot;&gt;&lt;/a&gt;Scoped threads&lt;/h3&gt;
&lt;p&gt;Rust code could launch new threads with &lt;code&gt;std::thread::spawn&lt;/code&gt; since 1.0, but this
function bounds its closure with &lt;code&gt;&#x27;static&lt;/code&gt;. Roughly, this means that threads
currently must have ownership of any arguments passed into their closure; you
can&#x27;t pass borrowed data into a thread. In cases where the threads are expected
to exit by the end of the function (by being &lt;code&gt;join()&lt;/code&gt;&#x27;d), this isn&#x27;t strictly
necessary and can require workarounds like placing the data in an &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now, with 1.63.0, the standard library is adding &lt;em&gt;scoped&lt;/em&gt; threads, which allow
spawning a thread borrowing from the local stack frame. The
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/fn.scope.html&quot;&gt;&lt;code&gt;std::thread::scope&lt;/code&gt;&lt;/a&gt; API provides the necessary guarantee that any spawned threads
will have exited prior to itself returning, which allows for safely borrowing
data. Here&#x27;s an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let mut a &#x3D; vec![1, 2, 3];
let mut x &#x3D; 0;

std::thread::scope(|s| {
    s.spawn(|| {
        println!(&amp;quot;hello from the first scoped thread&amp;quot;);
        // We can borrow &#x60;a&#x60; here.
        dbg!(&amp;amp;a);
    });
    s.spawn(|| {
        println!(&amp;quot;hello from the second scoped thread&amp;quot;);
        // We can even mutably borrow &#x60;x&#x60; here,
        // because no other threads are using it.
        x +&#x3D; a[0] + a[2];
    });
    println!(&amp;quot;hello from the main thread&amp;quot;);
});

// After the scope, we can modify and access our variables again:
a.push(4);
assert_eq!(x, a.len());
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#rust-ownership-for-raw-file-descriptorshandles-io-safety&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-ownership-for-raw-file-descriptorshandles-io-safety&quot;&gt;&lt;/a&gt;Rust ownership for raw file descriptors/handles (I/O Safety)&lt;/h3&gt;
&lt;p&gt;Previously, Rust code working with platform APIs taking raw file descriptors (on
unix-style platforms) or handles (on Windows) would typically work directly with
a platform-specific representation of the descriptor (for example, a &lt;code&gt;c_int&lt;/code&gt;, or the alias &lt;code&gt;RawFd&lt;/code&gt;).
For Rust bindings to such native APIs, the type system then failed to encode
whether the API would take ownership of the file descriptor (e.g., &lt;code&gt;close&lt;/code&gt;) or
merely borrow it (e.g., &lt;code&gt;dup&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Now, Rust provides wrapper types such as &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/struct.BorrowedFd.html&quot;&gt;&lt;code&gt;BorrowedFd&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/struct.OwnedFd.html&quot;&gt;&lt;code&gt;OwnedFd&lt;/code&gt;&lt;/a&gt;, which are marked as
&lt;code&gt;#[repr(transparent)]&lt;/code&gt;, meaning that &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; bindings can directly take
these types to encode the ownership semantics. See the stabilized APIs section
for the full list of wrapper types stabilized in 1.63, currently, they are
available on cfg(unix) platforms, Windows, and WASI.&lt;/p&gt;
&lt;p&gt;We recommend that new APIs use these types instead of the previous type aliases
(like &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html&quot;&gt;&lt;code&gt;RawFd&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-mutex-rwlock-condvar-initialization&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-mutex-rwlock-condvar-initialization&quot;&gt;&lt;/a&gt;&lt;code&gt;const&lt;/code&gt; Mutex, RwLock, Condvar initialization&lt;/h3&gt;
&lt;p&gt;The &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.new&quot;&gt;&lt;code&gt;Condvar::new&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#method.new&quot;&gt;&lt;code&gt;Mutex::new&lt;/code&gt;&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html#method.new&quot;&gt;&lt;code&gt;RwLock::new&lt;/code&gt;&lt;/a&gt; functions are now
callable in &lt;code&gt;const&lt;/code&gt; contexts, which allows avoiding the use of crates like
&lt;code&gt;lazy_static&lt;/code&gt; for creating global statics with &lt;code&gt;Mutex&lt;/code&gt;, &lt;code&gt;RwLock&lt;/code&gt;, or &lt;code&gt;Condvar&lt;/code&gt;
values. This builds on the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html#thinner-faster-mutexes-on-linux&quot;&gt;work in 1.62&lt;/a&gt; to enable thinner and faster mutexes
on Linux.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#turbofish-for-generics-in-functions-with-impl-trait&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;turbofish-for-generics-in-functions-with-impl-trait&quot;&gt;&lt;/a&gt;Turbofish for generics in functions with &lt;code&gt;impl Trait&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;For a function signature like &lt;code&gt;fn foo&amp;lt;T&amp;gt;(value: T, f: impl Copy)&lt;/code&gt;, it was an
error to specify the concrete type of &lt;code&gt;T&lt;/code&gt; via turbofish: &lt;code&gt;foo::&amp;lt;u32&amp;gt;(3, 3)&lt;/code&gt;
would fail with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;error[E0632]: cannot provide explicit generic arguments when &#x60;impl Trait&#x60; is used in argument position
 --&amp;gt; src/lib.rs:4:11
  |
4 |     foo::&amp;lt;u32&amp;gt;(3, 3);
  |           ^^^ explicit generic argument not allowed
  |
  &#x3D; note: see issue #83701 &amp;lt;https://github.com/rust-lang/rust/issues/83701&amp;gt; for more information
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In 1.63, this restriction is relaxed, and the explicit type of the generic can be specified.
However, the &lt;code&gt;impl Trait&lt;/code&gt; parameter, despite desugaring to a generic, remains
opaque and cannot be specified via turbofish.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#non-lexical-lifetimes-migration-complete&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;non-lexical-lifetimes-migration-complete&quot;&gt;&lt;/a&gt;Non-lexical lifetimes migration complete&lt;/h3&gt;
&lt;p&gt;As detailed in &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/08/05/nll-by-default.html&quot;&gt;this blog post&lt;/a&gt;, we&#x27;ve fully removed the previous lexical borrow checker
from rustc across all editions, fully enabling the non-lexical, new, version of the borrow
checker. Since the borrow checker doesn&#x27;t affect the output of rustc, this won&#x27;t change
the behavior of any programs, but it completes a long-running migration (started in the
initial stabilization of NLL for the 2018 edition) to deliver the full benefits of the new
borrow checker across all editions of Rust. For most users, this change will bring
slightly better diagnostics for some borrow checking errors, but will not otherwise impact
which code they can write.&lt;/p&gt;
&lt;p&gt;You can read more about non-lexical lifetimes in &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes&quot;&gt;this section of the 2018 edition announcement&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/array/fn.from_fn.html&quot;&gt;&lt;code&gt;array::from_fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.into_pin&quot;&gt;&lt;code&gt;Box::into_pin&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.try_reserve&quot;&gt;&lt;code&gt;BinaryHeap::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/collections/binary_heap/struct.BinaryHeap.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;BinaryHeap::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.try_reserve&quot;&gt;&lt;code&gt;OsString::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;OsString::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.try_reserve&quot;&gt;&lt;code&gt;PathBuf::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;PathBuf::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.try_exists&quot;&gt;&lt;code&gt;Path::try_exists&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cell/struct.Ref.html#method.filter_map&quot;&gt;&lt;code&gt;Ref::filter_map&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cell/struct.RefMut.html#method.filter_map&quot;&gt;&lt;code&gt;RefMut::filter_map&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.len&quot;&gt;&lt;code&gt;NonNull::&amp;lt;[T]&amp;gt;::len&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/borrow/trait.ToOwned.html#method.clone_into&quot;&gt;&lt;code&gt;ToOwned::clone_into&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.to_ipv4_mapped&quot;&gt;&lt;code&gt;Ipv6Addr::to_ipv4_mapped&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsFd.html&quot;&gt;&lt;code&gt;unix::io::AsFd&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/struct.BorrowedFd.html&quot;&gt;&lt;code&gt;unix::io::BorrowedFd&amp;lt;&#x27;fd&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/struct.OwnedFd.html&quot;&gt;&lt;code&gt;unix::io::OwnedFd&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/trait.AsHandle.html&quot;&gt;&lt;code&gt;windows::io::AsHandle&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.BorrowedHandle.html&quot;&gt;&lt;code&gt;windows::io::BorrowedHandle&amp;lt;&#x27;handle&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.OwnedHandle.html&quot;&gt;&lt;code&gt;windows::io::OwnedHandle&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.HandleOrInvalid.html&quot;&gt;&lt;code&gt;windows::io::HandleOrInvalid&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.HandleOrNull.html&quot;&gt;&lt;code&gt;windows::io::HandleOrNull&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.InvalidHandleError.html&quot;&gt;&lt;code&gt;windows::io::InvalidHandleError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.NullHandleError.html&quot;&gt;&lt;code&gt;windows::io::NullHandleError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/trait.AsSocket.html&quot;&gt;&lt;code&gt;windows::io::AsSocket&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.BorrowedSocket.html&quot;&gt;&lt;code&gt;windows::io::BorrowedSocket&amp;lt;&#x27;handle&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.OwnedSocket.html&quot;&gt;&lt;code&gt;windows::io::OwnedSocket&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/fn.scope.html&quot;&gt;&lt;code&gt;thread::scope&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/fn.scope.html&quot;&gt;&lt;code&gt;thread::Scope&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html&quot;&gt;&lt;code&gt;thread::ScopedJoinHandle&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These APIs are now usable in const contexts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/array/fn.from_ref.html&quot;&gt;&lt;code&gt;array::from_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/slice/fn.from_ref.html&quot;&gt;&lt;code&gt;slice::from_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/intrinsics/fn.copy.html&quot;&gt;&lt;code&gt;intrinsics::copy&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/intrinsics/fn.copy_nonoverlapping.html&quot;&gt;&lt;code&gt;intrinsics::copy_nonoverlapping&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::copy_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to_nonoverlapping&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::copy_to_nonoverlapping&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::copy_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to_nonoverlapping-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::copy_to_nonoverlapping&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_from&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::copy_from&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_from_nonoverlapping&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::copy_from_nonoverlapping&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/str/fn.from_utf8.html&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/str/struct.Utf8Error.html#method.error_len&quot;&gt;&lt;code&gt;Utf8Error::error_len&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/str/struct.Utf8Error.html#method.valid_up_to&quot;&gt;&lt;code&gt;Utf8Error::valid_up_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.new&quot;&gt;&lt;code&gt;Condvar::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#method.new&quot;&gt;&lt;code&gt;Mutex::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html#method.new&quot;&gt;&lt;code&gt;RwLock::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.63.0 release. Check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1630-2022-08-11&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-163-2022-08-11&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-163&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1630&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1630&quot;&gt;&lt;/a&gt;Contributors to 1.63.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.63.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.63.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
</feed>

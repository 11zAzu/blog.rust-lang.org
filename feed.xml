<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2022-04-15T16:51:30+00:00</updated>

    
    <entry>
        <title>Announcing Rust 1.60.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html" type="text/html" title="Announcing Rust 1.60.0" />
        <published>2022-04-07T00:00:00+00:00</published>
        <updated>2022-04-07T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/04/07/Rust-1.60.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.60.0. Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.60.0 with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1600-2022-04-07&quot;&gt;detailed release notes for 1.60.0&lt;/a&gt; on GitHub.
If you&#x27;d like to help us out by testing future releases, you might consider updating locally to use
the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1600-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1600-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.60.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#source-based-code-coverage&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;source-based-code-coverage&quot;&gt;&lt;/a&gt;Source-based Code Coverage&lt;/h3&gt;
&lt;p&gt;Support for LLVM-based coverage instrumentation has been stabilized in rustc. You can try this out on your code by rebuilding your code with &lt;code&gt;-Cinstrument-coverage&lt;/code&gt;, for example like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&#x3D;&quot;&gt;RUSTFLAGS&#x3D;&amp;quot;-C instrument-coverage&amp;quot; cargo build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After that, you can run the resulting binary, which will produce a
&lt;code&gt;default.profraw&lt;/code&gt; file in the current directory. (The path and filename can be
overriden by an environment variable; see
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/rustc/instrument-coverage.html#running-the-instrumented-binary-to-generate-raw-coverage-profiling-data&quot;&gt;documentation&lt;/a&gt;
for details).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;llvm-tools-preview&lt;/code&gt; component includes &lt;code&gt;llvm-profdata&lt;/code&gt; for processing and
merging raw profile output (coverage region execution counts); and &lt;code&gt;llvm-cov&lt;/code&gt;
for report generation. &lt;code&gt;llvm-cov&lt;/code&gt; combines the processed output, from
&lt;code&gt;llvm-profdata&lt;/code&gt;, and the binary itself, because the binary embeds a mapping from
counters to actual source code regions.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&#x3D;&quot;&gt;rustup component add llvm-tools-preview
$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/bin/llvm-profdata merge -sparse default.profraw -o default.profdata
$(rustc --print sysroot)/lib/rustlib/x86_64-unknown-linux-gnu/bin/llvm-cov show -Xdemangler&#x3D;rustfilt target/debug/coverage-testing \
    -instr-profile&#x3D;default.profdata \
    -show-line-counts-or-regions \
    -show-instantiations
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above commands on a simple helloworld binary produce this annotated report, showing that each line of the input was covered.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    1|      1|fn main() {
    2|      1|    println!(&amp;quot;Hello, world!&amp;quot;);
    3|      1|}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For more details, please read the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/rustc/instrument-coverage.html&quot;&gt;documentation&lt;/a&gt; in the
rustc book. The baseline functionality is stable and will exist in some form
in all future Rust releases, but the specific output format and LLVM tooling which
produces it are subject to change. For this reason, it is important to make
sure that you use the same version for both the &lt;code&gt;llvm-tools-preview&lt;/code&gt; and the
rustc binary used to compile your code.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo---timings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo---timings&quot;&gt;&lt;/a&gt;&lt;code&gt;cargo --timings&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Cargo has stabilized support for collecting information on build with the &lt;code&gt;--timings&lt;/code&gt; flag.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&quot;&gt;$ cargo build --timings
   Compiling hello-world v0.1.0 (hello-world)
      Timing report saved to target/cargo-timings/cargo-timing-20220318T174818Z.html
    Finished dev [unoptimized + debuginfo] target(s) in 0.98s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The report is also copied to &lt;code&gt;target/cargo-timings/cargo-timing.html&lt;/code&gt;. A report on the release build of Cargo has been put up &lt;a href&#x3D;&quot;/images/2022-04-07-timing.html&quot;&gt;here&lt;/a&gt;. These reports can be useful for improving build performance.
More information about the timing reports may be found in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/cargo/reference/timings.html&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#new-syntax-for-cargo-features&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;new-syntax-for-cargo-features&quot;&gt;&lt;/a&gt;New syntax for Cargo features&lt;/h3&gt;
&lt;p&gt;This release introduces two new changes to improve support for &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/features.html&quot;&gt;Cargo features&lt;/a&gt; and how they interact with &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies&quot;&gt;optional dependencies&lt;/a&gt;: Namespaced dependencies and weak dependency features.&lt;/p&gt;
&lt;p&gt;Cargo has long supported features along with optional dependencies, as illustrated by the snippet below.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[dependencies]
jpeg-decoder &#x3D; { version &#x3D; &amp;quot;0.1.20&amp;quot;, default-features &#x3D; false, optional &#x3D; true }

[features]
# Enables parallel processing support by enabling the &amp;quot;rayon&amp;quot; feature of jpeg-decoder.
parallel &#x3D; [&amp;quot;jpeg-decoder/rayon&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are two things to note in this example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The optional dependency &lt;code&gt;jpeg-decoder&lt;/code&gt; implicitly defines a feature of the same name. Enabling the &lt;code&gt;jpeg-decoder&lt;/code&gt; feature will enable the &lt;code&gt;jpeg-decoder&lt;/code&gt; dependency.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;&amp;quot;jpeg-decoder/rayon&amp;quot;&lt;/code&gt; syntax enables the &lt;code&gt;jpeg-decoder&lt;/code&gt; dependency &lt;em&gt;and&lt;/em&gt; enables the &lt;code&gt;jpeg-decoder&lt;/code&gt; dependency&#x27;s &lt;code&gt;rayon&lt;/code&gt; feature.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Namespaced features tackles the first issue. You can now use the &lt;code&gt;dep:&lt;/code&gt; prefix in the &lt;code&gt;[features]&lt;/code&gt; table to explicitly refer to an optional dependency without implicitly exposing it as a feature. This gives you more control on how to define the feature corresponding to the optional dependency including hiding optional dependencies behind more descriptive feature names.&lt;/p&gt;
&lt;p&gt;Weak dependency features tackle the second issue where the &lt;code&gt;&amp;quot;optional-dependency/feature-name&amp;quot;&lt;/code&gt; syntax would always enable &lt;code&gt;optional-dependency&lt;/code&gt;. However, often you want to enable the feature on the optional dependency &lt;em&gt;only&lt;/em&gt; if some other feature has enabled the optional dependency. Starting in 1.60, you can add a ? as in &lt;code&gt;&amp;quot;package-name?/feature-name&amp;quot;&lt;/code&gt; which will only enable the given feature if something else has enabled the optional dependency.&lt;/p&gt;
&lt;p&gt;For example, let&#x27;s say we have added some serialization support to our library, and it requires enabling a corresponding feature in some optional dependencies. That can be done like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[dependencies]
serde &#x3D; { version &#x3D; &amp;quot;1.0.133&amp;quot;, optional &#x3D; true }
rgb &#x3D; { version &#x3D; &amp;quot;0.8.25&amp;quot;, optional &#x3D; true }

[features]
serde &#x3D; [&amp;quot;dep:serde&amp;quot;, &amp;quot;rgb?/serde&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, enabling the serde feature will enable the serde dependency. It will also enable the serde feature for the rgb dependency, but only if something else has enabled the rgb dependency.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#incremental-compilation-status&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;incremental-compilation-status&quot;&gt;&lt;/a&gt;Incremental compilation status&lt;/h3&gt;
&lt;p&gt;Incremental compilation is re-enabled for the 1.60 release. The Rust team continues to work on fixing bugs in incremental, but no problems causing widespread breakage are known at this time, so we have chosen to reenable incremental compilation. Additionally, the compiler team is continuing to work on long-term strategy to avoid future problems of this kind. That process is in relatively early days, so we don&#x27;t have anything to share yet on that front.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#instant-monotonicity-guarantees&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;instant-monotonicity-guarantees&quot;&gt;&lt;/a&gt;&lt;code&gt;Instant&lt;/code&gt; monotonicity guarantees&lt;/h3&gt;
&lt;p&gt;On all platforms &lt;code&gt;Instant&lt;/code&gt; will try to use an OS API that guarantees monotonic
behavior if available (which is the case on all tier 1 platforms). In practice
such guarantees are -- under rare circumstances -- broken by hardware,
virtualization, or operating system bugs. To work around these bugs and platforms
not offering monotonic clocks, &lt;code&gt;Instant::duration_since&lt;/code&gt;, &lt;code&gt;Instant::elapsed&lt;/code&gt; and
&lt;code&gt;Instant::sub&lt;/code&gt; now saturate to zero. In older Rust versions this led to a panic
instead. &lt;code&gt;Instant::checked_duration_since&lt;/code&gt; can be used to detect and handle
situations where monotonicity is violated, or &lt;code&gt;Instant&lt;/code&gt;s are subtracted in the
wrong order.&lt;/p&gt;
&lt;p&gt;This workaround obscures programming errors where earlier and later instants are
accidentally swapped. For this reason future Rust versions may reintroduce
panics in at least those cases, if possible and efficient.&lt;/p&gt;
&lt;p&gt;Prior to 1.60, the monotonicity guarantees were provided through mutexes or
atomics in std, which can introduce large performance overheads to
&lt;code&gt;Instant::now()&lt;/code&gt;. Additionally, the panicking behavior meant that Rust software
could panic in a subset of environments, which was largely undesirable, as the
authors of that software may not be able to fix or upgrade the operating system,
hardware, or virtualization system they are running on. Further, introducing
unexpected panics into these environments made Rust software less reliable and
portable, which is of higher concern than exposing typically uninteresting
platform bugs in monotonic clock handling to end users.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.new_cyclic&quot;&gt;&lt;code&gt;Arc::new_cyclic&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/rc/struct.Rc.html#method.new_cyclic&quot;&gt;&lt;code&gt;Rc::new_cyclic&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/slice/struct.EscapeAscii.html&quot;&gt;&lt;code&gt;slice::EscapeAscii&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.escape_ascii&quot;&gt;&lt;code&gt;&amp;lt;[u8]&amp;gt;::escape_ascii&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.escape_ascii&quot;&gt;&lt;code&gt;u8::escape_ascii&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#method.spare_capacity_mut&quot;&gt;&lt;code&gt;Vec::spare_capacity_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_drop&quot;&gt;&lt;code&gt;MaybeUninit::assume_init_drop&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_read&quot;&gt;&lt;code&gt;MaybeUninit::assume_init_read&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.abs_diff&quot;&gt;&lt;code&gt;i8::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i16.html#method.abs_diff&quot;&gt;&lt;code&gt;i16::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i32.html#method.abs_diff&quot;&gt;&lt;code&gt;i32::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i64.html#method.abs_diff&quot;&gt;&lt;code&gt;i64::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i128.html#method.abs_diff&quot;&gt;&lt;code&gt;i128::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.isize.html#method.abs_diff&quot;&gt;&lt;code&gt;isize::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.abs_diff&quot;&gt;&lt;code&gt;u8::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u16.html#method.abs_diff&quot;&gt;&lt;code&gt;u16::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u32.html#method.abs_diff&quot;&gt;&lt;code&gt;u32::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u64.html#method.abs_diff&quot;&gt;&lt;code&gt;u64::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u128.html#method.abs_diff&quot;&gt;&lt;code&gt;u128::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.usize.html#method.abs_diff&quot;&gt;&lt;code&gt;usize::abs_diff&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/enum.ErrorKind.html#impl-Display&quot;&gt;&lt;code&gt;Display for io::ErrorKind&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/process/struct.ExitCode.html#impl-From%3Cu8%3E&quot;&gt;&lt;code&gt;From&amp;lt;u8&amp;gt; for ExitCode&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.never.html#impl-Not&quot;&gt;&lt;code&gt;Not for !&lt;/code&gt; (the &amp;quot;never&amp;quot; type)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.Wrapping.html#trait-implementations&quot;&gt;_Op_&lt;code&gt;Assign&amp;lt;$t&amp;gt; for Wrapping&amp;lt;$t&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/arch/macro.is_aarch64_feature_detected.html&quot;&gt;&lt;code&gt;arch::is_aarch64_feature_detected!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.60.0 release. Check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1600-2022-04-07&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-160-2022-04-07&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-160&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1600&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1600&quot;&gt;&lt;/a&gt;Contributors to 1.60.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.60.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.60.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for the regex crate (CVE-2022-24713)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/03/08/cve-2022-24713.html" type="text/html" title="Security advisory for the regex crate (CVE-2022-24713)" />
        <published>2022-03-08T00:00:00+00:00</published>
        <updated>2022-03-08T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/03/08/cve-2022-24713.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/03/08/cve-2022-24713.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/NcNNL1Jq7Yw&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified that the &lt;code&gt;regex&lt;/code&gt; crate did not
properly limit the complexity of the regular expressions (regex) it parses. An
attacker could use this security issue to perform a denial of service, by
sending a specially crafted regex to a service accepting untrusted regexes. No
known vulnerability is present when parsing untrusted input with trusted
regexes.&lt;/p&gt;
&lt;p&gt;This issue has been assigned CVE-2022-24713. The severity of this vulnerability
is &amp;quot;high&amp;quot; when the &lt;code&gt;regex&lt;/code&gt; crate is used to parse untrusted regexes. Other uses
of the &lt;code&gt;regex&lt;/code&gt; crate are not affected by this vulnerability.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;regex&lt;/code&gt; crate features built-in mitigations to prevent denial of service
attacks caused by untrusted regexes, or untrusted input matched by trusted
regexes. Those (tunable) mitigations already provide sane defaults to prevent
attacks. This guarantee is documented and it&#x27;s considered part of the crate&#x27;s
API.&lt;/p&gt;
&lt;p&gt;Unfortunately a bug was discovered in the mitigations designed to prevent
untrusted regexes to take an arbitrary amount of time during parsing, and it&#x27;s
possible to craft regexes that bypass such mitigations. This makes it possible
to perform denial of service attacks by sending specially crafted regexes to
services accepting user-controlled, untrusted regexes.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected versions&lt;/h2&gt;
&lt;p&gt;All versions of the &lt;code&gt;regex&lt;/code&gt; crate before or equal to 1.5.4 are affected by this
issue. The fix is included starting from  &lt;code&gt;regex&lt;/code&gt; 1.5.5.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We recommend everyone accepting user-controlled regexes to upgrade immediately
to the latest version of the &lt;code&gt;regex&lt;/code&gt; crate.&lt;/p&gt;
&lt;p&gt;Unfortunately there is no fixed set of problematic regexes, as there are
practically infinite regexes that could be crafted to exploit this
vulnerability. Because of this, we do not recommend denying known problematic
regexes.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;We want to thank Addison Crump for responsibly disclosing this to us according
to the &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;Rust security policy&lt;/a&gt;, and for helping review the fix.&lt;/p&gt;
&lt;p&gt;We also want to thank Andrew Gallant for developing the fix, and Pietro Albini
for coordinating the disclosure and writing this advisory.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.59.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html" type="text/html" title="Announcing Rust 1.59.0" />
        <published>2022-02-24T00:00:00+00:00</published>
        <updated>2022-02-24T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/02/24/Rust-1.59.0.html">&lt;p&gt;The Rust team has published a new version of Rust, 1.59.0. Rust is a programming
language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Today&#x27;s release falls on the day in which the world&#x27;s attention is captured by
the sudden invasion of Ukraine by Putin&#x27;s forces. Before going into the details
of the new Rust release, we&#x27;d like to state that we stand in solidarity with the
people of Ukraine and express our support for all people affected by this
conflict.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.59.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1590-2022-02-24&quot;&gt;detailed release notes for 1.59.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1590-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1590-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.59.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#inline-assembly&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;inline-assembly&quot;&gt;&lt;/a&gt;Inline assembly&lt;/h3&gt;
&lt;p&gt;The Rust language now supports inline assembly. This enables many applications
that need very low-level control over their execution, or access to
specialized machine instructions.&lt;/p&gt;
&lt;p&gt;When compiling for x86-64 targets, for instance, you can now write:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 &#x3D; 4;
unsafe {
    asm!(
        &amp;quot;mov {tmp}, {x}&amp;quot;,
        &amp;quot;shl {tmp}, 1&amp;quot;,
        &amp;quot;shl {x}, 2&amp;quot;,
        &amp;quot;add {x}, {tmp}&amp;quot;,
        x &#x3D; inout(reg) x,
        tmp &#x3D; out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The format string syntax used to name registers in the &lt;code&gt;asm!&lt;/code&gt; and &lt;code&gt;global_asm!&lt;/code&gt;
macros is the same used in Rust &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fmt/&quot;&gt;format strings&lt;/a&gt;, so it should feel quite familiar
to Rust programmers.&lt;/p&gt;
&lt;p&gt;The assembly language and instructions available with inline assembly vary
according to the target architecture. Today, the stable Rust compiler supports
inline assembly on the following architectures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x86 and x86-64&lt;/li&gt;
&lt;li&gt;ARM&lt;/li&gt;
&lt;li&gt;AArch64&lt;/li&gt;
&lt;li&gt;RISC-V&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see more examples of inline assembly in &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/rust-by-example/unsafe/asm.html&quot;&gt;Rust By Example&lt;/a&gt;,
and find more detailed documentation in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/reference/inline-assembly.html&quot;&gt;reference&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#destructuring-assignments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;destructuring-assignments&quot;&gt;&lt;/a&gt;Destructuring assignments&lt;/h3&gt;
&lt;p&gt;You can now use tuple, slice, and struct patterns as the left-hand side of an
assignment.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let (a, b, c, d, e);

(a, b) &#x3D; (1, 2);
[c, .., d, _] &#x3D; [1, 2, 3, 4, 5];
Struct { e, .. } &#x3D; Struct { e: 5, f: 3 };

assert_eq!([1, 2, 1, 4, 5], [a, b, c, d, e]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This makes assignment more consistent with &lt;code&gt;let&lt;/code&gt; bindings, which have long
supported the same thing. Note that destructuring assignments with operators
such as &lt;code&gt;+&#x3D;&lt;/code&gt; are not allowed.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-generics-defaults-and-interleaving&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-generics-defaults-and-interleaving&quot;&gt;&lt;/a&gt;Const generics defaults and interleaving&lt;/h3&gt;
&lt;p&gt;Generic types can now specify default values for their const generics. For
example, you can now write the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct ArrayStorage&amp;lt;T, const N: usize &#x3D; 2&amp;gt; {
    arr: [T; N],
}

impl&amp;lt;T&amp;gt; ArrayStorage&amp;lt;T&amp;gt; {
    fn new(a: T, b: T) -&amp;gt; ArrayStorage&amp;lt;T&amp;gt; {
        ArrayStorage {
            arr: [a, b],
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Previously, type parameters were required to come before all const parameters.
That restriction has been relaxed and you can now interleave them.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn cartesian_product&amp;lt;
    T, const N: usize,
    U, const M: usize,
    V, F
&amp;gt;(a: [T; N], b: [U; M], f: F) -&amp;gt; [[V; N]; M]
where
    F: FnMut(&amp;amp;T, &amp;amp;U) -&amp;gt; V
{
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#future-incompatibility-warnings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;future-incompatibility-warnings&quot;&gt;&lt;/a&gt;Future incompatibility warnings&lt;/h3&gt;
&lt;p&gt;Sometimes bugs in the Rust compiler cause it to accept code that should not
have been accepted. An example of this was &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/46043&quot;&gt;borrows of packed struct
fields&lt;/a&gt; being allowed in safe code.&lt;/p&gt;
&lt;p&gt;While this happens very rarely, it can be quite disruptive when a crate used by
your project has code that will no longer be allowed. In fact, you might not
notice until your project inexplicably stops building!&lt;/p&gt;
&lt;p&gt;Cargo now shows you warnings when a dependency will be rejected by a future
version of Rust. After running &lt;code&gt;cargo build&lt;/code&gt; or &lt;code&gt;cargo check&lt;/code&gt;, you might see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warning: the following packages contain code that will be rejected by a future version of Rust: old_dep v0.1.0
note: to see what the problems were, use the option &#x60;--future-incompat-report&#x60;, or run &#x60;cargo report future-incompatibilities --id 1&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can run the &lt;code&gt;cargo report&lt;/code&gt; command mentioned in the warning to see a full
report of the code that will be rejected. This gives you time to upgrade your
dependency before it breaks your build.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#creating-stripped-binaries&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;creating-stripped-binaries&quot;&gt;&lt;/a&gt;Creating stripped binaries&lt;/h3&gt;
&lt;p&gt;It&#x27;s often useful to strip unnecessary information like debuginfo from binaries
you distribute, making them smaller.&lt;/p&gt;
&lt;p&gt;While it has always been possible to do this manually after the binary is
created, cargo and rustc now support stripping when the binary is linked. To
enable this, add the following to your &lt;code&gt;Cargo.toml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[profile.release]
strip &#x3D; &amp;quot;debuginfo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This causes debuginfo to be stripped from release binaries. You can also supply
&lt;code&gt;&amp;quot;symbols&amp;quot;&lt;/code&gt; or just &lt;code&gt;true&lt;/code&gt; to strip all symbol information where supported.&lt;/p&gt;
&lt;p&gt;The standard library typically ships with debug symbols and line-level
debuginfo, so Rust binaries built without debug symbols enabled still include
the debug information from the standard library by default. Using the &lt;code&gt;strip&lt;/code&gt;
option allows you to remove this extra information, producing smaller Rust
binaries.&lt;/p&gt;
&lt;p&gt;See &lt;a href&#x3D;&quot;https://doc.rust-lang.org/beta/cargo/reference/profiles.html#strip&quot;&gt;Cargo&#x27;s documentation&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#incremental-compilation-off-by-default&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;incremental-compilation-off-by-default&quot;&gt;&lt;/a&gt;Incremental compilation off by default&lt;/h3&gt;
&lt;p&gt;The 1.59.0 release disables incremental by default (unless explicitly asked for
by via an environment variable: &lt;code&gt;RUSTC_FORCE_INCREMENTAL&#x3D;1&lt;/code&gt;). This mitigates
the effects of a known bug, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/94124&quot;&gt;#94124&lt;/a&gt;, which can cause deserialization errors (and panics) during compilation
with incremental compilation turned on.&lt;/p&gt;
&lt;p&gt;The specific fix for &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/94124&quot;&gt;#94124&lt;/a&gt; has landed and is currently in the 1.60 beta,
which will ship in six weeks. We are not presently aware of other issues that
would encourage a decision to disable incremental in 1.60 stable, and if none
arise it is likely that 1.60 stable will re-enable incremental compilation
again. Incremental compilation remains on by default in the beta and nightly
channels.&lt;/p&gt;
&lt;p&gt;As always, we encourage users to test on the nightly and beta channels and
report issues you find: particularly for incremental bugs, this is the best way
to ensure the Rust team can judge whether there is breakage and the number of
users it affects.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/fn.available_parallelism.html&quot;&gt;&lt;code&gt;std::thread::available_parallelism&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.copied&quot;&gt;&lt;code&gt;Result::copied&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.cloned&quot;&gt;&lt;code&gt;Result::cloned&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/macro.asm.html&quot;&gt;&lt;code&gt;arch::asm!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/arch/macro.global_asm.html&quot;&gt;&lt;code&gt;arch::global_asm!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html#method.is_break&quot;&gt;&lt;code&gt;ops::ControlFlow::is_break&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html#method.is_continue&quot;&gt;&lt;code&gt;ops::ControlFlow::is_continue&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.char.html#impl-TryFrom%3Cchar%3E&quot;&gt;&lt;code&gt;TryFrom&amp;lt;char&amp;gt; for u8&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/char/struct.TryFromCharError.html&quot;&gt;&lt;code&gt;char::TryFromCharError&lt;/code&gt;&lt;/a&gt;
implementing &lt;code&gt;Clone&lt;/code&gt;, &lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Display&lt;/code&gt;, &lt;code&gt;PartialEq&lt;/code&gt;, &lt;code&gt;Copy&lt;/code&gt;, &lt;code&gt;Eq&lt;/code&gt;, &lt;code&gt;Error&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/iter/fn.zip.html&quot;&gt;&lt;code&gt;iter::zip&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU8.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU8::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU16.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU16::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU32.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU32::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU64.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU64::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/num/struct.NonZeroU128.html#method.is_power_of_two&quot;&gt;&lt;code&gt;NonZeroU128::is_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/char/struct.ToLowercase.html#impl-DoubleEndedIterator&quot;&gt;&lt;code&gt;DoubleEndedIterator for ToLowercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/char/struct.ToUppercase.html#impl-DoubleEndedIterator&quot;&gt;&lt;code&gt;DoubleEndedIterator for ToUppercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html#impl-TryFrom%3C%26%27_%20mut%20%5BT%5D%3E&quot;&gt;&lt;code&gt;TryFrom&amp;lt;&amp;amp;mut [T]&amp;gt; for [T; N]&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Once.html#impl-UnwindSafe&quot;&gt;&lt;code&gt;UnwindSafe for Once&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Once.html#impl-RefUnwindSafe&quot;&gt;&lt;code&gt;RefUnwindSafe for Once&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/stdarch/pull/1266&quot;&gt;armv8 neon intrinsics for aarch64&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.as_ptr&quot;&gt;&lt;code&gt;mem::MaybeUninit::as_ptr&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init&quot;&gt;&lt;code&gt;mem::MaybeUninit::assume_init&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/mem/union.MaybeUninit.html#method.assume_init_ref&quot;&gt;&lt;code&gt;mem::MaybeUninit::assume_init_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.CStr.html#method.from_bytes_with_nul_unchecked&quot;&gt;&lt;code&gt;ffi::CStr::from_bytes_with_nul_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.59.0 release. Check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1590-2022-02-24&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-159-2022-02-24&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-159&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1590&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1590&quot;&gt;&lt;/a&gt;Contributors to 1.59.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.59.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.59.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Team</name>
        </author>
    </entry>
    
    <entry>
        <title>rust-analyzer joins the Rust organization!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/02/21/rust-analyzer-joins-rust-org.html" type="text/html" title="rust-analyzer joins the Rust organization!" />
        <published>2022-02-21T00:00:00+00:00</published>
        <updated>2022-02-21T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/02/21/rust-analyzer-joins-rust-org.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/02/21/rust-analyzer-joins-rust-org.html">&lt;p&gt;We have an exciting announcement to make!
The &lt;a href&#x3D;&quot;https://rust-analyzer.github.io&quot;&gt;rust-analyzer&lt;/a&gt; project, a new implementation of the Language Server Protocol (LSP) for Rust, is now officially a part of the wider Rust organization! 🎉&lt;/p&gt;
&lt;p&gt;We want to start by thanking everyone who has gotten us this far, from contributors, to sponsors, to all the users of rust-analyzer in the Rust community. We could not have done this without you.&lt;/p&gt;
&lt;p&gt;The immediate impact of this organizational change is limited -- nothing changes for rust-analyzer users or contributors.
However, this change unblocks technical work to make rust-analyzer the officially recommended language server for Rust in the near future.&lt;/p&gt;
&lt;p&gt;If you were hesitant to try rust-analyzer before, today is a good opportunity to do so.
Not only is it a very capable language server for Rust, but according to &lt;a href&#x3D;&quot;https://marketplace.visualstudio.com/search?target&#x3D;VSCode&amp;category&#x3D;Programming%20Languages&amp;sortBy&#x3D;Rating&quot;&gt;VS Code statistics&lt;/a&gt;, it is one of the best rated LSP implementations &lt;em&gt;across&lt;/em&gt; programming languages.
We highly recommend giving rust-analyzer a spin today, even if it will take some more time for us to complete the due process and switch from the existing officially recommended LSP implementation (RLS) properly.&lt;/p&gt;
&lt;p&gt;rust-analyzer enjoys excellent support in many editors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For VS Code, install the &lt;a href&#x3D;&quot;https://marketplace.visualstudio.com/items?itemName&#x3D;matklad.rust-analyzer&quot;&gt;rust-analyzer&lt;/a&gt; extension from the marketplace.&lt;/li&gt;
&lt;li&gt;For Neovim, follow the setup instructions &lt;a href&#x3D;&quot;https://sharksforarms.dev/posts/neovim-rust/&quot;&gt;from this post&lt;/a&gt;.
For Vim, see &lt;a href&#x3D;&quot;https://github.com/fannheyward/coc-rust-analyzer&quot;&gt;coc-rust-analyzer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For Emacs, follow the setup instructions &lt;a href&#x3D;&quot;https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/&quot;&gt;from this post&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For other editors, check &lt;a href&#x3D;&quot;https://rust-analyzer.github.io/manual.html&quot;&gt;the manual&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, if you are using IntelliJ-Platform based IDEs like CLion, IDEA or PyCharm, you don&#x27;t need rust-analyzer.
You should use the awesome &lt;a href&#x3D;&quot;https://intellij-rust.github.io&quot;&gt;IntelliJ Rust&lt;/a&gt; plugin by JetBrains.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#history-and-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;history-and-future&quot;&gt;&lt;/a&gt;History and Future&lt;/h2&gt;
&lt;p&gt;The rust-analyzer project was started at the very end of 2017 (&lt;a href&#x3D;&quot;https://github.com/rust-analyzer/rust-analyzer/commit/a63222cd240d9b5405826783603f3b391c90885d&quot;&gt;first commit&lt;/a&gt;).
At that time, the existing LSP implementation, RLS, had been providing IDE support for Rust for several years.
While it handled well the most important features, it was clearly far from the experience offered by state-of-the-art IDEs for some other languages.&lt;/p&gt;
&lt;p&gt;Originally, the plan was to just experiment with error-resilient parsing for Rust; but when you have a good parser, it is so tempting &lt;a href&#x3D;&quot;https://github.com/rust-analyzer/rust-analyzer/commit/d7c5a6f3081c2e7266620779d3c32067f947b959&quot;&gt;to add a simple LSP server&lt;/a&gt; on top of it.
Long story short, it took surprisingly little effort to get to a prototype which was already useful as an IDE, which happened in Autumn 2018.
At that critical point, the company &lt;a href&#x3D;&quot;https://ferrous-systems.com&quot;&gt;Ferrous Systems&lt;/a&gt; (which was newborn itself) stepped in to fund further development of the prototype.&lt;/p&gt;
&lt;p&gt;During 2019, the then nascent rust-analyzer community worked hard to build out the foundation of an IDE.
By 2020, we realized that what we had built was no longer a prototype, but an already tremendously useful tool for day-to-day Rust programming.
This culminated in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2912&quot;&gt;RFC2912&lt;/a&gt;: &amp;quot;Transition to rust-analyzer as our official LSP (Language Server Protocol) implementation&amp;quot;.
The RFC was accepted with overwhelming support from the community: it is still the most upvoted Rust RFC ever.
However, there was a wrinkle in the plan -- rust-analyzer was not an official Rust project!
That&#x27;s what we are fixing today!&lt;/p&gt;
&lt;p&gt;Next, we will proceed with the plan outlined in the RFC: advertising rust-analyzer as the very likely future of Rust IDE support, gathering feedback, and, conditioned on the positive outcome of that, sunsetting RLS, the currently recommended language server. So, once again -- do try out rust-analyzer and leave feedback on the &lt;a href&#x3D;&quot;https://github.com/rust-analyzer/rust-analyzer/issues/4224&quot;&gt;tracking issues&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After the transition, we will double down on the technical side of things.&lt;/p&gt;
&lt;p&gt;As exciting as rust-analyzer is today, it only scratches the surface of what&#x27;s possible when you bring the compiler&#x27;s intricate understanding of the code right into the text editor.
The end-game we are aiming for is creating an API to analyze and transform Rust code with full access to semantics.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#funding&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;funding&quot;&gt;&lt;/a&gt;Funding&lt;/h2&gt;
&lt;p&gt;One of the hardest nuts to crack for the present transition was the question of funding.
Today, Rust is organized as a set of somewhat independent projects (rustc, cargo, rustup, rustfmt), and there&#x27;s deliberately no way to fund a specific project directly. The new &lt;a href&#x3D;&quot;https://foundation.rust-lang.org&quot;&gt;Rust Foundation&lt;/a&gt; is the official place to sponsor Rust in general, with the Foundation Board overseeing funds allocation. Yet, it has always been encouraged for individuals to seek individual funding. While the Rust project may advertise funding opportunities for individual contributors, it does not officially &lt;em&gt;endorse&lt;/em&gt; these efforts nor does it facilitate the funding of entire teams.&lt;/p&gt;
&lt;p&gt;rust-analyzer has received a significant share of funds from its OpenCollective and later GitHub Sponsors, managed by Ferrous Systems. This OpenCollective funded efforts by both individual contributors and Ferrous Systems employees. Details of this can be found in their &lt;a href&#x3D;&quot;https://rust-analyzer.github.io/blog/2021/08/03/financial-report-3.html&quot;&gt;transparency reports&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Luckily, the OpenCollective has always been managed in a way that would make it possible to transfer it to a different account holder.
With this transition, the OpenCollective will be renamed from &amp;quot;rust-analyzer OpenCollective&amp;quot; to &amp;quot;Ferrous Systems OpenCollective (rust-analyzer)&amp;quot;. This allows current sponsors to continue to sponsor and also make it clear that their chosen project will continue to be funded.&lt;/p&gt;
&lt;p&gt;In a sense, the OpenCollective is handed to Ferrous Systems. All Sponsor credits will move to &lt;a href&#x3D;&quot;https://ferrous-systems.com/open-source/#sponsors&quot;&gt;https://ferrous-systems.com/open-source/#sponsors&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We would like to thank Ferrous Systems for their openness and flexibility in the process, for their thoughtfulness in making sure the funding situation around rust-analyzer was clear, and for taking on the effort of fundraising.&lt;/p&gt;
&lt;p&gt;Eventually the &lt;a href&#x3D;&quot;https://github.com/sponsors/rust-analyzer&quot;&gt;rust-analyzer GitHub Sponsors&lt;/a&gt; will also move away from the rust-analyzer GitHub organisation.&lt;/p&gt;
&lt;p&gt;And of course, another great way for companies to support rust-analyzer development is to hire &lt;a href&#x3D;&quot;https://github.com/rust-analyzer/rust-analyzer/graphs/contributors&quot;&gt;the people working on rust-analyzer&lt;/a&gt; to continue to do so.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thanks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;We&#x27;d like to once again thank everyone who help get rust-analyzer to this point. From experiment to being well on its way to the officially recommended LSP implementation for Rust, we couldn&#x27;t have done it without the help of our contributors, sponsors, and users.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So that&#x27;s where we are at right now!
Thanks to the awesome contributors to rustc, clippy, cargo, LSP, IntelliJ Rust, RLS and rust-analyzer, Rust today already enjoys great IDE support, even if it still has a bit of experimental flair to it.&lt;/p&gt;
</content>

        <author>
            <name>The rust-analyzer Team on behalf of the entire Rust Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Survey 2021 Results</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html" type="text/html" title="Rust Survey 2021 Results" />
        <published>2022-02-15T00:00:00+00:00</published>
        <updated>2022-02-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/02/15/Rust-Survey-2021.html">&lt;p&gt;Greetings Rustaceans!&lt;/p&gt;
&lt;p&gt;Another year has passed, and with it comes another annual Rust survey analysis! The survey was conducted in December 2021.&lt;/p&gt;
&lt;p&gt;We’d like to thank everyone who participated in this year’s survey, with a special shout-out to those who helped translate the survey from English into other languages.&lt;/p&gt;
&lt;p&gt;Without further ado, let’s dive into the analysis!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-global-community&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-global-community&quot;&gt;&lt;/a&gt;A Global Community&lt;/h2&gt;
&lt;p&gt;The Rust community continues to grow, with this survey having the largest number of complete survey responses (9354 respondents), exceeding last year&#x27;s total by roughly 1500 responses.&lt;/p&gt;
&lt;p&gt;90% of respondents said that they use Rust for any purpose, while 5% stated they had used Rust at some point in the past but no longer do, and 4% stated they have yet to use Rust at all.&lt;/p&gt;
&lt;p&gt;The survey was offered in 10 languages with 78% filling out the survey in English followed by Simplified Chinese (6%), German (4%), and French (3%). Despite English being the language most respondents completed the survey in, respondents hailed from all around the world. The United States was the country with the largest representation at 24% followed by Germany (12%), China (7%), and the U.K. (6%). In total 113 different countries and territories were represented through this survey!&lt;/p&gt;
&lt;p&gt;English, however, is not the language of choice for all Rustaceans with nearly 7% preferring not to use English as a language for technical communication. An additional 23% of respondents prefer another language in addition to English. The most commonly preferred languages (besides English) roughly follow where Rustaceans live with Simplified Chinese, German, and French being the top 3. However, Japanese, Simplified Chinese, and Russian speakers were the most likely to prefer not to use English at all for technical conversation.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#using-rust&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;using-rust&quot;&gt;&lt;/a&gt;Using Rust&lt;/h2&gt;
&lt;p&gt;The percentage of people using Rust continues to rise. Of those using Rust, 81% are currently using it on at least a weekly basis compared to 72% from last year&#x27;s survey.&lt;/p&gt;
&lt;p&gt;75% of all Rust users say they can write production ready code, though 27% say that it is at times a struggle.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2022-02-RustSurvey/expertise.png&quot; alt&#x3D;&quot;Rust expertise&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Overall, Rustaceans seem to be having a great time writing Rust with only 1% saying it isn&#x27;t fun to use. Only a quarter of a percent find Rust doesn&#x27;t have any real benefit over other programming languages.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#rust-at-work&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-at-work&quot;&gt;&lt;/a&gt;Rust at Work&lt;/h2&gt;
&lt;p&gt;Rust can now safely be classified as a language used by people in professional settings. Of those respondents using Rust, 59% use it at least occasionally at work with 23% using Rust for the majority of their coding. This is a large increase over last year where only 42% of respondents used Rust at work.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2022-02-RustSurvey/rust-at-work.png&quot; alt&#x3D;&quot;Do you use Rust at work?&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Adopting Rust at work seems to follow a long but ultimately worthwhile path for a lot of Rustaceans. First, 83% of those who have adopted Rust at work found it to be &amp;quot;challenging&amp;quot;. How much this is related to Rust itself versus general challenges with adopting a new programming language, however, is unclear. During adoption only 13% of respondents found the language was slowing their team down and 82% found that Rust helped their teams achieve their goals.&lt;/p&gt;
&lt;p&gt;After adoption, the costs seem to be justified: only 1% of respondents did not find the challenge worth it while 79% said it definitely was. When asked if their teams were likely to use Rust again in the future, 90% agreed. Finally, of respondents using Rust at work, 89% of respondents said their teams found it fun and enjoyable to program.&lt;/p&gt;
&lt;p&gt;As for why respondents are using Rust at work, the top answer was that it allowed users &amp;quot;to build relatively correct and bug free software&amp;quot; with 96% of respondents agreeing with that statement. After correctness, performance (92%) was the next most popular choice. 89% of respondents agreed that they picked Rust at work because of Rust&#x27;s much-discussed security properties.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2022-02-RustSurvey/rust-adoption.png&quot; alt&#x3D;&quot;Adopting Rust&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Overall, Rust seems to be a language ready for the challenges of production, with only 3% of respondents saying that Rust was a &amp;quot;risky&amp;quot; choice for production use.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#challenges-ahead&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;challenges-ahead&quot;&gt;&lt;/a&gt;Challenges Ahead&lt;/h2&gt;
&lt;p&gt;Overall, the annual survey points towards a growing, healthy community of Rustaceans, but this is not to say we don&#x27;t have work ahead of us. Compile times, a historical focus of improvement for the Rust project, continue to not be where they need to be, with 61% of respondents saying work still needs to be done to improve them. Although, to the compiler team&#x27;s credit, 61% found that they improved over the past year.  Other areas indicated as in need of more improvement were disk space (45%), debugging (40%), and GUI development (56%).&lt;/p&gt;
&lt;p&gt;The IDE experience (led through continued adoption and improvement of various tools like rust-analyzer, IntelliJ Rust, etc.) gets the prize for showing the most improvement:  56% found it has improved over the last year.&lt;/p&gt;
&lt;p&gt;However, compiler error messages received the most praise, with 90% approval of their current state. 🎉&lt;/p&gt;
&lt;p&gt;When asked what their biggest worries for the future of Rust are, the top answer was a fear that there will not be enough usage in industry (38%). Given that Rust continues to show strides in adoption at places of work, the community seems to be on a good path to overcoming this concern.&lt;/p&gt;
&lt;p&gt;The next largest concern was that the language would become too complex (33%). This was combined with a relative small number of folks calling for additional features (especially for ones not already in the pipeline).&lt;/p&gt;
&lt;p&gt;Finally, the third largest concern was that those working on Rust would not find the proper support they need to continue to develop the language and community in a healthy way (30%). With the establishment of the Rust Foundation, support structures are coming into place that hopefully will address this point, but no doubt plenty of work is still ahead of us.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#an-exciting-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;an-exciting-future&quot;&gt;&lt;/a&gt;An Exciting Future&lt;/h2&gt;
&lt;p&gt;2021 was arguably one of the most significant years in Rust&#x27;s history - with the establishment of the Rust foundation, the 2021 edition, and a larger community than ever, Rust seems to be on a solid path as we head into the future.&lt;/p&gt;
&lt;p&gt;Plenty of work remains, but here&#x27;s hoping for a great 2022!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Survey Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Crates.io Index Snapshot Branches Moving</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/02/14/crates-io-snapshot-branches.html" type="text/html" title="Crates.io Index Snapshot Branches Moving" />
        <published>2022-02-14T00:00:00+00:00</published>
        <updated>2022-02-14T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/02/14/crates-io-snapshot-branches.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/02/14/crates-io-snapshot-branches.html">&lt;p&gt;Every so often, the &lt;a href&#x3D;&quot;https://github.com/rust-lang/crates.io-index&quot;&gt;crates.io index&lt;/a&gt;&#x27;s Git history
is &lt;a href&#x3D;&quot;https://internals.rust-lang.org/t/cargos-crate-index-upcoming-squash-into-one-commit/8440&quot;&gt;squashed into one
commit&lt;/a&gt;
to minimize the history Cargo needs to download. When the index is squashed, we save snapshots
to preserve the history of crate publishes.&lt;/p&gt;
&lt;p&gt;Currently, those snapshots are stored as branches in the main index Git repository. Those branches
are using server resources though, as the server still has to consider their contents whenever
Cargo asks for the master branch. We will be deleting the snapshot branches from this repository to
ensure that all objects referenced in the master branch will only be compressed against other
objects in the master branch, ensuring that the current clone behavior will be much more efficient
on the server side.&lt;/p&gt;
&lt;p&gt;Here&#x27;s how this might affect you:&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#if-you-use-cargo&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;if-you-use-cargo&quot;&gt;&lt;/a&gt;If you use Cargo&lt;/h2&gt;
&lt;p&gt;You should not see any effects from this change. Cargo does not use the snapshot branches, and
Cargo regularly handles index squashes. If you do see any issues, they are bugs, please &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo&quot;&gt;report
them on the Cargo repo&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#if-you-use-the-snapshot-branches&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;if-you-use-the-snapshot-branches&quot;&gt;&lt;/a&gt;If you use the snapshot branches&lt;/h2&gt;
&lt;p&gt;In one week, on 2022-02-21, we will be removing all snapshot branches from the crates.io-index
repo. All snapshot branches, both historical and in the future, are and will be in the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/crates.io-index-archive&quot;&gt;rust-lang/crates.io-index-archive repo&lt;/a&gt;
instead. Please update any scripts or tools referencing the snapshot branches by that time.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#in-the-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;in-the-future&quot;&gt;&lt;/a&gt;In the future&lt;/h2&gt;
&lt;p&gt;In the medium term, we&#x27;re working to prioritize the completion of &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/issues/9069&quot;&gt;in-progress
work&lt;/a&gt; to add a way to serve the index as static
files on HTTP, which will further ease the server load. The index repository will &lt;em&gt;not&lt;/em&gt; be going
away so that older versions of Cargo will continue to work. See &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/2789&quot;&gt;RFC
2789&lt;/a&gt; for more details.&lt;/p&gt;
</content>

        <author>
            <name>The Crates.io Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes in the Core Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/31/changes-in-the-core-team.html" type="text/html" title="Changes in the Core Team" />
        <published>2022-01-31T00:00:00+00:00</published>
        <updated>2022-01-31T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/31/changes-in-the-core-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/31/changes-in-the-core-team.html">&lt;p&gt;We want to say thanks to three people who recently have decided to step back from the Core Team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Steve Klabnik is leaving the Core Team and the Security Response Working Group.
Steve started with Rust more than 9 years ago.
He was the primary author of the Rust Programming Language book and part of the core team since 2014. He has been running the @rustlang Twitter account and as such formed a lot of the “voice” of the project.
Steve will now be able to focus on &lt;em&gt;using&lt;/em&gt; Rust instead of &lt;em&gt;making&lt;/em&gt; Rust.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Florian Gilcher is stepping back from all of his project positions.&lt;br /&gt;
He became a Core Team observer in 2019 and a full Core Team member in 2020.
He also served as a project director on the Rust foundation board.
Before all of that he was part of the Community Team since 2015.
As he&#x27;s focusing on his company and taking on other business obligations, he is making space for others in the project.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pietro Albini is leaving the Core Team to focus on other parts of the project, including the Infrastructure Team and the Security Response Working Group. He joined the Core Team in late 2019, shortly after becoming a co-lead of the Infrastructure Team, but the amount of work in the Core Team made it hard for him to spend enough time on his other roles in the project.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&#x27;re thankful for Steve&#x27;s, Florian&#x27;s and Pietro&#x27;s contributions to the Core Team &amp;amp; the Rust project in the past and we’re looking forward to any contributions they will still make in the future.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisory for the standard library (CVE-2022-21658)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html" type="text/html" title="Security advisory for the standard library (CVE-2022-21658)" />
        <published>2022-01-20T00:00:00+00:00</published>
        <updated>2022-01-20T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/R1fZFDhnJVQ&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified that the &lt;code&gt;std::fs::remove_dir_all&lt;/code&gt;
standard library function is vulnerable to a race condition enabling symlink
following (CWE-363). An attacker could use this security issue to trick a
privileged program into deleting files and directories the attacker couldn&#x27;t
otherwise access or delete.&lt;/p&gt;
&lt;p&gt;This issue has been assigned &lt;a href&#x3D;&quot;https://www.cve.org/CVERecord?id&#x3D;CVE-2022-21658&quot;&gt;CVE-2022-21658&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;Let&#x27;s suppose an attacker obtained unprivileged access to a system and needed
to delete a system directory called &lt;code&gt;sensitive/&lt;/code&gt;, but they didn&#x27;t have the
permissions to do so. If &lt;code&gt;std::fs::remove_dir_all&lt;/code&gt; followed symbolic links,
they could find a privileged program that removes a directory they have access
to (called &lt;code&gt;temp/&lt;/code&gt;), create a symlink from &lt;code&gt;temp/foo&lt;/code&gt; to &lt;code&gt;sensitive/&lt;/code&gt;, and wait
for the privileged program to delete &lt;code&gt;foo/&lt;/code&gt;. The privileged program would
follow the symlink from &lt;code&gt;temp/foo&lt;/code&gt; to &lt;code&gt;sensitive/&lt;/code&gt; while recursively deleting,
resulting in &lt;code&gt;sensitive/&lt;/code&gt; being deleted.&lt;/p&gt;
&lt;p&gt;To prevent such attacks, &lt;code&gt;std::fs::remove_dir_all&lt;/code&gt; already includes protection
to avoid recursively deleting symlinks, as described in &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/fs/fn.remove_dir_all.html&quot;&gt;its documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This function does &lt;strong&gt;not&lt;/strong&gt; follow symbolic links and it will simply remove
the symbolic link itself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unfortunately that check was implemented incorrectly in the standard library,
resulting in a TOCTOU (Time-of-check Time-of-use) race condition. Instead of
telling the system not to follow symlinks, the standard library first checked
whether the thing it was about to delete was a symlink, and otherwise it would
proceed to recursively delete the directory.&lt;/p&gt;
&lt;p&gt;This exposed a race condition: an attacker could create a directory and replace
it with a symlink between the check and the actual deletion. While this attack
likely won&#x27;t work the first time it&#x27;s attempted, in our experimentation we were
able to reliably perform it within a couple of seconds.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected Versions&lt;/h2&gt;
&lt;p&gt;Rust 1.0.0 through Rust 1.58.0 is affected by this vulnerability. We&#x27;re going
to release Rust 1.58.1 later today, which will include mitigations for this
vulnerability. Patches to the Rust standard library are also available for
custom-built Rust toolchains &lt;a href&#x3D;&quot;https://github.com/rust-lang/wg-security-response/tree/master/patches/CVE-2022-21658&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note that the following targets don&#x27;t have usable APIs to properly mitigate the
attack, and are thus still vulnerable even with a patched toolchain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;macOS before version 10.10 (Yosemite)&lt;/li&gt;
&lt;li&gt;REDOX&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We recommend everyone to update to Rust 1.58.1 as soon as possible, especially
people developing programs expected to run in privileged contexts (including
system daemons and setuid binaries), as those have the highest risk of being
affected by this.&lt;/p&gt;
&lt;p&gt;Note that adding checks in your codebase before calling &lt;code&gt;remove_dir_all&lt;/code&gt; will
&lt;strong&gt;not&lt;/strong&gt; mitigate the vulnerability, as they would also be vulnerable to race
conditions like &lt;code&gt;remove_dir_all&lt;/code&gt; itself. The existing mitigation is working as
intended outside of race conditions.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgments&quot;&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;We want to thank Hans Kratz for independently discovering and disclosing this
issue to us according to the &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;Rust security policy&lt;/a&gt;, for developing the fix
for UNIX-like targets and for reviewing fixes for other platforms.&lt;/p&gt;
&lt;p&gt;We also want to thank Florian Weimer for reviewing the UNIX-like fix and for
reporting the same issue back in 2018, even though the Security Response WG
didn&#x27;t realize the severity of the issue at the time.&lt;/p&gt;
&lt;p&gt;Finally we want to thank Pietro Albini for coordinating the security response
and writing this advisory, Chris Denton for writing the Windows fix, Alex
Crichton for writing the WASI fix, and Mara Bos for reviewing the patches.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.58.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/20/Rust-1.58.1.html" type="text/html" title="Announcing Rust 1.58.1" />
        <published>2022-01-20T00:00:00+00:00</published>
        <updated>2022-01-20T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/20/Rust-1.58.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/20/Rust-1.58.1.html">&lt;p&gt;The Rust team has published a new point release of Rust, 1.58.1. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.58.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1581-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1581-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.58.1 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.58.1 fixes a race condition in the &lt;code&gt;std::fs::remove_dir_all&lt;/code&gt; standard
library function. This security vulnerability is tracked as &lt;a href&#x3D;&quot;https://www.cve.org/CVERecord?id&#x3D;CVE-2022-21658&quot;&gt;CVE-2022-21658&lt;/a&gt;,
and you can read more about it &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/01/20/cve-2022-21658.html&quot;&gt;on the advisory we published earlier
today&lt;/a&gt;. We recommend all users to update their toolchain immediately
and rebuild their programs with the updated compiler.&lt;/p&gt;
&lt;p&gt;Rust 1.58.1 also addresses several regressions in diagnostics and tooling introduced in Rust 1.58.0:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;non_send_fields_in_send_ty&lt;/code&gt; Clippy lint was discovered to have too many
false positives and has been moved to the experimental lints group (called
&amp;quot;nursery&amp;quot;).&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;useless_format&lt;/code&gt; Clippy lint has been updated to handle captured
identifiers in format strings, introduced in Rust 1.58.0.&lt;/li&gt;
&lt;li&gt;A regression in Rustfmt preventing generated files from being formatted when
passed through the standard input has been fixed.&lt;/li&gt;
&lt;li&gt;An incorrect error message displayed by &lt;code&gt;rustc&lt;/code&gt; in some cases has been fixed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find more detailed information on the specific regressions in the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1581-2022-01-20&quot;&gt;release notes&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1581&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1581&quot;&gt;&lt;/a&gt;Contributors to 1.58.1&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.58.1. We couldn&#x27;t have done it
without all of you. &lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.58.1/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.58.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html" type="text/html" title="Announcing Rust 1.58.0" />
        <published>2022-01-13T00:00:00+00:00</published>
        <updated>2022-01-13T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/01/13/Rust-1.58.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.58.0.
Rust is a programming language empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust 1.58.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1580-2022-01-13&quot;&gt;detailed release notes for 1.58.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1580-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1580-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.58.0 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.58 brings captured identifiers in format strings, a change to the
&lt;code&gt;Command&lt;/code&gt; search path on Windows, more &lt;code&gt;#[must_use]&lt;/code&gt; annotations in the
standard library, and some new library stabilizations.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#captured-identifiers-in-format-strings&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;captured-identifiers-in-format-strings&quot;&gt;&lt;/a&gt;Captured identifiers in format strings&lt;/h3&gt;
&lt;p&gt;Format strings can now capture arguments simply by writing &lt;code&gt;{ident}&lt;/code&gt; in the
string. Formats have long accepted positional arguments (optionally by index)
and named arguments, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;println!(&amp;quot;Hello, {}!&amp;quot;, get_person());                // implicit position
println!(&amp;quot;Hello, {0}!&amp;quot;, get_person());               // explicit index
println!(&amp;quot;Hello, {person}!&amp;quot;, person &#x3D; get_person()); // named
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now named arguments can also be captured from the surrounding scope, like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let person &#x3D; get_person();
// ...
println!(&amp;quot;Hello, {person}!&amp;quot;); // captures the local &#x60;person&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This may also be used in formatting parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let (width, precision) &#x3D; get_format();
for (name, score) in get_scores() {
  println!(&amp;quot;{name}: {score:width$.precision$}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Format strings can only capture plain identifiers, not arbitrary paths or
expressions. For more complicated arguments, either assign them to a local name
first, or use the older &lt;code&gt;name &#x3D; expression&lt;/code&gt; style of formatting arguments.&lt;/p&gt;
&lt;p&gt;This feature works in all macros accepting format strings. However, one corner
case is the &lt;code&gt;panic!&lt;/code&gt; macro in 2015 and 2018 editions, where &lt;code&gt;panic!(&amp;quot;{ident}&amp;quot;)&lt;/code&gt;
is still treated as an unformatted string -- the compiler will warn about this
not having the intended effect. Due to the 2021 edition&#x27;s update of panic
macros for &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/edition-guide/rust-2021/panic-macro-consistency.html&quot;&gt;improved consistency&lt;/a&gt;, this works as expected in 2021 &lt;code&gt;panic!&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#reduced-windows-command-search-path&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;reduced-windows-command-search-path&quot;&gt;&lt;/a&gt;Reduced Windows &lt;code&gt;Command&lt;/code&gt; search path&lt;/h3&gt;
&lt;p&gt;On Windows targets, &lt;code&gt;std::process::Command&lt;/code&gt; will no longer search the current
directory for executables. That effect was owed to historical behavior of the
win32 &lt;a href&#x3D;&quot;https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa&quot;&gt;&lt;code&gt;CreateProcess&lt;/code&gt;&lt;/a&gt; API, so Rust was effectively searching in this order:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;(Rust specific) The directories that are listed in the child&#x27;s &lt;code&gt;PATH&lt;/code&gt;
environment variable, if it was explicitly changed from the parent.&lt;/li&gt;
&lt;li&gt;The directory from which the application loaded.&lt;/li&gt;
&lt;li&gt;The current directory for the parent process.&lt;/li&gt;
&lt;li&gt;The 32-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The 16-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The Windows directory.&lt;/li&gt;
&lt;li&gt;The directories that are listed in the &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, using the current directory can lead to surprising results, or even
malicious behavior when dealing with untrusted directories. For example,
&lt;code&gt;ripgrep&lt;/code&gt; published &lt;a href&#x3D;&quot;https://www.cve.org/CVERecord?id&#x3D;CVE-2021-3013&quot;&gt;CVE-2021-3013&lt;/a&gt; when they learned that their child
processes could be intercepted in this way. Even Microsoft&#x27;s own PowerShell
&lt;a href&#x3D;&quot;https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_command_precedence?view&#x3D;powershell-7.2&quot;&gt;documents&lt;/a&gt; that they do not use the current directory for security.&lt;/p&gt;
&lt;p&gt;Rust now performs its own search without the current directory, and the legacy
16-bit directory is also not included, as there is no API to discover its
location. So the new &lt;code&gt;Command&lt;/code&gt; search order for Rust on Windows is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The directories that are listed in the child&#x27;s &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;li&gt;The directory from which the application loaded.&lt;/li&gt;
&lt;li&gt;The 32-bit Windows system directory.&lt;/li&gt;
&lt;li&gt;The Windows directory.&lt;/li&gt;
&lt;li&gt;The directories that are listed in the &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Non-Windows targets continue to use their platform-specific behavior, most
often only considering the child or parent &lt;code&gt;PATH&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#more-must_use-in-the-standard-library&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;more-must_use-in-the-standard-library&quot;&gt;&lt;/a&gt;More &lt;code&gt;#[must_use]&lt;/code&gt; in the standard library&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;#[must_use]&lt;/code&gt; attribute can be applied to types or functions when failing
to explicitly consider them or their output is almost certainly a bug. This has
long been used in the standard library for types like &lt;code&gt;Result&lt;/code&gt;, which should be
checked for error conditions. This also helps catch mistakes such as expecting
a function to mutate a value in-place, when it actually returns a new value.&lt;/p&gt;
&lt;p&gt;Library &lt;a href&#x3D;&quot;https://github.com/rust-lang/libs-team/issues/35&quot;&gt;proposal 35&lt;/a&gt; was approved in October 2021 to audit and expand the
application of &lt;code&gt;#[must_use]&lt;/code&gt; throughout the standard library, covering many
more functions where the primary effect is the return value. This is similar
to the idea of function purity, but looser than a true language feature. Some
of these additions were present in release 1.57.0, and now in 1.58.0 the effort
has completed.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fs/struct.Metadata.html#method.is_symlink&quot;&gt;&lt;code&gt;Metadata::is_symlink&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.is_symlink&quot;&gt;&lt;code&gt;Path::is_symlink&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.i8.html#method.saturating_div&quot;&gt;&lt;code&gt;{integer}::saturating_div&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.unwrap_unchecked&quot;&gt;&lt;code&gt;Option::unwrap_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.unwrap_unchecked&quot;&gt;&lt;code&gt;Result::unwrap_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/result/enum.Result.html#method.unwrap_err_unchecked&quot;&gt;&lt;code&gt;Result::unwrap_err_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fs/struct.File.html#method.options&quot;&gt;&lt;code&gt;File::options&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable functions are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.new&quot;&gt;&lt;code&gt;Duration::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_add&quot;&gt;&lt;code&gt;Duration::checked_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_add&quot;&gt;&lt;code&gt;Duration::saturating_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_sub&quot;&gt;&lt;code&gt;Duration::checked_sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_sub&quot;&gt;&lt;code&gt;Duration::saturating_sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_mul&quot;&gt;&lt;code&gt;Duration::checked_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_mul&quot;&gt;&lt;code&gt;Duration::saturating_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.checked_div&quot;&gt;&lt;code&gt;Duration::checked_div&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.58.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1580-2022-01-13&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-158-2022-01-13&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-158&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1580&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1580&quot;&gt;&lt;/a&gt;Contributors to 1.58.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.58.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.58.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
</feed>

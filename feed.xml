<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2021-03-25T14:56:28+00:00</updated>

    
    <entry>
        <title>Announcing Rust 1.51.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html" type="text/html" title="Announcing Rust 1.51.0" />
        <published>2021-03-25T00:00:00+00:00</published>
        <updated>2021-03-25T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.51.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.51.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1510-2021-03-25&quot;&gt;detailed release notes for 1.51.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1510-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1510-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.51.0 stable&lt;/h2&gt;
&lt;p&gt;This release represents one of the largest additions to the Rust language and Cargo in quite a while, stabilizing an MVP of const generics and a new feature resolver for Cargo. Let&#x27;s dive right into it!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-generics-mvp&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-generics-mvp&quot;&gt;&lt;/a&gt;Const Generics MVP&lt;/h3&gt;
&lt;p&gt;Before this release, Rust allowed you to have your types be parameterized over lifetimes or types. For example if we wanted to have a &lt;code&gt;struct&lt;/code&gt; that is generic over the element type of an array, we&#x27;d write the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct FixedArray&amp;lt;T&amp;gt; {
              // ^^^ Type generic definition
    list: [T; 32]
        // ^ Where we&#x27;re using it.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we then use &lt;code&gt;FixedArray&amp;lt;u8&amp;gt;&lt;/code&gt;, the compiler will make a monomorphic version of &lt;code&gt;FixedArray&lt;/code&gt; that looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct FixedArray&amp;lt;u8&amp;gt; {
    list: [u8; 32]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a powerful feature that allows you to write reusable code with no runtime overhead. However, until this release it hasn&#x27;t been possible to easily be generic over the &lt;em&gt;values&lt;/em&gt; of those types. This was most notable in arrays which include their length in their type definition (&lt;code&gt;[T; N]&lt;/code&gt;), which previously you could not be generic over. Now with 1.51.0 you can write code that is generic over the values of any integer, &lt;code&gt;bool&lt;/code&gt;, or &lt;code&gt;char&lt;/code&gt; type! (Using &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;enum&lt;/code&gt; values is still unstable.)&lt;/p&gt;
&lt;p&gt;This change now lets us have our own array struct that&#x27;s generic over its type &lt;em&gt;and&lt;/em&gt; its length. Let&#x27;s look at an example definition, and how it can be used.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct Array&amp;lt;T, const LENGTH: usize&amp;gt; {
    //          ^^^^^^^^^^^^^^^^^^^ Const generic definition.
    list: [T; LENGTH]
    //        ^^^^^^ We use it here.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now if we then used &lt;code&gt;Array&amp;lt;u8, 32&amp;gt;&lt;/code&gt;, the compiler will make a monomorphic version of &lt;code&gt;Array&lt;/code&gt; that looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct Array&amp;lt;u8, 32&amp;gt; {
    list: [u8; 32]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Const generics adds an important new tool for library designers in creating new, powerful compile-time safe APIs. If you&#x27;d like to learn more about const generics you can also check out the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html&quot;&gt;&amp;quot;Const Generics MVP Hits Beta&amp;quot;&lt;/a&gt; blog post for more information about the feature and its current restrictions. We can&#x27;t wait to see what new libraries and APIs you create!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#arrayintoiter-stabilisation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;arrayintoiter-stabilisation&quot;&gt;&lt;/a&gt;&lt;code&gt;array::IntoIter&lt;/code&gt; Stabilisation&lt;/h3&gt;
&lt;p&gt;As part of const generics stabilising, we&#x27;re also stabilising a new API that uses it, &lt;code&gt;std::array::IntoIter&lt;/code&gt;. &lt;code&gt;IntoIter&lt;/code&gt; allows you to create a by value iterator over any array. Previously there wasn&#x27;t a convenient way to iterate over owned values of an array, only references to them.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn main() {
  let array &#x3D; [1, 2, 3, 4, 5];
  
  // Previously
  for item in array.iter().copied() {
      println!(&amp;quot;{}&amp;quot;, item);
  }
  
  // Now
  for item in std::array::IntoIter::new(array) {
      println!(&amp;quot;{}&amp;quot;, item);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this is added as a separate method instead of &lt;code&gt;.into_iter()&lt;/code&gt; on arrays, as that currently introduces some amount of breakage; currently &lt;code&gt;.into_iter()&lt;/code&gt; refers to the slice by-reference iterator. We&#x27;re exploring ways to make this more ergonomic in the future.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargos-new-feature-resolver&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargos-new-feature-resolver&quot;&gt;&lt;/a&gt;Cargo&#x27;s New Feature Resolver&lt;/h3&gt;
&lt;p&gt;Dependency management is a hard problem, and one of the hardest parts of it is just picking what &lt;em&gt;version&lt;/em&gt; of a dependency to use when it&#x27;s depended on by two different packages. This doesn&#x27;t just include its version number, but also what features are or aren&#x27;t enabled for the package. Cargo&#x27;s default behaviour is to merge features for a single package when it&#x27;s referred to multiple times in the dependency graph.&lt;/p&gt;
&lt;p&gt;For example, let&#x27;s say you had a dependency called &lt;code&gt;foo&lt;/code&gt; with features A and B, which was being used by packages &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;, but &lt;code&gt;bar&lt;/code&gt; depends on &lt;code&gt;foo+A&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; depends on &lt;code&gt;foo+B&lt;/code&gt;. Cargo will merge both of those features and compile &lt;code&gt;foo&lt;/code&gt; as &lt;code&gt;foo+AB&lt;/code&gt;. This has a benefit that you only have to compile &lt;code&gt;foo&lt;/code&gt; once, and then it can reused for both &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;However, this also comes with a downside. What if a feature enabled in a build-dependency is not compatible with the target you are building for?&lt;/p&gt;
&lt;p&gt;A common example of this in the ecosystem is the optional &lt;code&gt;std&lt;/code&gt; feature included in many &lt;code&gt;#![no_std]&lt;/code&gt; crates, that allows crates to provide added functionality when &lt;code&gt;std&lt;/code&gt; is available. Now imagine you want to use the &lt;code&gt;#![no_std]&lt;/code&gt; version of &lt;code&gt;foo&lt;/code&gt; in your &lt;code&gt;#![no_std]&lt;/code&gt; binary, and use the &lt;code&gt;foo&lt;/code&gt; at build time in your &lt;code&gt;build.rs&lt;/code&gt;. If your build time dependency depends on &lt;code&gt;foo+std&lt;/code&gt;, your binary now also depends on &lt;code&gt;foo+std&lt;/code&gt;, which means it will no longer compile because &lt;code&gt;std&lt;/code&gt; is not available for your target platform.&lt;/p&gt;
&lt;p&gt;This has been a long-standing issue in cargo, and with this release there&#x27;s a new &lt;code&gt;resolver&lt;/code&gt; option in your &lt;code&gt;Cargo.toml&lt;/code&gt;, where you can set &lt;code&gt;resolver&#x3D;&amp;quot;2&amp;quot;&lt;/code&gt; to tell cargo to try a new approach to resolving features. You can check out &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2957-cargo-features2.html&quot;&gt;RFC 2957&lt;/a&gt; for a detailed description of the behaviour, which can be summarised as follows.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dev dependencies&lt;/strong&gt; — When a package is shared as a normal dependency and a dev-dependency, the dev-dependency features are only enabled if the current build is including dev-dependencies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Host Dependencies&lt;/strong&gt; — When a package is shared as a normal dependency and a build-dependency or proc-macro, the features for the normal dependency are kept independent of the build-dependency or proc-macro.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Target dependencies&lt;/strong&gt; — When a package appears multiple times in the build graph, and one of those instances is a target-specific dependency, then the features of the target-specific dependency are only enabled if the target is currently being built.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While this can lead to some crates compiling more than once, this should provide a much more intuitive development experience when using features with cargo. If you&#x27;d like to know more, you can also read the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/cargo/reference/features.html#feature-resolver-version-2&quot;&gt;&amp;quot;Feature Resolver&amp;quot;&lt;/a&gt; section in the Cargo Book for more information. We&#x27;d like to thank the cargo team and everyone involved for all their hard work in designing and implementing the new resolver!&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[package]
resolver &#x3D; &amp;quot;2&amp;quot;
# Or if you&#x27;re using a workspace
[workspace]
resolver &#x3D; &amp;quot;2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#splitting-debug-information&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;splitting-debug-information&quot;&gt;&lt;/a&gt;Splitting Debug Information&lt;/h3&gt;
&lt;p&gt;While not often highlighted in the release, the Rust teams are constantly working on improving Rust&#x27;s compile times, and this release marks one of the largest improvements in a long time for Rust on macOS. Debug information maps the binary code back to your source code, so that the program can give you more information about what went wrong at runtime. In macOS, debug info was previously collected into a single &lt;code&gt;.dSYM&lt;/code&gt; folder using a tool called &lt;code&gt;dsymutil&lt;/code&gt;, which can take some time and use up quite a bit of disk space.&lt;/p&gt;
&lt;p&gt;Collecting all of the debuginfo into this directory helps in finding it at runtime, particularly if the binary is being moved. However, it does have the drawback that even when you make a small change to your program, &lt;code&gt;dsymutil&lt;/code&gt; will need to run over the entire final binary to produce the final &lt;code&gt;.dSYM&lt;/code&gt; folder. This can sometimes add a lot to the build time, especially for larger projects, as all dependencies always get recollected, but this has been a necessary step as without it Rust&#x27;s standard library didn&#x27;t know how to load the debug info on macOS.&lt;/p&gt;
&lt;p&gt;Recently, Rust backtraces switched to using a different backend which supports loading debuginfo without needing to run &lt;code&gt;dsymutil&lt;/code&gt;, and we&#x27;ve stabilized support for skipping the &lt;code&gt;dsymutil&lt;/code&gt; run. This can significantly speed up builds that include debuginfo and significantly reduce the amount of disk space used. We haven&#x27;t run extensive benchmarks, but have seen a lot of reports of people&#x27;s builds being a lot faster on macOS with this behavior.&lt;/p&gt;
&lt;p&gt;You can enable this new behaviour by setting the &lt;code&gt;-Csplit-debuginfo&#x3D;unpacked&lt;/code&gt; flag when running &lt;code&gt;rustc&lt;/code&gt;, or by setting the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#split-debuginfo&quot;&gt;&lt;code&gt;split-debuginfo&lt;/code&gt;&lt;/a&gt; &lt;code&gt;[profile]&lt;/code&gt; option to &lt;code&gt;unpacked&lt;/code&gt; in Cargo. The &amp;quot;unpacked&amp;quot; option instructs rustc to leave the .o object files in the build output directory instead of deleting them, and skips the step of running dsymutil. Rust&#x27;s backtrace support is smart enough to know how to find these .o files. Tools such as lldb also know how to do this. This should work as long as you don&#x27;t need to move the binary to a different location while retaining the debug information.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-toml&quot;&gt;[profile.dev]
split-debuginfo &#x3D; &amp;quot;unpacked&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;In total, this release saw the stabilisation of 18 new methods for various types like &lt;code&gt;slice&lt;/code&gt; and &lt;code&gt;Peekable&lt;/code&gt;. One notable addition is the stabilisation of &lt;code&gt;ptr::addr_of!&lt;/code&gt; and &lt;code&gt;ptr::addr_of_mut!&lt;/code&gt;, which allow you to create raw pointers to unaligned fields. Previously this wasn&#x27;t possible because Rust requires &lt;code&gt;&amp;amp;/&amp;amp;mut&lt;/code&gt; to be aligned and point to initialized data, and &lt;code&gt;&amp;amp;addr as *const _&lt;/code&gt; would then cause undefined behaviour as &lt;code&gt;&amp;amp;addr&lt;/code&gt; needs to be aligned. These two macros now let you safely create unaligned pointers.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::ptr;

#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}

let packed &#x3D; Packed { f1: 1, f2: 2 };
// &#x60;&amp;amp;packed.f2&#x60; would create an unaligned reference, and thus be Undefined Behavior!
let raw_f2 &#x3D; ptr::addr_of!(packed.f2);
assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following methods were stabilised.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.decrement_strong_count&quot;&gt;&lt;code&gt;Arc::decrement_strong_count&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Arc.html#method.increment_strong_count&quot;&gt;&lt;code&gt;Arc::increment_strong_count&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Once.html#method.call_once_force&quot;&gt;&lt;code&gt;Once::call_once_force&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html#method.next_if_eq&quot;&gt;&lt;code&gt;Peekable::next_if_eq&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html#method.next_if&quot;&gt;&lt;code&gt;Peekable::next_if&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/trait.Seek.html#method.stream_position&quot;&gt;&lt;code&gt;Seek::stream_position&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/array/struct.IntoIter.html&quot;&gt;&lt;code&gt;array::IntoIter&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html&quot;&gt;&lt;code&gt;panic::panic_any&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ptr/macro.addr_of.html&quot;&gt;&lt;code&gt;ptr::addr_of!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ptr/macro.addr_of_mut.html&quot;&gt;&lt;code&gt;ptr::addr_of_mut!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.fill_with&quot;&gt;&lt;code&gt;slice::fill_with&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_inclusive_mut&quot;&gt;&lt;code&gt;slice::split_inclusive_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.split_inclusive&quot;&gt;&lt;code&gt;slice::split_inclusive&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.strip_prefix&quot;&gt;&lt;code&gt;slice::strip_prefix&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.strip_suffix&quot;&gt;&lt;code&gt;slice::strip_suffix&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.str.html#method.split_inclusive&quot;&gt;&lt;code&gt;str::split_inclusive&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.OnceState.html&quot;&gt;&lt;code&gt;sync::OnceState&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/task/trait.Wake.html&quot;&gt;&lt;code&gt;task::Wake&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.51.0 release: check out what changed in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1510-2021-03-25&quot;&gt;Rust&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-151-2021-03-25&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-151&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1510&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1510&quot;&gt;&lt;/a&gt;Contributors to 1.51.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.51.0. We couldn&#x27;t have done it without all of you. &lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.51.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Building a shared vision for Async Rust</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/03/18/async-vision-doc.html" type="text/html" title="Building a shared vision for Async Rust" />
        <published>2021-03-18T00:00:00+00:00</published>
        <updated>2021-03-18T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/03/18/async-vision-doc.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/03/18/async-vision-doc.html">&lt;p&gt;The &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/&quot;&gt;Async Foundations Working Group&lt;/a&gt; believes Rust can become one of the most popular choices for building distributed systems, ranging from embedded devices to foundational cloud services. Whatever they&#x27;re using it for, we want all developers to love using Async Rust. For that to happen, we need to move Async Rust beyond the &amp;quot;MVP&amp;quot; state it&#x27;s in today and make it accessible to everyone.&lt;/p&gt;
&lt;p&gt;We are launching a collaborative effort to build a shared &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision.html#-the-vision&quot;&gt;vision document&lt;/a&gt; for Async Rust. &lt;strong&gt;Our goal is to engage the entire community in a collective act of the imagination:&lt;/strong&gt; how can we make the end-to-end experience of using Async I/O not only a pragmatic choice, but a &lt;em&gt;joyful&lt;/em&gt; one?&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#the-vision-document-starts-with-the-status-quo&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-vision-document-starts-with-the-status-quo&quot;&gt;&lt;/a&gt;The vision document starts with the status quo...&lt;/h3&gt;
&lt;p&gt;The &amp;quot;vision document&amp;quot; starts with a &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/characters.html&quot;&gt;cast of characters&lt;/a&gt;. Each character is tied to a particular Rust value (e.g., performance, productivity, etc) determined by their background; this background also informs the expectations they bring when using Rust.&lt;/p&gt;
&lt;p&gt;Let me introduce you to one character, &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/characters/grace.html&quot;&gt;Grace&lt;/a&gt;. As an experienced C developer, Grace is used to high performance and control, but she likes the idea of using Rust to get memory safety. Here is her biography:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Grace has been writing C and C++ for a number of years. She&#x27;s accustomed to hacking lots of low-level details to coax the most performance she can from her code. She&#x27;s also experienced her share of epic debugging sessions resulting from memory errors in C. She&#x27;s intrigued by Rust: she likes the idea of getting the same control and performance she gets from C but with the productivity benefits she gets from memory safety. She&#x27;s currently experimenting with introducing Rust into some of the systems she works on, and she&#x27;s considering Rust for a few greenfield projects as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For each character, we will write a series of &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/status_quo.html&quot;&gt;&amp;quot;status quo&amp;quot; stories&lt;/a&gt; that describe the challenges they face as they try to achieve their goals (and typically fail in dramatic fashion!) &lt;strong&gt;These stories are not fiction.&lt;/strong&gt; They are an amalgamation of the real experiences of people using Async Rust, as reported to us by interviews, blog posts, and tweets. To give you the idea, we currently have two examples: one where &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/status_quo/grace_deploys_her_service.html&quot;&gt;Grace has to debug a custom future that she wrote&lt;/a&gt;, and another where &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/characters/alan.html&quot;&gt;Alan&lt;/a&gt; -- a programmer coming from a GC&#x27;d language -- &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/status_quo/alan_runs_into_stack_trouble.html&quot;&gt;encounters a stack overflow and has to debug the cause&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Writing the &amp;quot;status quo&amp;quot; stories helps us to compensate for the &lt;a href&#x3D;&quot;https://en.wikipedia.org/wiki/Curse_of_knowledge&quot;&gt;curse of knowledge&lt;/a&gt;: the folks working on Async Rust tend to be experts in Async Rust. We&#x27;ve gotten used to the &lt;a href&#x3D;&quot;https://github.com/rust-lang/async-book/tree/a927107bfe501a44dde1560a5942b1471c11c71d/src/07_workarounds&quot;&gt;workarounds&lt;/a&gt; required to be productive, and we know the little tips and tricks that can get you out of a jam. The stories help us gauge the cumulative impact all the paper cuts can have on someone still learning their way around. This gives us the data we need to prioritize.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#and-then-tells-how-we-will-change-it&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;and-then-tells-how-we-will-change-it&quot;&gt;&lt;/a&gt;...and then tells how we will change it&lt;/h3&gt;
&lt;p&gt;The ultimate goal of the vision doc, of course, is not just to tell us where we are now, but where we are going and how  we will get there. Once we&#x27;ve made good progress on the status quo stories, the next step will be start brainstorming stories about the &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/shiny_future.html&quot;&gt;&amp;quot;shiny future&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Shiny future stories talk about what the world of async could look like 2 or 3 years in the future. Typically, they will replay the same scenario as a &amp;quot;status quo&amp;quot; story, but with a happier ending. For example, maybe Grace has access to a debugging tool that is able to diagnose her stuck tasks and tell her what kind of future they are blocked on, so she doesn&#x27;t have to grep through the logs. Maybe the compiler could warn Alan about a likely stack overflow, or (better yet) we can tweak the design of &lt;code&gt;select&lt;/code&gt; to avoid the problem in the first place. The idea is to be ambitious and focus first and foremost on the user experience we want to create; we&#x27;ll figure out the steps along the way (and maybe adjust the goal, if we have to).&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#involving-the-whole-community&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;involving-the-whole-community&quot;&gt;&lt;/a&gt;Involving the whole community&lt;/h3&gt;
&lt;p&gt;The async vision document provides a forum where the Async Rust community can plan a great overall experience for Async Rust users. Async Rust was intentionally designed not to have a &amp;quot;one size fits all&amp;quot; mindset, and we don&#x27;t want to change that. Our goal is to build a shared vision for the end-to-end experience while retaining the loosely coupled, exploration-oriented ecosystem we have built.&lt;/p&gt;
&lt;p&gt;The process we are using to write the vision doc encourages active collaboration and &amp;quot;positive sum&amp;quot; thinking. It starts with a brainstorming period, during which we aim to collect as many &amp;quot;status quo&amp;quot; and &amp;quot;shiny future&amp;quot; stories as we can. This brainstorming period runs for six weeks, until the end of April. For the first two weeks (until 2021-04-02), we are collecting &amp;quot;status quo&amp;quot; stories only. After that, we will accept both &amp;quot;status quo&amp;quot; and &amp;quot;shiny future&amp;quot; stories until the end of the brainstorming period. Finally, to cap off the brainstorming period, we will select winners for &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision/awards.html&quot;&gt;awards&lt;/a&gt; like &amp;quot;Most Humorous Story&amp;quot; or &amp;quot;Must Supportive Contributor&amp;quot;.&lt;/p&gt;
&lt;p&gt;Once the brainstorming period is complete, the working group leads will begin work on assembling the various stories and shiny futures into a coherent draft. This draft will be reviewed by the community and the Rust teams and adjusted based on feedback.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#want-to-help&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;want-to-help&quot;&gt;&lt;/a&gt;Want to help?&lt;/h3&gt;
&lt;p&gt;If you&#x27;d like to help us to write the vision document, we&#x27;d love for you to contribute your experiences and vision! Right now, we are focused on creating status quo stories. We are looking for people to author PRs or to talk about their experiences on issues or elsewhere. If you&#x27;d like to get started, check out the &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/status_quo/template.html&quot;&gt;template for status quo stories&lt;/a&gt; -- it has all the information you need to open a PR. Alternatively, you can view the &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision.html&quot;&gt;How To Vision&lt;/a&gt; page, which covers the whole vision document process in detail.&lt;/p&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Const generics MVP hits beta!</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html" type="text/html" title="Const generics MVP hits beta!" />
        <published>2021-02-26T00:00:00+00:00</published>
        <updated>2021-02-26T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html">&lt;p&gt;After more than 3 years since the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md&quot;&gt;original RFC for const generics&lt;/a&gt; was accepted, &lt;strong&gt;the first version of const generics is now available in the Rust beta channel!&lt;/strong&gt; It will be available in the 1.51 release, which is expected to be released on &lt;strong&gt;March 25th, 2021&lt;/strong&gt;. Const generics is one of the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html&quot;&gt;most highly anticipated&lt;/a&gt; features coming to Rust, and we&#x27;re excited for people to start taking advantage of the increased power of the language following this addition.&lt;/p&gt;
&lt;p&gt;Even if you don&#x27;t know what const generics are (in which case, read on!), you&#x27;ve likely been benefitting from them: const generics are already employed in the Rust standard library to improve the ergonomics of arrays and diagnostics; more on that below.&lt;/p&gt;
&lt;p&gt;With const generics hitting beta, let&#x27;s take a quick look over what&#x27;s actually being stabilized, what this means practically, and what&#x27;s next.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-are-const-generics&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-are-const-generics&quot;&gt;&lt;/a&gt;What are const generics?&lt;/h2&gt;
&lt;p&gt;Const generics are generic arguments that range over constant values, rather than types or lifetimes. This allows, for instance, types to be parameterized by integers. In fact, there has been one example of const generic types since early on in Rust&#x27;s development: the array types &lt;code&gt;[T; N]&lt;/code&gt;, for some type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;N: usize&lt;/code&gt;. However, there has previously been no way to abstract over arrays of an arbitrary size: if you wanted to implement a trait for arrays of any size, you would have to do so manually for each possible value. For a long time, even the standard library methods for arrays were limited to arrays of length at most 32 due to this problem. This restriction was &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2020/10/08/Rust-1.47.html#traits-on-larger-arrays&quot;&gt;finally lifted in Rust 1.47&lt;/a&gt; - a change that was made possible by const generics.&lt;/p&gt;
&lt;p&gt;Here&#x27;s an example of a type and implementation making use of const generics: a type wrapping a pair of arrays of the same size.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;struct ArrayPair&amp;lt;T, const N: usize&amp;gt; {
    left: [T; N],
    right: [T; N],
}

impl&amp;lt;T: Debug, const N: usize&amp;gt; Debug for ArrayPair&amp;lt;T, N&amp;gt; {
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#current-restrictions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;current-restrictions&quot;&gt;&lt;/a&gt;Current restrictions&lt;/h3&gt;
&lt;p&gt;The first iteration of const generics has been deliberately constrained: in other words, this version is the MVP (minimal viable product) for const generics. This decision is motivated both by the additional complexity of general const generics (the implementation for general const generics is not yet complete, but we feel const generics in 1.51 are already very useful), as well as by the desire to introduce a large feature gradually, to gain experience with any potential shortcomings and difficulties. We intend to lift these in future versions of Rust: see &lt;a href&#x3D;&quot;#whats-next&quot;&gt;what&#x27;s next&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#only-integral-types-are-permitted-for-const-generics&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;only-integral-types-are-permitted-for-const-generics&quot;&gt;&lt;/a&gt;Only integral types are permitted for const generics&lt;/h4&gt;
&lt;p&gt;For now, the only types that may be used as the type of a const generic argument are the types of integers (i.e. signed and unsigned integers, including &lt;code&gt;isize&lt;/code&gt; and &lt;code&gt;usize&lt;/code&gt;) as well as &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;bool&lt;/code&gt;. This covers a primary use case of const, namely abstracting over arrays. In the future, this restriction will be lifted to allow more complex types, such as &lt;code&gt;&amp;amp;str&lt;/code&gt; and user-defined types.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#no-complex-generic-expressions-in-const-arguments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;no-complex-generic-expressions-in-const-arguments&quot;&gt;&lt;/a&gt;No complex generic expressions in const arguments&lt;/h4&gt;
&lt;p&gt;Currently, const parameters may only be instantiated by const arguments of the following forms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A standalone const parameter.&lt;/li&gt;
&lt;li&gt;A literal (i.e. an integer, bool, or character).&lt;/li&gt;
&lt;li&gt;A concrete constant expression (enclosed by &lt;code&gt;{}&lt;/code&gt;), involving no generic parameters.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn foo&amp;lt;const N: usize&amp;gt;() {}

fn bar&amp;lt;T, const M: usize&amp;gt;() {
    foo::&amp;lt;M&amp;gt;(); // ok: &#x60;M&#x60; is a const parameter
    foo::&amp;lt;2021&amp;gt;(); // ok: &#x60;2021&#x60; is a literal
    foo::&amp;lt;{20 * 100 + 20 * 10 + 1}&amp;gt;(); // ok: const expression contains no generic parameters
    
    foo::&amp;lt;{ M + 1 }&amp;gt;(); // error: const expression contains the generic parameter &#x60;M&#x60;
    foo::&amp;lt;{ std::mem::size_of::&amp;lt;T&amp;gt;() }&amp;gt;(); // error: const expression contains the generic parameter &#x60;T&#x60;
    
    let _: [u8; M]; // ok: &#x60;M&#x60; is a const parameter
    let _: [u8; std::mem::size_of::&amp;lt;T&amp;gt;()]; // error: const expression contains the generic parameter &#x60;T&#x60;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#by-value-array-iterator&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;by-value-array-iterator&quot;&gt;&lt;/a&gt;By-value array iterator&lt;/h2&gt;
&lt;p&gt;In addition to the language changes described above, we&#x27;ve also started adding methods to the standard library taking advantage of const generics. While most are not yet ready for stabilization in this version, there is one method that has been stabilized. &lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/std/array/struct.IntoIter.html&quot;&gt;&lt;code&gt;array::IntoIter&lt;/code&gt;&lt;/a&gt; allows arrays to be iterated by value, rather than by reference, addressing a significant shortcoming. There is ongoing discussion about the possibility of implementing &lt;code&gt;IntoIterator&lt;/code&gt; directly for arrays, though there are &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/65819&quot;&gt;backwards-compatibility concerns&lt;/a&gt; that still have to be addressed. &lt;code&gt;IntoIter::new&lt;/code&gt; acts as an interim solution that makes working with arrays significantly simpler.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;use std::array;
fn needs_vec(v: Vec&amp;lt;i32&amp;gt;) {
    // ...
}

let arr &#x3D; [vec![0, 1], vec![1, 2, 3], vec![3]];
for elem in array::IntoIter::new(arr) {
    needs_vec(elem);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-next&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-next&quot;&gt;&lt;/a&gt;What&#x27;s next?&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-generics-and-default-arguments&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-generics-and-default-arguments&quot;&gt;&lt;/a&gt;Const generics and default arguments&lt;/h3&gt;
&lt;p&gt;Generic parameters must currently come in a specific order: lifetimes, types, consts. However, this causes difficulties when one attempts to use default arguments alongside const parameters. For the compiler to know which generic argument is which, any default arguments need to be placed last. These two constraints - &amp;quot;types come before consts&amp;quot;, and &amp;quot;defaults come last&amp;quot; - conflict with each other for definitions that have default type arguments &lt;em&gt;and&lt;/em&gt; const parameters.&lt;/p&gt;
&lt;p&gt;The solution to this is to relax the ordering constraint so that const parameters may precede type arguments. However, there turn out to be subtleties involved in implementing this change, because the Rust compiler currently makes assumptions about parameter ordering that require some delicacy to remove.&lt;/p&gt;
&lt;p&gt;In light of similar design questions around defaults for const arguments, these are also currently not supported in version 1.51. However, fixing the parameter ordering issues above will also unblock const defaults.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-generics-for-custom-types&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-generics-for-custom-types&quot;&gt;&lt;/a&gt;Const generics for custom types&lt;/h3&gt;
&lt;p&gt;For a type to be valid, in theory, as the type of a const parameter, we must be able to compare values of that type at compile-time. Furthermore, equality of values should be well-behaved (namely, it should be deterministic, reflexive, symmetric, and transitive). To guarantee these properties, the concept of &lt;em&gt;structural equality&lt;/em&gt; was introduced in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/2000-const-generics.md&quot;&gt;const generics RFC&lt;/a&gt;: essentially this includes any type with &lt;code&gt;#[derive(PartialEq, Eq)]&lt;/code&gt; whose members also satisfy structural equality.&lt;/p&gt;
&lt;p&gt;There are &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/74446&quot;&gt;still some questions&lt;/a&gt; concerning precisely how structural equality should behave, and &lt;a href&#x3D;&quot;https://github.com/rust-lang/compiler-team/issues/323&quot;&gt;prerequisites for implementation&lt;/a&gt;. Primitive types are significantly simpler, which has allowed us to stabilize const generics for these types before more general types.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-generics-with-complex-expressions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-generics-with-complex-expressions&quot;&gt;&lt;/a&gt;Const generics with complex expressions&lt;/h3&gt;
&lt;p&gt;There are several complexities involved in supporting complex expressions. A feature flag, &lt;code&gt;feature(const_evaluatable_checked)&lt;/code&gt;, is available in the Nightly channel, which enables a version of complex expression support for const generics.&lt;/p&gt;
&lt;p&gt;One difficulty lies in the necessity of having some way to compare unevaluated constants, as the compiler does not automatically know that two syntactically identical expressions are actually equal. This involves a kind of symbolic reasoning about expressions, which is a complex problem in general.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// The two expressions &#x60;N + 1&#x60; and &#x60;N + 1&#x60; are distinct
// entities in the compiler, so we need a way to check
// if they should be considered equal.
fn foo&amp;lt;const N: usize&amp;gt;() -&amp;gt; [u8; N + 1] {
    [0; N + 1]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also want a way to deal with potential errors when evaluating generic operations.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn split_first&amp;lt;T, const N: usize&amp;gt;(arr: [T; N]) -&amp;gt; (T, [T; N - 1]) {
    // ...
}

fn generic_function&amp;lt;const M: usize&amp;gt;(arr: [i32; M]) {
    // ...
    let (head, tail) &#x3D; split_first(arr);
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Without a way to restrict the possible values of &lt;code&gt;M&lt;/code&gt; here, calling &lt;code&gt;generic_function::&amp;lt;0&amp;gt;()&lt;/code&gt; would cause an error when evaluating &lt;code&gt;0 - 1&lt;/code&gt; that is not caught at declaration time and so may unexpectedly fail for downstream users.&lt;/p&gt;
&lt;p&gt;There are &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/68436&quot;&gt;design questions&lt;/a&gt; about how exactly to express these kinds of bounds, which need to be addressed before stabilising complex const arguments.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#summary&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;summary&quot;&gt;&lt;/a&gt;Summary&lt;/h2&gt;
&lt;p&gt;With such a major new feature, there are likely to be a few rough edges. If you encounter any problems, even if it&#x27;s as minor as a confusing error message, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;please open an issue&lt;/a&gt;! We want the user experience to be the best it can possibly be - and any issues now are likely to be even more important for the next iterations of const generics.&lt;/p&gt;
</content>

        <author>
            <name>The const generics project group</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.50.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/02/11/Rust-1.50.0.html" type="text/html" title="Announcing Rust 1.50.0" />
        <published>2021-02-11T00:00:00+00:00</published>
        <updated>2021-02-11T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/02/11/Rust-1.50.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/02/11/Rust-1.50.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.50.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.50.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1500-2021-02-11&quot;&gt;detailed release notes for 1.50.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1500-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1500-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.50.0 stable&lt;/h2&gt;
&lt;p&gt;For this release, we have improved array indexing, expanded safe access to union fields, and added to the standard library.
See the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1500-2021-02-11&quot;&gt;detailed release notes&lt;/a&gt; to learn about other changes
not covered by this post.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-generic-array-indexing&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-generic-array-indexing&quot;&gt;&lt;/a&gt;Const-generic array indexing&lt;/h3&gt;
&lt;p&gt;Continuing the march toward stable &lt;code&gt;const&lt;/code&gt; generics, this release adds
implementations of &lt;code&gt;ops::Index&lt;/code&gt; and &lt;code&gt;IndexMut&lt;/code&gt; for arrays &lt;code&gt;[T; N]&lt;/code&gt; for
&lt;em&gt;any&lt;/em&gt; length of &lt;code&gt;const N&lt;/code&gt;. The indexing operator &lt;code&gt;[]&lt;/code&gt; already worked on
arrays through built-in compiler magic, but at the type level, arrays
didn&#x27;t actually implement the library traits until now.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn second&amp;lt;C&amp;gt;(container: &amp;amp;C) -&amp;gt; &amp;amp;C::Output
where
    C: std::ops::Index&amp;lt;usize&amp;gt; + ?Sized,
{
    &amp;amp;container[1]
}

fn main() {
    let array: [i32; 3] &#x3D; [1, 2, 3];
    assert_eq!(second(&amp;amp;array[..]), &amp;amp;2); // slices worked before
    assert_eq!(second(&amp;amp;array), &amp;amp;2); // now it also works directly
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-value-repetition-for-arrays&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-value-repetition-for-arrays&quot;&gt;&lt;/a&gt;&lt;code&gt;const&lt;/code&gt; value repetition for arrays&lt;/h3&gt;
&lt;p&gt;Arrays in Rust can be written either as a list &lt;code&gt;[a, b, c]&lt;/code&gt; or a repetition &lt;code&gt;[x; N]&lt;/code&gt;.
For lengths &lt;code&gt;N&lt;/code&gt; greater than one, repetition has only been allowed for &lt;code&gt;x&lt;/code&gt;s that are &lt;code&gt;Copy&lt;/code&gt;,
and &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2203-const-repeat-expr.html&quot;&gt;RFC 2203&lt;/a&gt; sought to allow any &lt;code&gt;const&lt;/code&gt; expression there. However,
while that feature was unstable for arbitrary expressions, its implementation
since Rust 1.38 accidentally allowed stable use of &lt;code&gt;const&lt;/code&gt; &lt;em&gt;values&lt;/em&gt; in array
repetition.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn main() {
    // This is not allowed, because &#x60;Option&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;&#x60; does not implement &#x60;Copy&#x60;.
    let array: [Option&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt;; 10] &#x3D; [None; 10];

    const NONE: Option&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; &#x3D; None;
    const EMPTY: Option&amp;lt;Vec&amp;lt;i32&amp;gt;&amp;gt; &#x3D; Some(Vec::new());

    // However, repeating a &#x60;const&#x60; value is allowed!
    let nones &#x3D; [NONE; 10];
    let empties &#x3D; [EMPTY; 10];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Rust 1.50, that stabilization is formally acknowledged. In the future, to avoid such &amp;quot;temporary&amp;quot; named
constants, you can look forward to inline &lt;code&gt;const&lt;/code&gt; expressions per &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2920-inline-const.html&quot;&gt;RFC 2920&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#safe-assignments-to-manuallydropt-union-fields&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;safe-assignments-to-manuallydropt-union-fields&quot;&gt;&lt;/a&gt;Safe assignments to &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; union fields&lt;/h3&gt;
&lt;p&gt;Rust 1.49 made it possible to add &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; fields to a &lt;code&gt;union&lt;/code&gt; as part
of allowing &lt;code&gt;Drop&lt;/code&gt; for unions at all. However, unions don&#x27;t drop old values
when a field is assigned, since they don&#x27;t know which variant was formerly
valid, so safe Rust previously limited this to &lt;code&gt;Copy&lt;/code&gt; types only, which never &lt;code&gt;Drop&lt;/code&gt;.
Of course, &lt;code&gt;ManuallyDrop&amp;lt;T&amp;gt;&lt;/code&gt; also doesn&#x27;t need to &lt;code&gt;Drop&lt;/code&gt;, so now Rust 1.50
allows safe assignments to these fields as well.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#a-niche-for-file-on-unix-platforms&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-niche-for-file-on-unix-platforms&quot;&gt;&lt;/a&gt;A niche for &lt;code&gt;File&lt;/code&gt; on Unix platforms&lt;/h3&gt;
&lt;p&gt;Some types in Rust have specific limitations on what is considered a
valid value, which may not cover the entire range of possible memory
values. We call any remaining invalid value a &lt;a href&#x3D;&quot;https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#niche&quot;&gt;niche&lt;/a&gt;, and this space
may be used for type layout optimizations. For example, in Rust 1.28
we introduced &lt;code&gt;NonZero&lt;/code&gt; integer types (like &lt;code&gt;NonZeroU8&lt;/code&gt;) where &lt;code&gt;0&lt;/code&gt; is a niche, and this allowed
&lt;code&gt;Option&amp;lt;NonZero&amp;gt;&lt;/code&gt; to use &lt;code&gt;0&lt;/code&gt; to represent &lt;code&gt;None&lt;/code&gt; with no extra memory.&lt;/p&gt;
&lt;p&gt;On Unix platforms, Rust&#x27;s &lt;code&gt;File&lt;/code&gt; is simply made of the system&#x27;s integer
file descriptor, and this happens to have a possible niche
as well because it can never be &lt;code&gt;-1&lt;/code&gt;! System calls which return a file
descriptor use &lt;code&gt;-1&lt;/code&gt; to indicate that an error occurred (check &lt;code&gt;errno&lt;/code&gt;)
so it&#x27;s never possible for &lt;code&gt;-1&lt;/code&gt; to be a real file descriptor. Starting
in Rust 1.50 this niche is added to the type&#x27;s definition so it can be
used in layout optimizations too. It follows that &lt;code&gt;Option&amp;lt;File&amp;gt;&lt;/code&gt; will
now have the same size as &lt;code&gt;File&lt;/code&gt; itself!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#library-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;library-changes&quot;&gt;&lt;/a&gt;Library changes&lt;/h3&gt;
&lt;p&gt;In Rust 1.50.0, there are nine new stable functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.bool.html#method.then&quot;&gt;&lt;code&gt;bool::then&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/btree_map/enum.Entry.html#method.or_insert_with_key&quot;&gt;&lt;code&gt;btree_map::Entry::or_insert_with_key&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.f32.html#method.clamp&quot;&gt;&lt;code&gt;f32::clamp&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.f64.html#method.clamp&quot;&gt;&lt;code&gt;f64::clamp&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/hash_map/enum.Entry.html#method.or_insert_with_key&quot;&gt;&lt;code&gt;hash_map::Entry::or_insert_with_key&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/trait.Ord.html#method.clamp&quot;&gt;&lt;code&gt;Ord::clamp&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html#method.take&quot;&gt;&lt;code&gt;RefCell::take&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.fill&quot;&gt;&lt;code&gt;slice::fill&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html#method.get_mut&quot;&gt;&lt;code&gt;UnsafeCell::get_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And quite a few existing functions were made &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_ipv4&quot;&gt;&lt;code&gt;IpAddr::is_ipv4&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html#method.is_ipv6&quot;&gt;&lt;code&gt;IpAddr::is_ipv6&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.size&quot;&gt;&lt;code&gt;Layout::size&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.align&quot;&gt;&lt;code&gt;Layout::align&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html#method.from_size_align&quot;&gt;&lt;code&gt;Layout::from_size_align&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pow&lt;/code&gt; for all integer types.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checked_pow&lt;/code&gt; for all integer types.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;saturating_pow&lt;/code&gt; for all integer types.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrapping_pow&lt;/code&gt; for all integer types.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;next_power_of_two&lt;/code&gt; for all unsigned integer types.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checked_power_of_two&lt;/code&gt; for all unsigned integer types.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1500-2021-02-11&quot;&gt;detailed release notes&lt;/a&gt; to learn about other changes.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.50.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1500-2021-02-11&quot;&gt;Rust&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-150-2021-02-11&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-150&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#contributors-to-1500&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1500&quot;&gt;&lt;/a&gt;Contributors to 1.50.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.50.0. We couldn&#x27;t have done it
without all of you. &lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.50.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>mdBook security advisory</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/01/04/mdbook-security-advisory.html" type="text/html" title="mdBook security advisory" />
        <published>2021-01-04T00:00:00+00:00</published>
        <updated>2021-01-04T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/01/04/mdbook-security-advisory.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/01/04/mdbook-security-advisory.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/3-sO6of29O0&quot;&gt;the official security advisory&lt;/a&gt;. The official post
contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response Working Group was recently notified of a security
issue affecting the search feature of mdBook, which could allow an attacker to
execute arbitrary JavaScript code on the page.&lt;/p&gt;
&lt;p&gt;The CVE for this vulnerability is &lt;a href&#x3D;&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name&#x3D;CVE-2020-26297&quot;&gt;CVE-2020-26297&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#overview&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;overview&quot;&gt;&lt;/a&gt;Overview&lt;/h2&gt;
&lt;p&gt;The search feature of mdBook (introduced in version 0.1.4) was affected by a
cross site scripting vulnerability that allowed an attacker to execute
arbitrary JavaScript code on an user&#x27;s browser by tricking the user into typing
a malicious search query, or tricking the user into clicking a link to the
search page with the malicious search query prefilled.&lt;/p&gt;
&lt;p&gt;mdBook 0.4.5 fixes the vulnerability by properly escaping the search query.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;Owners of websites built with mdBook have to upgrade to mdBook 0.4.5 or greater
and rebuild their website contents with it. It&#x27;s possible to install mdBook
0.4.5 on the local system with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cargo install mdbook --version 0.4.5 --force
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;Thanks to Kamil Vavra for responsibly disclosing the vulnerability to us
according to &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;our security policy&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#timeline-of-events&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;timeline-of-events&quot;&gt;&lt;/a&gt;Timeline of events&lt;/h2&gt;
&lt;p&gt;All times are listed in UTC.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2020-12-30 20:14 - The issue is reported to the Rust Security Response WG&lt;/li&gt;
&lt;li&gt;2020-12-30 20:32 - The issue is acknowledged and the investigation began&lt;/li&gt;
&lt;li&gt;2020-12-30 21:21 - Found the cause of the vulnerability and prepared the patch&lt;/li&gt;
&lt;li&gt;2021-01-04 15:00 - Patched version released and vulnerability disclosed&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.49.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html" type="text/html" title="Announcing Rust 1.49.0" />
        <published>2020-12-31T00:00:00+00:00</published>
        <updated>2020-12-31T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2020/12/31/Rust-1.49.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.49.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.49.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the
appropriate page on our website, and check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1490-2020-12-31&quot;&gt;detailed release notes for
1.49.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1490-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1490-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.49.0 stable&lt;/h2&gt;
&lt;p&gt;For this release, we have some new targets and an improvement to the test
framework. See the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1490-2020-12-31&quot;&gt;detailed release notes&lt;/a&gt; to learn about other
changes not covered by this post.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#64-bit-arm-linux-reaches-tier-1&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;64-bit-arm-linux-reaches-tier-1&quot;&gt;&lt;/a&gt;64-bit ARM Linux reaches Tier 1&lt;/h3&gt;
&lt;p&gt;The Rust compiler supports &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/rustc/platform-support.html&quot;&gt;a wide variety of targets&lt;/a&gt;, but
the Rust Team can&#x27;t provide the same level of support for all of them. To
clearly mark how supported each target is, we use a tiering system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tier 3 targets are technically supported by the compiler, but we don&#x27;t check
whether their code build or passes the tests, and we don&#x27;t provide any
prebuilt binaries as part of our releases.&lt;/li&gt;
&lt;li&gt;Tier 2 targets are guaranteed to build and we provide prebuilt binaries, but
we don&#x27;t execute the test suite on those platforms: the produced binaries
might not work or might have bugs.&lt;/li&gt;
&lt;li&gt;Tier 1 targets provide the highest support guarantee, and we run the full
suite on those platforms for every change merged in the compiler. Prebuilt
binaries are also available.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rust 1.49.0 promotes the &lt;code&gt;aarch64-unknown-linux-gnu&lt;/code&gt; target to Tier 1 support,
bringing our highest guarantees to users of 64-bit ARM systems running Linux!
We expect this change to benefit workloads spanning from embedded to desktops
and servers.&lt;/p&gt;
&lt;p&gt;This is an important milestone for the project, since it&#x27;s the first time a
non-x86 target has reached Tier 1 support: we hope this will pave the way for
more targets to reach our highest tier in the future.&lt;/p&gt;
&lt;p&gt;Note that Android is not affected by this change as it uses a different Tier 2
target.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#64-bit-arm-macos-and-windows-reach-tier-2&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;64-bit-arm-macos-and-windows-reach-tier-2&quot;&gt;&lt;/a&gt;64-bit ARM macOS and Windows reach Tier 2&lt;/h3&gt;
&lt;p&gt;Rust 1.49.0 also features two targets reaching Tier 2 support:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;aarch64-apple-darwin&lt;/code&gt; target brings support for Rust on Apple M1 systems.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;aarch64-pc-windows-msvc&lt;/code&gt; target brings support for Rust on 64-bit ARM
devices running Windows on ARM.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Developers can expect both of those targets to have prebuilt binaries
installable with &lt;code&gt;rustup&lt;/code&gt; from now on! The Rust Team is not running the test
suite on those platforms though, so there might be bugs or instabilities.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#test-framework-captures-output-in-threads&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;test-framework-captures-output-in-threads&quot;&gt;&lt;/a&gt;Test framework captures output in threads&lt;/h3&gt;
&lt;p&gt;Rust&#x27;s built-in testing framework doesn&#x27;t have a ton of features, but that
doesn&#x27;t mean it can&#x27;t be improved! Consider a test that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;#[test]
fn thready_pass() {
    println!(&amp;quot;fee&amp;quot;);
    std::thread::spawn(|| {
        println!(&amp;quot;fie&amp;quot;);
        println!(&amp;quot;foe&amp;quot;);
    })
    .join()
    .unwrap();
    println!(&amp;quot;fum&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here&#x27;s what running this test looks like before Rust 1.49.0:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;❯ cargo +1.48.0 test
   Compiling threadtest v0.1.0 (C:\threadtest)
    Finished test [unoptimized + debuginfo] target(s) in 0.38s
     Running target\debug\deps\threadtest-02f42ffd9836cae5.exe

running 1 test
fie
foe
test thready_pass ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests threadtest

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see that the output from the thread is printed, which intermixes
from the output of the test framework itself. Wouldn&#x27;t it be nice
if every &lt;code&gt;println!&lt;/code&gt; worked like that one that prints &amp;quot;&lt;code&gt;fum&lt;/code&gt;?&amp;quot; Well, &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/78227&quot;&gt;that&#x27;s
the behavior in Rust 1.49.0&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;❯ cargo test
   Compiling threadtest v0.1.0 (C:\threadtest)
    Finished test [unoptimized + debuginfo] target(s) in 0.52s
     Running target\debug\deps\threadtest-40aabfaa345584be.exe

running 1 test
test thready_pass ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests threadtest

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But don&#x27;t worry; if the test were to fail, you&#x27;ll still see all of the
output. By adding a &lt;code&gt;panic!&lt;/code&gt; to the end of the test, we can see what failure
looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;❯ cargo test
   Compiling threadtest v0.1.0 (C:\threadtest)
    Finished test [unoptimized + debuginfo] target(s) in 0.52s
     Running target\debug\deps\threadtest-40aabfaa345584be.exe

running 1 test
test thready_pass ... FAILED

failures:

---- thready_pass stdout ----
fee
fie
foe
fum
thread &#x27;thready_pass&#x27; panicked at &#x27;explicit panic&#x27;, src\lib.rs:11:5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Specifically, the test runner makes sure to capture the output, and saves it
in case the test fails.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#library-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;library-changes&quot;&gt;&lt;/a&gt;Library changes&lt;/h3&gt;
&lt;p&gt;In Rust 1.49.0, there are three new stable functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable&quot;&gt;&lt;code&gt;slice::select_nth_unstable&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable_by&quot;&gt;&lt;code&gt;slice::select_nth_unstable_by&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.select_nth_unstable_by_key&quot;&gt;&lt;code&gt;slice::select_nth_unstable_by_key&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And two functions were made &lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/task/enum.Poll.html#method.is_ready&quot;&gt;&lt;code&gt;Poll::is_ready&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/task/enum.Poll.html#method.is_pending&quot;&gt;&lt;code&gt;Poll::is_pending&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1490-2020-12-31&quot;&gt;detailed release notes&lt;/a&gt; to learn about other changes.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.49.0 release: check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1490-2020-12-31&quot;&gt;Rust&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-149-2020-12-31&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-149&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#contributors-to-1490&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1490&quot;&gt;&lt;/a&gt;Contributors to 1.49.0&lt;/h2&gt;
&lt;p&gt;Many people came together to create Rust 1.49.0. We couldn&#x27;t have done it
without all of you. &lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.49.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Rust Survey 2020 Results</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html" type="text/html" title="Rust Survey 2020 Results" />
        <published>2020-12-16T00:00:00+00:00</published>
        <updated>2020-12-16T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2020/12/16/rust-survey-2020.html">&lt;p&gt;Greetings Rustaceans!&lt;/p&gt;
&lt;p&gt;Another year has passed, and with it comes another annual Rust survey analysis! The survey was &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2020/09/10/survey-launch.html&quot;&gt;conducted&lt;/a&gt; in the second half of September 2020 over a two-week period. We’d like to thank everyone who participated in this year’s survey with a special shout-out to those who helped translate non-English responses.&lt;/p&gt;
&lt;p&gt;Without further ado, let’s dive into the analysis!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#survey-audience&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;survey-audience&quot;&gt;&lt;/a&gt;Survey Audience&lt;/h2&gt;
&lt;p&gt;The survey was available in &lt;strong&gt;14&lt;/strong&gt; different languages and had a record &lt;strong&gt;8,323&lt;/strong&gt; total responses.&lt;/p&gt;
&lt;p&gt;Here&#x27;s the distribution of languages across the responses:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;English: 75.0%&lt;/li&gt;
&lt;li&gt;Simplified Chinese: 5.4%&lt;/li&gt;
&lt;li&gt;Russian: 5.3%&lt;/li&gt;
&lt;li&gt;German: 4.0%&lt;/li&gt;
&lt;li&gt;French: 2.7%&lt;/li&gt;
&lt;li&gt;Japanese: 2.2%&lt;/li&gt;
&lt;li&gt;Korean: 1.2%&lt;/li&gt;
&lt;li&gt;Traditional Chinese: 1.1%&lt;/li&gt;
&lt;li&gt;Spanish: 1.0%&lt;/li&gt;
&lt;li&gt;Portuguese: 0.7%&lt;/li&gt;
&lt;li&gt;Italian: 0.6%&lt;/li&gt;
&lt;li&gt;Swedish: 0.5%&lt;/li&gt;
&lt;li&gt;Vietnamese: 0.1%&lt;/li&gt;
&lt;li&gt;Polish: 0.1%&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;83.0% of respondents said they used Rust (an all time high) while 7% said they had used Rust in the past but no longer do. When asked why they had stopped using Rust, the largest group (35%) said they just hadn’t learned it yet (presumably from lack of time), followed by those whose company was not using Rust (34%) and those who said switching to Rust would “slow them down” compared to their current language of choice (19%).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#stability&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stability&quot;&gt;&lt;/a&gt;Stability&lt;/h2&gt;
&lt;p&gt;While Rust itself has always had a strong stability guarantee, stability often means more than just ensuring users’ code doesn’t break when compiled with a new version of the compiler. Rust in 2020 has largely been about cleaning up and stabilizing features and initiatives that were already under way. While this work is not nearly completed, respondents have noted that the stability of Rust in general has been improving.&lt;/p&gt;
&lt;p&gt;First, we’d like to make a shout out to the &lt;a href&#x3D;&quot;https://rust-analyzer.github.io/&quot;&gt;rust-analyzer&lt;/a&gt; and &lt;a href&#x3D;&quot;https://intellij-rust.github.io/&quot;&gt;IntelliJ Rust plugin&lt;/a&gt; projects which both enjoy relatively happy user bases. Nearly 3/4ths of all respondents noted that they saw at least some improvement in the IDE story, but users of rust-analyzer and IntelliJ were especially happy with 47% of rust-analyzer users noting “a lot of improvement” while 40% of IntelliJ users said the same.&lt;/p&gt;
&lt;p&gt;In addition to improvements in the IDE experience, the number of users who are relying on a nightly compiler at least part of the time continues to drop - down to 28% compared with last year’s 30.5% with only 8.7% of respondents saying they use nightly exclusively. When asked why people are using nightly the largest reason was to use the Rocket web framework which has announced &lt;a href&#x3D;&quot;https://github.com/SergioBenitez/Rocket/issues/19&quot;&gt;it will work on the stable version of Rust in its next release&lt;/a&gt;. The next largest reason for nightly was const generics, but with &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/79135&quot;&gt;a minimal version of const generics reaching stable&lt;/a&gt;, we should see less of a reliance on nightly for this feature.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2020-12-rust-survey-2020/rust-versions.svg&quot; alt&#x3D;&quot;Which versions of Rust do you use?&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It’s worth noting that a decent percentage of users who use nightly do so out of habit because “nightly is stable enough”. When asked what broke people’s code most often, by far the largest answer was the introduction of new warnings to a code base where warnings break the build (which is not part of Rust’s stability guarantee though Rust is designed so that adding new warnings never breaks your dependencies). Since we rely on nightly testing to catch regressions, this is a very good sign: nightly is stable enough to be useful while still allowing for continual changes. A shout-out to the Rust infrastructure, compiler, and libs teams for doing such a good job of ensuring that what lands in the nightly compiler is already fairly stable!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whos-using-rust&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whos-using-rust&quot;&gt;&lt;/a&gt;Who’s using Rust?&lt;/h2&gt;
&lt;p&gt;Rust continues to make inroads as a language used for production with roughly 40% of respondents that work in software noting that they use Rust at their day job. Additionally, the future of Rust on the job is bright with nearly half of those who knew saying that their employer planned to hire Rust developers in the next year.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2020-12-rust-survey-2020/rust-at-work.svg&quot; alt&#x3D;&quot;Do you use Rust at work?&quot; /&gt;&lt;/p&gt;
&lt;p&gt;The seemingly largest change in those using Rust seems to be students with a much larger percentage (~15% vs ~11% last year) of the respondents answering that they don’t use Rust at work because they’re students or software hobbyists and therefore don’t have a job in software.&lt;/p&gt;
&lt;p&gt;Additionally, the use of Rust at respondents&#x27; workplaces seems to be getting bigger with 44% of respondents saying that the amount of Rust at work was 10,000 lines of code or more compared to 34% last year.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2020-12-rust-survey-2020/project-size.svg&quot; alt&#x3D;&quot;Size of Rust code bases at work&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#improving-rust&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;improving-rust&quot;&gt;&lt;/a&gt;Improving Rust&lt;/h2&gt;
&lt;p&gt;While Rust usage seems to be growing at a healthy pace, the results of the survey made it clear that there is still work to be done to make Rust a more appropriate tool for many people’s workflows.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#c-interop&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;c-interop&quot;&gt;&lt;/a&gt;C++ Interop&lt;/h3&gt;
&lt;p&gt;Interestingly, C++ was the most requested language for better interop with Rust, with C and Python in second and third place. Improved C++ interop was especially often mentioned as a way to improve Rust usage specifically at work. In fact, for users who work on large codebases (100,000 lines of code or larger), C++ interop and — unsurprisingly — compile times were the most cited ways to improve their Rust experience.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2020-12-rust-survey-2020/language-interop.svg&quot; alt&#x3D;&quot;If you want better language interop, with which language?&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#improved-learnability&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;improved-learnability&quot;&gt;&lt;/a&gt;Improved Learnability&lt;/h3&gt;
&lt;p&gt;When asked how to improve adoption of Rust, many cited making Rust easier to learn with 15.8% of respondents saying they would use Rust more if it were “less intimidating, easier to learn, or less complicated”. Additionally when directly asked how people think we can improve adoption of Rust, the largest category of feedback was documentation and training.&lt;/p&gt;
&lt;p&gt;When we asked respondents to rate their expertise in Rust, there was a clear peak at 7 out of 10. It’s hard to say how this compares across languages but it seems notable that relatively few are willing to claim full expertise. However, when compared with last year, the Rust community does seem to be gaining expertise in the language.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2020-12-rust-survey-2020/rust-expertise-overall.svg&quot; alt&#x3D;&quot;How would you rate your expertise in Rust?&quot; /&gt;&lt;/p&gt;
&lt;p&gt;We also asked about the difficulty of specific topics. The most difficult topic to learn according to survey results is somewhat unsurprisingly lifetime management with 61.4% of respondents saying that the use of lifetimes is either tricky or very difficult.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2020-12-rust-survey-2020/topic-difficulty-ratings.svg&quot; alt&#x3D;&quot;Percent of respondents rating each topic as tricky or very difficult.&quot; /&gt;&lt;/p&gt;
&lt;p&gt;It does seem that having C++ knowledge helps with 20.2% of respondents with at least some C++ experience noting lifetimes to be “very difficult” while 22.2% of those without C++ knowledge found the topic to be “very difficult”. Overall, systems programming knowledge (defined as at least some experience in C and C++), tends to make for more confident Rust users: those with systems programming experience rated themselves as 5.5 out of 10 on their Rust expertise, while those with experience in statically typed garbage collected languages like Java or C# rated themselves as 4.9 out of 10. Those with only experience in dynamically typed languages like Ruby or JavaScript rated themselves as 4.8 out of 10.&lt;/p&gt;
&lt;p&gt;Unsurprisingly, the more often people use Rust, the more they feel they are experts in the language with 56.3% of those who use Rust daily ranking themselves as 7 or more out of 10 on how much of an expert they are on Rust compared with 22% of those who use Rust monthly.&lt;/p&gt;
&lt;p&gt;&lt;img src&#x3D;&quot;/images/2020-12-rust-survey-2020/rust-expertise-daily.svg&quot; alt&#x3D;&quot;How would you rate your expertise in Rust? (Daily Rust users)&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#compile-times&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;compile-times&quot;&gt;&lt;/a&gt;Compile Times&lt;/h3&gt;
&lt;p&gt;One continuing topic of importance to the Rust community and the Rust team is improving compile times. Progress has already been made with 50.5% of respondents saying they felt compile times have improved. This improvement was particularly pronounced with respondents with large codebases (10,000 lines of code or more) where 62.6% citing improvement and only 2.9% saying they have gotten worse. Improving compile times is likely to be the source of significant effort in 2021, so stay tuned!&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#library-support&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;library-support&quot;&gt;&lt;/a&gt;Library Support&lt;/h3&gt;
&lt;p&gt;In general, respondents seemed pleased with the growing library support in the Rust ecosystem with 65.9% of respondents saying they had seen at least some improvement and only 4.9% saying they hadn&#x27;t seen any improvement. When asked what type of library support was missing most, GUI programming was the overwhelming answer with only 26.9% of respondents noting that this was an area of improvement in the last year.&lt;/p&gt;
&lt;p&gt;Additional topics for improvement include maturing the async programming story, more libraries for specific tasks not already covered by the crates.io ecosystem, and more &amp;quot;blessed&amp;quot; libraries for common tasks.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#community&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;community&quot;&gt;&lt;/a&gt;Community&lt;/h3&gt;
&lt;p&gt;Ways that the Rust community could improve varied but were highlighted by two popular points. First, improving the state of the Rust community for those who do not wish to or cannot participate in English. There does not seem to be a particular language that is especially underserved with Russian, Mandarin, Japanese, Portuguese, Spanish and French coming up frequently.&lt;/p&gt;
&lt;p&gt;Additionally, many said that having large corporate sponsors in the Rust community will make it easier for them to make the case for using Rust at work.&lt;/p&gt;
&lt;p&gt;Another interesting find was that Europe seemed by far to be the most favored place for holding a Rust conference with all parts of Europe (West, East, North, South, and Central) all having more than 14% of respondents saying they would be interested in attending a conference there with Western Europe getting the highest percentage (26.3% of respondents). The only other region in the same ballpark was the United States with 21.6% of respondents saying they’d be interested in a conference located there.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#getting-excited-for-rusts-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;getting-excited-for-rusts-future&quot;&gt;&lt;/a&gt;Getting Excited for Rust’s Future&lt;/h2&gt;
&lt;p&gt;Generally, respondents seemed to have a positive picture not only for how Rust has improved over the last year but for the year to come. In particular, many noted their excitement for new features to the language such as const generics and generic associated types (GATs) as well as the 2021 edition, improvements to async, the Bevy game engine, more adoption of Rust by companies, WebAssembly and more!&lt;/p&gt;
&lt;p&gt;Here’s to an exciting 2021! 🎉🦀&lt;/p&gt;
</content>

        <author>
            <name>The Rust Survey Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Next steps for the Foundation Conversation</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2020/12/14/Next-steps-for-the-foundation-conversation.html" type="text/html" title="Next steps for the Foundation Conversation" />
        <published>2020-12-14T00:00:00+00:00</published>
        <updated>2020-12-14T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2020/12/14/Next-steps-for-the-foundation-conversation.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2020/12/14/Next-steps-for-the-foundation-conversation.html">&lt;p&gt;Last week we kicked off the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2020/12/07/the-foundation-conversation.html&quot;&gt;Foundation Conversation&lt;/a&gt;, a week-long period of Q&amp;amp;A forums and live broadcasts with the goal of explaining our vision for the Foundation and finding out what sorts of questions people had. We used those questions to help build a &lt;a href&#x3D;&quot;https://github.com/rust-lang/foundation-faq-2020/blob/main/FAQ.md&quot;&gt;draft Foundation FAQ&lt;/a&gt;, and if you’ve not seen it yet, you should definitely take a look -- it’s chock full of good information. Thanks to everyone for asking such great questions!&lt;/p&gt;
&lt;p&gt;We’ve created a &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSfeq4L0Rk6yXzGS19A6qLo4hpLlQiJh1nYFHsRJ9MrxO6k4iQ/viewform&quot;&gt;new survey&lt;/a&gt; that asks about how people experienced the Foundation Conversation. Please take a moment to &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSfeq4L0Rk6yXzGS19A6qLo4hpLlQiJh1nYFHsRJ9MrxO6k4iQ/viewform&quot;&gt;fill it out&lt;/a&gt;! We’re planning a similar event for this January, so your feedback will be really helpful.&lt;/p&gt;
&lt;p&gt;This post is going to discuss how the Foundation and the Rust project relate to one another.&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#what-is-the-central-purpose-of-the-foundation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-the-central-purpose-of-the-foundation&quot;&gt;&lt;/a&gt;What is the central purpose of the Foundation?&lt;/h1&gt;
&lt;p&gt;At its core, &lt;em&gt;the mission of the Foundation is to empower the Rust maintainers to joyfully do their best work&lt;/em&gt;. We think of the Foundation as working with the teams, helping them to create the scaffolding that people need to contribute and participate in the Rust project.&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#the-scope-and-role-of-the-rust-teams-does-not-change&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-scope-and-role-of-the-rust-teams-does-not-change&quot;&gt;&lt;/a&gt;The scope and role of the Rust teams does not change&lt;/h1&gt;
&lt;p&gt;For most Rust teams, the creation of the Foundation doesn’t change anything about the scope of their work and decision making authority. The compiler team is still going to be maintaining the compiler, the community team will still be helping coordinate and mentor community events, and so forth. One exception is the Rust core team: there are various legal details that we expect to off-load onto the Foundation.&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#let-the-rust-teams-be-their-best-selves&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;let-the-rust-teams-be-their-best-selves&quot;&gt;&lt;/a&gt;Let the Rust teams be their best selves&lt;/h1&gt;
&lt;p&gt;We are really excited for all the things that the Foundation will make possible for the Rust teams. We hope to draw on the Foundation to target some of the hardest problems in running an open-source project. We’re thinking of programs like offering training for maintainers, assistance with product and program management, access to trained mediators for conflict management, as well as facilitating events to help contributors get more high bandwidth communication (assuming, that is, we’re ever allowed to leave our houses again).&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#what-comes-next&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-comes-next&quot;&gt;&lt;/a&gt;What comes next&lt;/h1&gt;
&lt;p&gt;This last week has been intense -- we calculated about 60 person hours of sync time answering questions -- and it’s been really valuable. The questions that everyone asked really helped us to refine and sharpen our thinking. For the remainder of the year we are going to be working hard on finalizing the details of the Foundation. We expect to launch the Foundation officially early next year! In the meantime, remember to fill out our &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSfeq4L0Rk6yXzGS19A6qLo4hpLlQiJh1nYFHsRJ9MrxO6k4iQ/viewform&quot;&gt;survey&lt;/a&gt;!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Launching the Lock Poisoning Survey</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2020/12/11/lock-poisoning-survey.html" type="text/html" title="Launching the Lock Poisoning Survey" />
        <published>2020-12-11T00:00:00+00:00</published>
        <updated>2020-12-11T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2020/12/11/lock-poisoning-survey.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2020/12/11/lock-poisoning-survey.html">&lt;p&gt;The Libs team is looking at how we can improve the &lt;code&gt;std::sync&lt;/code&gt; module, by potentially splitting it up into new modules and making some changes to APIs along the way.
One of those API changes we&#x27;re looking at is non-poisoning implementations of &lt;code&gt;Mutex&lt;/code&gt; and &lt;code&gt;RwLock&lt;/code&gt;.
To find the best path forward we&#x27;re conducting a survey to get a clearer picture of how the standard locks are used out in the wild.&lt;/p&gt;
&lt;p&gt;The survey is a Google Form.
&lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSehk-GkwoCag_w3YfXDfgeANulR0h5m2d3EzUMQaiY1vRfIEw/viewform&quot;&gt;You can fill it out here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#what-is-this-survey-for&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-this-survey-for&quot;&gt;&lt;/a&gt;What is this survey for?&lt;/h3&gt;
&lt;p&gt;The survey is intended to answer the following questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When is poisoning on &lt;code&gt;Mutex&lt;/code&gt; and &lt;code&gt;RwLock&lt;/code&gt; being used deliberately.&lt;/li&gt;
&lt;li&gt;Whether &lt;code&gt;Mutex&lt;/code&gt; and &lt;code&gt;RwLock&lt;/code&gt; (and their guard types) appear in the public API of libraries.&lt;/li&gt;
&lt;li&gt;How much friction there is switching from the poisoning &lt;code&gt;Mutex&lt;/code&gt; and &lt;code&gt;RwLock&lt;/code&gt; locks to non-poisoning ones (such as from &lt;code&gt;antidote&lt;/code&gt; or &lt;code&gt;parking_lot&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This information will then inform an RFC that will set out a path to non-poisoning locks in the standard library.
It may also give us a starting point for looking at the tangentially related &lt;code&gt;UnwindSafe&lt;/code&gt; and &lt;code&gt;RefUnwindSafe&lt;/code&gt; traits for panic safety.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#who-is-this-survey-for&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;who-is-this-survey-for&quot;&gt;&lt;/a&gt;Who is this survey for?&lt;/h3&gt;
&lt;p&gt;If you write code that uses locks then this survey is for you.
That includes the standard library&#x27;s &lt;code&gt;Mutex&lt;/code&gt; and &lt;code&gt;RwLock&lt;/code&gt; as well as locks from &lt;code&gt;crates.io&lt;/code&gt;, such as &lt;code&gt;antidote&lt;/code&gt;, &lt;code&gt;parking_lot&lt;/code&gt;, and &lt;code&gt;tokio::sync&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#so-what-is-poisoning-anyway&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;so-what-is-poisoning-anyway&quot;&gt;&lt;/a&gt;So what is poisoning anyway?&lt;/h3&gt;
&lt;p&gt;Let&#x27;s say you have an &lt;code&gt;Account&lt;/code&gt; that can update its balance:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl Account {
    pub fn update_balance(&amp;amp;mut self, change: i32) {
        self.balance +&#x3D; change;
        self.changes.push(change);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#x27;s also say we have the invariant that &lt;code&gt;balance &#x3D;&#x3D; changes.sum()&lt;/code&gt;.
We&#x27;ll call this the &lt;em&gt;balance invariant&lt;/em&gt;.
So at any point when interacting with an &lt;code&gt;Account&lt;/code&gt; you can always depend on its &lt;code&gt;balance&lt;/code&gt; being the sum of its &lt;code&gt;changes&lt;/code&gt;, thanks to the balance invariant.&lt;/p&gt;
&lt;p&gt;There&#x27;s a point in our &lt;code&gt;update_balance&lt;/code&gt; method where the balance invariant isn&#x27;t maintained though:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;impl Account {
    pub fn update_balance(&amp;amp;mut self, change: i32) {
        self.balance +&#x3D; change;
//      self.balance !&#x3D; self.changes.sum()
        self.changes.push(change);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That seems ok, because we&#x27;re in the middle of a method with exclusive access to our &lt;code&gt;Account&lt;/code&gt; and everything is back to good when we return.
There isn&#x27;t a &lt;code&gt;Result&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; to be seen so we know there&#x27;s no chance of an early return before the balance invariant is restored. Or so we think.&lt;/p&gt;
&lt;p&gt;What if &lt;code&gt;self.changes.push&lt;/code&gt; didn&#x27;t return normally?
What if it panicked instead without actually doing anything?
Then we&#x27;d return from &lt;code&gt;update_balance&lt;/code&gt; early without restoring the balance invariant.
That seems ok too, because a panic will start unwinding the thread it was called from, leaving no trace of any data it owned behind.
Ignoring the &lt;code&gt;Drop&lt;/code&gt; trait, no data means no broken invariants.
Problem solved, right?&lt;/p&gt;
&lt;p&gt;What if our &lt;code&gt;Account&lt;/code&gt; wasn&#x27;t owned by that thread that panicked?
What if it was shared with other threads as a &lt;code&gt;Arc&amp;lt;Mutex&amp;lt;Account&amp;gt;&amp;gt;&lt;/code&gt;?
Unwinding one thread isn&#x27;t going to protect other threads that could still access the &lt;code&gt;Account&lt;/code&gt;, and they&#x27;re not going to know that it&#x27;s now invalid.&lt;/p&gt;
&lt;p&gt;This is where poisoning comes in.
The &lt;code&gt;Mutex&lt;/code&gt; and &lt;code&gt;RwLock&lt;/code&gt; types in the standard library use a strategy that makes panics (and by extension the possibility for broken invariants) observable.
The next consumer of the lock, such as another thread that didn&#x27;t unwind, can decide at that point what to do about it.
This is done by storing a switch in the lock itself that&#x27;s flipped when a panic causes a thread to unwind through its guard.
Once that switch is flipped the lock is considered &lt;em&gt;poisoned&lt;/em&gt;, and the next attempt to acquire it will receive an error instead of a guard.&lt;/p&gt;
&lt;p&gt;The standard approach for dealing with a poisoned lock is to propagate the panic to the current thread by unwrapping the error it returns:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let mut guard &#x3D; shared.lock().unwrap();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That way nobody can ever observe the possibly violated balance invariant on our shared &lt;code&gt;Account&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That sounds great! So why would we want to remove it?&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#whats-wrong-with-lock-poisoning&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-wrong-with-lock-poisoning&quot;&gt;&lt;/a&gt;What&#x27;s wrong with lock poisoning?&lt;/h3&gt;
&lt;p&gt;There&#x27;s nothing wrong with poisoning itself.
It&#x27;s an excellent pattern for dealing with failures that can leave behind unworkable state.
The question we&#x27;re really asking is whether it should be used by the &lt;em&gt;standard locks&lt;/em&gt;, which are &lt;code&gt;std::sync::Mutex&lt;/code&gt; and &lt;code&gt;std::sync::RwLock&lt;/code&gt;.
We&#x27;re asking whether it&#x27;s a standard lock&#x27;s job to implement poisoning. Just to avoid any confusion, we&#x27;ll distinguish the poisoning pattern from the API of the standard locks by calling the former &lt;em&gt;poisoning&lt;/em&gt; and the latter &lt;em&gt;lock poisoning&lt;/em&gt;.
We&#x27;re just talking about lock poisoning.&lt;/p&gt;
&lt;p&gt;In the previous section we motivated poisoning as a way to protect us from possibly broken invariants.
Lock poisoning isn&#x27;t actually a tool for doing this in the way you might think.
In general, a poisoned lock can&#x27;t tell whether or not any invariants are &lt;em&gt;actually&lt;/em&gt; broken.
It assumes that a lock is shared, so is likely going to outlive any individual thread that can access it.
It also assumes that if a panic leaves any data behind then it&#x27;s more likely to be left in an unexpected state, because panics aren&#x27;t part of normal control flow in Rust.
Everything &lt;em&gt;could&lt;/em&gt; be fine after a panic, but the standard lock can&#x27;t guarantee it.
Since there&#x27;s no guarantee there&#x27;s an escape hatch.
We can always still get access to the state guarded by a poisoned lock:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let mut guard &#x3D; shared.lock().unwrap_or_else(|err| err.into_inner());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All Rust code needs to remain free from any possible undefined behavior in the presence of panics, so ignoring panics is always safe.
Rust doesn&#x27;t try guarantee all safe code is free from logic bugs, so broken invariants that don&#x27;t potentially lead to undefined behavior aren&#x27;t strictly considered unsafe.
Since ignoring lock poisoning is also always safe it doesn&#x27;t really give you a dependable tool to protect state from panics.
You can always ignore it.&lt;/p&gt;
&lt;p&gt;So lock poisoning doesn&#x27;t give you a tool for guaranteeing safety in the presence of panics.
What it does give you is a way to propagate those panics to other threads.
The machinery needed to do this adds costs to using the standard locks.
There&#x27;s an ergonomic cost in having to call &lt;code&gt;.lock().unwrap()&lt;/code&gt;, and a runtime cost in having to actually track state for panics.&lt;/p&gt;
&lt;p&gt;With the standard locks you pay those costs whether you need to or not.
That&#x27;s not typically how APIs in the standard library work.
Instead, you compose costs together so you only pay for what you need.
Should it be a standard lock&#x27;s job to synchronize access &lt;em&gt;and&lt;/em&gt; propagate panics?
We&#x27;re not so sure it is.
If it&#x27;s not then what should we do about it?
That&#x27;s where the survey comes in.
We&#x27;d like to get a better idea of how you use locks and poisoning in your projects to help decide what to do about lock poisoning.
&lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSehk-GkwoCag_w3YfXDfgeANulR0h5m2d3EzUMQaiY1vRfIEw/viewform&quot;&gt;You can fill it out here&lt;/a&gt;.&lt;/p&gt;
</content>

        <author>
            <name>Ashley Mannix</name>
        </author>
    </entry>
    
    <entry>
        <title>The Foundation Conversation</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2020/12/07/the-foundation-conversation.html" type="text/html" title="The Foundation Conversation" />
        <published>2020-12-07T00:00:00+00:00</published>
        <updated>2020-12-07T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2020/12/07/the-foundation-conversation.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2020/12/07/the-foundation-conversation.html">&lt;p&gt;In August, we on the Core Team &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html&quot;&gt;announced our plans to create a Foundation&lt;/a&gt; by the end of the year. Since that time, we’ve been doing a lot of work but it has been difficult to share many details, and we know that a lot of you have questions.&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#the-foundation-conversation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-foundation-conversation&quot;&gt;&lt;/a&gt;The &amp;quot;Foundation Conversation&amp;quot;&lt;/h1&gt;
&lt;p&gt;This blog post announces the start of the “Foundation Conversation”. This is a week-long period in which we have planned a number of forums and opportunities where folks can ask questions about the Foundation and get answers from the Core team. It includes both text-based “question-and-answer” (Q&amp;amp;A) periods as well as live broadcasts. We’re also going to be coming to the Rust team’s meetings to have discussions. We hope that this will help us to share our vision for the Foundation and to get the community excited about what’s to come.&lt;/p&gt;
&lt;p&gt;A secondary goal for the Foundation Conversation is to help us develop the Foundation FAQ. Most FAQs get written before anyone has ever really asked a question, but we really wanted to write a FAQ that responds honestly to the questions that people have. We’ve currently got a draft of the FAQ which is based both on questions we thought people would ask and questions that were raised by Rust team members thus far, but we would like to extend it to include questions raised by people in the broader community. That’s where you come in!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#how-to-join-the-conversation&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-to-join-the-conversation&quot;&gt;&lt;/a&gt;How to join the conversation&lt;/h2&gt;
&lt;p&gt;There are many ways to participate in the Foundation Conversation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/foundation-faq-2020/blob/main/FAQ.md&quot;&gt;Read the draft FAQ we’ve been working on&lt;/a&gt;&lt;/strong&gt;. It contains the answers to some of the questions that we have been asked thus far.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Fill out our &lt;a href&#x3D;&quot;https://docs.google.com/forms/d/e/1FAIpQLSeciTU1hLi-Y5842fvWC2lhYRHvkWOtPbk39p72amGcGmZIaA/viewform&quot;&gt;survey&lt;/a&gt;&lt;/strong&gt;. This survey is designed to help us understand how the Rust community is feeling about the Foundation.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ask questions during the Community Q&amp;amp;A periods&lt;/strong&gt;. We’ve scheduled a number of 3 hour periods during which the foundation-faq-2020 repo will be open for anyone to ask questions. There will be members of the core team around during those periods to answer those questions as best we can.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Watch our Live Broadcasts&lt;/strong&gt;. We’ve scheduled live broadcasts this week where members of the core team will be answering and discussing some of the questions that have come up thus far. These will be posted to YouTube later.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Read on for more details.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#the-foundation-faq-2020-repository&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-foundation-faq-2020-repository&quot;&gt;&lt;/a&gt;The foundation-faq-2020 repository&lt;/h2&gt;
&lt;p&gt;We have chosen to coordinate the Foundation Conversation using a GitHub repository called &lt;a href&#x3D;&quot;https://github.com/rust-lang/foundation-faq-2020&quot;&gt;foundation-faq-2020&lt;/a&gt;. This repository contains the &lt;a href&#x3D;&quot;https://github.com/rust-lang/foundation-faq-2020/blob/main/FAQ.md&quot;&gt;draft FAQ&lt;/a&gt; we’ve written so far, along with a series of issues representing the questions that people have. Last week we opened the repository for Rust team members, so you can see that we’ve already had quite a few questions raised (and answered). Once a new issue is opened, someone from the core team will come along and post an answer, and then label the question as “&lt;a href&#x3D;&quot;https://github.com/rust-lang/foundation-faq-2020/issues?q&#x3D;is%3Aissue+is%3Aopen+label%3Aanswered&quot;&gt;answered&lt;/a&gt;”.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#community-qa-sessions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;community-qa-sessions&quot;&gt;&lt;/a&gt;Community Q&amp;amp;A sessions&lt;/h2&gt;
&lt;p&gt;We have scheduled a number of 3 hour periods in which the repository will be open for anyone to open new issues. Outside of these slots, the repository is generally “read only” unless you are a member of a Rust team. We are calling these slots the “Community Q&amp;amp;A” sessions, since it is a time for the broader community to open questions and get answers.&lt;/p&gt;
&lt;p&gt;We’ve tried to stagger the times for the “Community Q&amp;amp;A” periods to be accessible from all time zones. During each slot, members of the core team will be standing by to monitor new questions and post answers. In some cases, if the question is complex, we may hold off on answering right away and instead take time to draft the response and post it later.&lt;/p&gt;
&lt;p&gt;Here are the times that we’ve scheduled for folks to pose questions.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;PST US&lt;/th&gt;
&lt;th&gt;EST US&lt;/th&gt;
&lt;th&gt;UTC Europe/Africa&lt;/th&gt;
&lt;th&gt;India&lt;/th&gt;
&lt;th&gt;China&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Dec 7th (&lt;a href&#x3D;&quot;https://everytimezone.com/s/213ef6bd&quot;&gt;View in my timezone&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;3-6pm&lt;/td&gt;
&lt;td&gt;6-9pm&lt;/td&gt;
&lt;td&gt;23:00-2:00&lt;/td&gt;
&lt;td&gt;4:30am-7:30am (Dec 8)&lt;/td&gt;
&lt;td&gt;7am-10am (Dec 8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dec 9th (&lt;a href&#x3D;&quot;https://everytimezone.com/s/f10ec849&quot;&gt;View in my timezone&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;4-7am&lt;/td&gt;
&lt;td&gt;7-10am&lt;/td&gt;
&lt;td&gt;12:00-15:00&lt;/td&gt;
&lt;td&gt;5:30-8:30pm&lt;/td&gt;
&lt;td&gt;8pm-11pm&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dec 11th (&lt;a href&#x3D;&quot;https://everytimezone.com/s/3c5c1b75&quot;&gt;View in my timezone&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;10-1pm&lt;/td&gt;
&lt;td&gt;1-4pm&lt;/td&gt;
&lt;td&gt;18:00-21:00&lt;/td&gt;
&lt;td&gt;11:30pm-2:30am&lt;/td&gt;
&lt;td&gt;2am-5am (Dec 12)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#live-broadcasts&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;live-broadcasts&quot;&gt;&lt;/a&gt;Live broadcasts&lt;/h2&gt;
&lt;p&gt;In addition to the repository, we’ve scheduled two “live broadcasts”. These sessions will feature members of the core team discussing and responding to some of the questions that have been asked thus far. Naturally, even if you can’t catch the live broadcast, the video will be available for streaming afterwards. Here is the schedule for these broadcasts:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;PST US&lt;/th&gt;
&lt;th&gt;EST US&lt;/th&gt;
&lt;th&gt;UTC Europe/Africa&lt;/th&gt;
&lt;th&gt;India&lt;/th&gt;
&lt;th&gt;China&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Dec 9th (&lt;a href&#x3D;&quot;https://everytimezone.com/s/a0b6bb44&quot;&gt;View in my timezone&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://www.youtube.com/watch?v&#x3D;OmEcRWyT6Ak&quot;&gt;Watch on YouTube&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;3-4pm&lt;/td&gt;
&lt;td&gt;6-7pm&lt;/td&gt;
&lt;td&gt;23:00-24:00&lt;/td&gt;
&lt;td&gt;4:30-5:30am   (Dec 10)&lt;/td&gt;
&lt;td&gt;7-8am   (Dec 10)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Dec 12th (&lt;a href&#x3D;&quot;https://everytimezone.com/s/8e88716f&quot;&gt;View in my timezone&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;&lt;a href&#x3D;&quot;https://www.youtube.com/watch?v&#x3D;42ZWHYWv9Ic&quot;&gt;Watch on YouTube&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;4-5am&lt;/td&gt;
&lt;td&gt;7-8am&lt;/td&gt;
&lt;td&gt;12:00-13:00&lt;/td&gt;
&lt;td&gt;5:30pm-6:30pm&lt;/td&gt;
&lt;td&gt;8-9pm&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;These will be hosted on our &lt;a href&#x3D;&quot;https://www.youtube.com/c/rustvideos&quot;&gt;YouTube channel&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We’re very excited about the progress on the Rust foundation and we’re looking forward to hearing from all of you.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
</feed>

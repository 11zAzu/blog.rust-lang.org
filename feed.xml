<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Teams.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2022-10-27T15:41:09+00:00</updated>

    
    <entry>
        <title>Announcing Rust 1.64.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html" type="text/html" title="Announcing Rust 1.64.0" />
        <published>2022-09-22T00:00:00+00:00</published>
        <updated>2022-09-22T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/09/22/Rust-1.64.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.64.0. Rust is a
programming language empowering everyone to build reliable and efficient
software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.64.0
with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get
&lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt; from the appropriate page on
our website, and check out the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22&quot;&gt;detailed release notes for
1.64.0&lt;/a&gt;
on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider
updating locally to use the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly
channel (&lt;code&gt;rustup default nightly&lt;/code&gt;). Please
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you
might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1640-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1640-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.64.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#enhancing-await-with-intofuture&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;enhancing-await-with-intofuture&quot;&gt;&lt;/a&gt;Enhancing &lt;code&gt;.await&lt;/code&gt; with &lt;code&gt;IntoFuture&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Rust 1.64 stabilizes the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/future/trait.IntoFuture.html&quot;&gt;&lt;code&gt;IntoFuture&lt;/code&gt;&lt;/a&gt;
trait. &lt;code&gt;IntoFuture&lt;/code&gt; is a trait similar to
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/iter/trait.IntoIterator.html&quot;&gt;&lt;code&gt;IntoIterator&lt;/code&gt;&lt;/a&gt;,
but rather than supporting &lt;code&gt;for ... in ...&lt;/code&gt; loops, &lt;code&gt;IntoFuture&lt;/code&gt; changes how
&lt;code&gt;.await&lt;/code&gt; works. With &lt;code&gt;IntoFuture&lt;/code&gt;, the &lt;code&gt;.await&lt;/code&gt; keyword can await more than
just futures; it can await &lt;em&gt;anything which can be converted into a &lt;code&gt;Future&lt;/code&gt; via
&lt;code&gt;IntoFuture&lt;/code&gt;&lt;/em&gt; - which can help make your APIs more user-friendly!&lt;/p&gt;
&lt;p&gt;Take for example a builder which constructs requests to some storage provider
over the network:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub struct Error { ... }
pub struct StorageResponse { ... }:
pub struct StorageRequest(bool);

impl StorageRequest {
    /// Create a new instance of &#x60;StorageRequest&#x60;.
    pub fn new() -&amp;gt; Self { ... }
    /// Decide whether debug mode should be enabled.
    pub fn set_debug(self, b: bool) -&amp;gt; Self { ... }
    /// Send the request and receive a response.
    pub async fn send(self) -&amp;gt; Result&amp;lt;StorageResponse, Error&amp;gt; { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typical usage would likely look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let response &#x3D; StorageRequest::new()  // 1. create a new instance
    .set_debug(true)                  // 2. set some option
    .send()                           // 3. construct the future
    .await?;                          // 4. run the future + propagate errors
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is not bad, but we can do better here. Using &lt;code&gt;IntoFuture&lt;/code&gt; we can combine
&lt;em&gt;&amp;quot;construct the future&amp;quot;&lt;/em&gt; (line 3) and &lt;em&gt;&amp;quot;run the future&amp;quot;&lt;/em&gt; (line 4) into a single
step:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let response &#x3D; StorageRequest::new()  // 1. create a new instance
    .set_debug(true)                  // 2. set some option
    .await?;                          // 3. construct + run the future + propagate errors
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can do this by implementing &lt;code&gt;IntoFuture&lt;/code&gt; for &lt;code&gt;StorageRequest&lt;/code&gt;. &lt;code&gt;IntoFuture&lt;/code&gt;
requires us to have a named future we can return, which we can do by creating a
&amp;quot;boxed future&amp;quot; and defining a type alias for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;// First we must import some new types into the scope.
use std::pin::Pin;
use std::future::{Future, IntoFuture};

pub struct Error { ... }
pub struct StorageResponse { ... }
pub struct StorageRequest(bool);

impl StorageRequest {
    /// Create a new instance of &#x60;StorageRequest&#x60;.
    pub fn new() -&amp;gt; Self { ... }
    /// Decide whether debug mode should be enabled.
    pub fn set_debug(self, b: bool) -&amp;gt; Self { ... }
    /// Send the request and receive a response.
    pub async fn send(self) -&amp;gt; Result&amp;lt;StorageResponse, Error&amp;gt; { ... }
}

// The new implementations:
// 1. create a new named future type
// 2. implement &#x60;IntoFuture&#x60; for &#x60;StorageRequest&#x60;
pub type StorageRequestFuture &#x3D; Pin&amp;lt;Box&amp;lt;dyn Future&amp;lt;Output &#x3D; Result&amp;lt;StorageResponse, Error&amp;gt;&amp;gt; + Send + &#x27;static&amp;gt;&amp;gt;
impl IntoFuture for StorageRequest {
    type IntoFuture &#x3D; StorageRequestFuture;
    type Output &#x3D; &amp;lt;StorageRequestFuture as Future&amp;gt;::Output;
    fn into_future(self) -&amp;gt; Self::IntoFuture {
        Box::pin(self.send())
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This takes a bit more code to implement, but provides a simpler API for users.&lt;/p&gt;
&lt;p&gt;In the future, the Rust Async WG hopes to simplify the creating new named
futures by supporting &lt;a href&#x3D;&quot;https://rust-lang.github.io/impl-trait-initiative/explainer/tait.html&quot;&gt;&lt;code&gt;impl Trait&lt;/code&gt; in &lt;code&gt;type&lt;/code&gt; aliases (Type Alias Impl Trait or
TAIT)&lt;/a&gt;.
This should make implementing &lt;code&gt;IntoFuture&lt;/code&gt; easier by simplifying the type
alias&#x27; signature, and make it more performant by removing the &lt;code&gt;Box&lt;/code&gt; from the
type alias.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#c-compatible-ffi-types-in-core-and-alloc&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;c-compatible-ffi-types-in-core-and-alloc&quot;&gt;&lt;/a&gt;C-compatible FFI types in core and alloc&lt;/h3&gt;
&lt;p&gt;When calling or being called by C ABIs, Rust code can use type aliases like
&lt;code&gt;c_uint&lt;/code&gt; or &lt;code&gt;c_ulong&lt;/code&gt; to match the corresponding types from C on any target,
without requiring target-specific code or conditionals.&lt;/p&gt;
&lt;p&gt;Previously, these type aliases were only available in &lt;code&gt;std&lt;/code&gt;, so code written
for embedded targets and other scenarios that could only use &lt;code&gt;core&lt;/code&gt; or &lt;code&gt;alloc&lt;/code&gt;
could not use these types.&lt;/p&gt;
&lt;p&gt;Rust 1.64 now provides all of the &lt;code&gt;c_*&lt;/code&gt; type aliases in
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/ffi/index.html&quot;&gt;&lt;code&gt;core::ffi&lt;/code&gt;&lt;/a&gt;, as well as
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/core/ffi/struct.CStr.html&quot;&gt;&lt;code&gt;core::ffi::CStr&lt;/code&gt;&lt;/a&gt; for
working with C strings. Rust 1.64 also provides
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/alloc/ffi/struct.CString.html&quot;&gt;&lt;code&gt;alloc::ffi::CString&lt;/code&gt;&lt;/a&gt;
for working with owned C strings using only the &lt;code&gt;alloc&lt;/code&gt; crate, rather than the
full &lt;code&gt;std&lt;/code&gt; library.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#rust-analyzer-is-now-available-via-rustup&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-analyzer-is-now-available-via-rustup&quot;&gt;&lt;/a&gt;rust-analyzer is now available via rustup&lt;/h3&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://rust-analyzer.github.io/&quot;&gt;rust-analyzer&lt;/a&gt; is now included as part of
the collection of tools included with Rust. This makes it easier to download
and access rust-analyzer, and makes it available on more platforms. It is
available as a &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/concepts/components.html&quot;&gt;rustup
component&lt;/a&gt; which
can be installed with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup component add rust-analyzer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this time, to run the rustup-installed version, you need to invoke it this
way:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup run stable rust-analyzer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next release of rustup will provide a built-in proxy so that running the
executable &lt;code&gt;rust-analyzer&lt;/code&gt; will launch the appropriate version.&lt;/p&gt;
&lt;p&gt;Most users should continue to use the releases provided by the rust-analyzer
team (available on the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-analyzer/releases&quot;&gt;rust-analyzer releases
page&lt;/a&gt;), which are
published more frequently. Users of the &lt;a href&#x3D;&quot;https://marketplace.visualstudio.com/items?itemName&#x3D;rust-lang.rust-analyzer&quot;&gt;official VSCode
extension&lt;/a&gt;
are not affected since it automatically downloads and updates releases in the
background.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#cargo-improvements-workspace-inheritance-and-multi-target-builds&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;cargo-improvements-workspace-inheritance-and-multi-target-builds&quot;&gt;&lt;/a&gt;Cargo improvements: workspace inheritance and multi-target builds&lt;/h3&gt;
&lt;p&gt;When working with collections of related libraries or binary crates in one
Cargo workspace, you can now avoid duplication of common field values between
crates, such as common version numbers, repository URLs, or &lt;code&gt;rust-version&lt;/code&gt;.
This also helps keep these values in sync between crates when updating them.
For more details, see
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-package-table&quot;&gt;&lt;code&gt;workspace.package&lt;/code&gt;&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/workspaces.html#the-dependencies-table&quot;&gt;&lt;code&gt;workspace.dependencies&lt;/code&gt;&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace&quot;&gt;&amp;quot;inheriting a dependency from a
workspace&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;When building for multiple targets, you can now pass multiple &lt;code&gt;--target&lt;/code&gt;
options to &lt;code&gt;cargo build&lt;/code&gt;, to build all of those targets at once. You can also
set
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/config.html#buildtarget&quot;&gt;&lt;code&gt;build.target&lt;/code&gt;&lt;/a&gt;
to an array of multiple targets in &lt;code&gt;.cargo/config.toml&lt;/code&gt; to build for multiple
targets by default.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/future/trait.IntoFuture.html&quot;&gt;&lt;code&gt;future::IntoFuture&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_mul&quot;&gt;&lt;code&gt;num::NonZero*::checked_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_pow&quot;&gt;&lt;code&gt;num::NonZero*::checked_pow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_mul&quot;&gt;&lt;code&gt;num::NonZero*::saturating_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_pow&quot;&gt;&lt;code&gt;num::NonZero*::saturating_pow&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.abs&quot;&gt;&lt;code&gt;num::NonZeroI*::abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.checked_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::checked_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.overflowing_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::overflowing_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.saturating_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::saturating_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.unsigned_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::unsigned_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroIsize.html#method.wrapping_abs&quot;&gt;&lt;code&gt;num::NonZeroI*::wrapping_abs&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_add&quot;&gt;&lt;code&gt;num::NonZeroU*::checked_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.checked_next_power_of_two&quot;&gt;&lt;code&gt;num::NonZeroU*::checked_next_power_of_two&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroUsize.html#method.saturating_add&quot;&gt;&lt;code&gt;num::NonZeroU*::saturating_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/process/trait.CommandExt.html#tymethod.process_group&quot;&gt;&lt;code&gt;os::unix::process::CommandExt::process_group&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_dir&quot;&gt;&lt;code&gt;os::windows::fs::FileTypeExt::is_symlink_dir&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/fs/trait.FileTypeExt.html#tymethod.is_symlink_file&quot;&gt;&lt;code&gt;os::windows::fs::FileTypeExt::is_symlink_file&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These types were previously stable in &lt;code&gt;std::ffi&lt;/code&gt;, but are now also available in
&lt;code&gt;core&lt;/code&gt; and &lt;code&gt;alloc&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/ffi/struct.CStr.html&quot;&gt;&lt;code&gt;core::ffi::CStr&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/ffi/struct.FromBytesWithNulError.html&quot;&gt;&lt;code&gt;core::ffi::FromBytesWithNulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.CString.html&quot;&gt;&lt;code&gt;alloc::ffi::CString&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.FromVecWithNulError.html&quot;&gt;&lt;code&gt;alloc::ffi::FromVecWithNulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.IntoStringError.html&quot;&gt;&lt;code&gt;alloc::ffi::IntoStringError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/ffi/struct.NulError.html&quot;&gt;&lt;code&gt;alloc::ffi::NulError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These types were previously stable in &lt;code&gt;std::os::raw&lt;/code&gt;, but are now also
available in &lt;code&gt;core::ffi&lt;/code&gt; and &lt;code&gt;std::ffi&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_char.html&quot;&gt;&lt;code&gt;ffi::c_char&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_double.html&quot;&gt;&lt;code&gt;ffi::c_double&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_float.html&quot;&gt;&lt;code&gt;ffi::c_float&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_int.html&quot;&gt;&lt;code&gt;ffi::c_int&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_long.html&quot;&gt;&lt;code&gt;ffi::c_long&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_longlong.html&quot;&gt;&lt;code&gt;ffi::c_longlong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_schar.html&quot;&gt;&lt;code&gt;ffi::c_schar&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_short.html&quot;&gt;&lt;code&gt;ffi::c_short&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_uchar.html&quot;&gt;&lt;code&gt;ffi::c_uchar&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_uint.html&quot;&gt;&lt;code&gt;ffi::c_uint&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ulong.html&quot;&gt;&lt;code&gt;ffi::c_ulong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ulonglong.html&quot;&gt;&lt;code&gt;ffi::c_ulonglong&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/type.c_ushort.html&quot;&gt;&lt;code&gt;ffi::c_ushort&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We&#x27;ve stabilized some helpers for use with &lt;code&gt;Poll&lt;/code&gt;, the low-level implementation
underneath futures:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/future/fn.poll_fn.html&quot;&gt;&lt;code&gt;future::poll_fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/task/macro.ready.html&quot;&gt;&lt;code&gt;task::ready!&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future, we hope to provide simpler APIs that require less use of
low-level details like &lt;code&gt;Poll&lt;/code&gt; and &lt;code&gt;Pin&lt;/code&gt;, but in the meantime, these helpers
make it easier to write such code.&lt;/p&gt;
&lt;p&gt;These APIs are now usable in const contexts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/core/slice/fn.from_raw_parts.html&quot;&gt;&lt;code&gt;slice::from_raw_parts&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#compatibility-notes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;compatibility-notes&quot;&gt;&lt;/a&gt;Compatibility notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;As &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/08/01/Increasing-glibc-kernel-requirements.html&quot;&gt;previously
announced&lt;/a&gt;,
&lt;code&gt;linux&lt;/code&gt; targets now require at least Linux kernel 3.2 (except for targets which
already required a newer kernel), and &lt;code&gt;linux-gnu&lt;/code&gt; targets now require glibc
2.17 (except for targets which already required a newer glibc).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rust 1.64.0 changes the memory layout of &lt;code&gt;Ipv4Addr&lt;/code&gt;, &lt;code&gt;Ipv6Addr&lt;/code&gt;,
&lt;code&gt;SocketAddrV4&lt;/code&gt; and &lt;code&gt;SocketAddrV6&lt;/code&gt; to be more compact and memory efficient.
This internal representation was never exposed, but some crates relied on
it anyway by using &lt;code&gt;std::mem::transmute&lt;/code&gt;, resulting in invalid memory
accesses. Such internal implementation details of the standard library are
&lt;em&gt;never&lt;/em&gt; considered a stable interface. To limit the damage, we worked with
the authors of all of the still-maintained crates doing so to release fixed
versions, which have been out for more than a year. The vast majority of
impacted users should be able to mitigate with a &lt;code&gt;cargo update&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;As part of the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/07/01/RLS-deprecation.html&quot;&gt;RLS
deprecation&lt;/a&gt;,
this is also the last release containing a copy of RLS. Starting from Rust
1.65.0, RLS will be replaced by a small LSP server showing the deprecation
warning.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.64 release, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Windows builds of the Rust compiler now use profile-guided optimization,
providing performance improvements of 10-20% for compiling Rust code on
Windows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you define a struct containing fields that are never used, rustc will warn
about the unused fields. Now, in Rust 1.64, you can enable the
&lt;code&gt;unused_tuple_struct_fields&lt;/code&gt; lint to get the same warnings about unused
fields in a tuple struct. In future versions, we plan to make this lint
warn by default.  Fields of type unit (&lt;code&gt;()&lt;/code&gt;) do not produce this warning,
to make it easier to migrate existing code without having to change tuple
indices.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check out everything that changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1640-2022-09-22&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-164-2022-09-22&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-164&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1640&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1640&quot;&gt;&lt;/a&gt;Contributors to 1.64.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.64.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.64.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Const Eval (Un)Safety Rules</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html" type="text/html" title="Const Eval (Un)Safety Rules" />
        <published>2022-09-15T00:00:00+00:00</published>
        <updated>2022-09-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/09/15/const-eval-safety-rule-revision.html">&lt;p&gt;In a recent Rust issue (&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt;), a developer noted that the upcoming
1.64-beta version of Rust had started signalling errors on their crate,
&lt;a href&#x3D;&quot;https://github.com/unicode-org/icu4x&quot;&gt;&lt;code&gt;icu4x&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;icu4x&lt;/code&gt; crate uses unsafe code during const evaluation.
&lt;em&gt;Const evaluation&lt;/em&gt;, or just &amp;quot;const-eval&amp;quot;,
runs at compile-time but produces values that may end up embedded in the
final object code that executes at runtime.&lt;/p&gt;
&lt;p&gt;Rust&#x27;s const-eval system supports both safe and unsafe Rust, but the rules for
what unsafe code is allowed to do during const-eval are even more strict than
what is allowed for unsafe code at runtime. This post is going to go into detail
about one of those rules.&lt;/p&gt;
&lt;p&gt;(Note: If your &lt;code&gt;const&lt;/code&gt; code does not use any &lt;code&gt;unsafe&lt;/code&gt; blocks or call any &lt;code&gt;const fn&lt;/code&gt;
with an &lt;code&gt;unsafe&lt;/code&gt; block, then you do not need to worry about this!)&lt;/p&gt;
&lt;!--

(This is distinct from procedural macros, which are Rust code that runs at
compile-time to manipulate *program syntax*; syntactic values are not usually
embedded into the final object code.)

--&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#a-new-diagnostic-to-watch-for&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;a-new-diagnostic-to-watch-for&quot;&gt;&lt;/a&gt;A new diagnostic to watch for&lt;/h2&gt;
&lt;p&gt;The problem, reduced over the course of the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923#issuecomment-1200284482&quot;&gt;comment thread of #99923&lt;/a&gt;, is that certain static initialization expressions (see below) are
defined as having undefined behavior (UB) &lt;em&gt;at compile time&lt;/em&gt; (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;beta&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;67a917fc4f2a4bf2eb72aebf8dad0fe9&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: () &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    let _copy &#x3D; illegal_ptr2int;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Many thanks to &lt;code&gt;@eddyb&lt;/code&gt; for the minimal reproduction!)&lt;/p&gt;
&lt;p&gt;The code above was accepted by Rust versions 1.63 and earlier, but in the Rust
1.64-beta, it now causes a compile time error with the following message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0080]: could not evaluate static initializer
 --&amp;gt; demo.rs:3:17
  |
3 |     let _copy &#x3D; illegal_ptr2int;
  |                 ^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes
  |
  &#x3D; help: this code performed an operation that depends on the underlying bytes representing a pointer
  &#x3D; help: the absolute address of a pointer is not known at compile-time, so such operations are not supported
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the message says, this operation is not supported: the &lt;code&gt;transmute&lt;/code&gt;
above is trying to reinterpret the memory address &lt;code&gt;&amp;amp;()&lt;/code&gt; as an integer of type
&lt;code&gt;usize&lt;/code&gt;. The compiler cannot predict what memory address the &lt;code&gt;()&lt;/code&gt; would be
associated with at execution time, so it refuses to allow that reinterpretation.&lt;/p&gt;
&lt;p&gt;When you write safe Rust, then the compiler is responsible for preventing
undefined behavior. When you write any unsafe code (be it const or non-const),
you are responsible for preventing UB, and during const-eval, the rules about
what unsafe code has defined behavior are even more strict than the analogous
rules governing Rust&#x27;s runtime semantics. (In other words, &lt;em&gt;more&lt;/em&gt; code is
classified as &amp;quot;UB&amp;quot; than you may have otherwise realized.)&lt;/p&gt;
&lt;p&gt;If you hit undefined behavior during const-eval, the Rust compiler will protect
itself from &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/3016-const-ub.md#guide-level-explanation&quot;&gt;adverse effects&lt;/a&gt; such as the undefined
behavior leaking into the type system, but there are few guarantees
other than that. For example, compile-time UB could lead to runtime UB.
Furthermore, if you have UB at const-eval time, there is no guarantee that your
code will be accepted from one compiler version to another.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-new-here&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-new-here&quot;&gt;&lt;/a&gt;What is new here&lt;/h2&gt;
&lt;p&gt;You might be thinking: &amp;quot;it &lt;em&gt;used to be&lt;/em&gt; accepted; therefore, there must be some
value for the memory address that the previous version of the compiler was using
here.&amp;quot;&lt;/p&gt;
&lt;p&gt;But such reasoning would be based on an imprecise view of what the Rust compiler
was doing here.&lt;/p&gt;
&lt;p&gt;The const-eval machinery of the Rust compiler  (also known as &amp;quot;the &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/const-eval.html&quot;&gt;CTFE&lt;/a&gt; engine&amp;quot;)
is built upon a &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/mir/index.html&quot;&gt;MIR&lt;/a&gt; interpreter which uses an &lt;em&gt;abstract model&lt;/em&gt; of a hypothetical machine as the
foundation for evaluating such expressions. This abstract model doesn&#x27;t have to
represent memory addresses as mere integers; in fact, to support
fine-grained checking for UB, it uses a much richer datatype for
the values that are held in the abstract memory store.&lt;/p&gt;
&lt;p&gt;(The aforementioned MIR interpreter is also the basis for &lt;a href&#x3D;&quot;https://github.com/rust-lang/miri#readme&quot;&gt;Miri&lt;/a&gt;, a research
tool that interprets &lt;em&gt;non-const&lt;/em&gt; Rust code, with a focus on
explicit detection of undefined behavior. The Miri developers are the primary
contributors to the CTFE engine in the Rust compiler.)&lt;/p&gt;
&lt;p&gt;The details of the CTFE engine&#x27;s value representation do not matter too much for our
discussion here. We merely note that earlier versions of the compiler silently
accepted expressions that &lt;em&gt;seemed to&lt;/em&gt; transmute memory addresses into integers,
copied them around, and then transmuted them back into addresses; but that was
not what was acutally happening under the hood. Instead, what was happening was
that the values were passed around blindly (after all, the whole point of
transmute is that it does no transformation on its input value, so it is a no-op
in terms of its operational semantics).&lt;/p&gt;
&lt;p&gt;The fact that it was passing a memory address into a context where you would
expect there to always be an integer value would only be caught, if at all, at
some later point.&lt;/p&gt;
&lt;p&gt;For example, the const-eval machinery rejects code that attempts to embed the
transmuted pointer into a value that could be used by runtime code, like so (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;48456e8bd028c6aa5c80a1962d7e4fb8&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: usize &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    illegal_ptr2int
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Likewise, it rejects code that attempts to &lt;em&gt;perform arithmetic&lt;/em&gt; on that
non-integer value, like so (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;74a35dd6ff93c86bd38c1a0006f2fc41&quot;&gt;playground&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;pub static FOO: () &#x3D; unsafe {
    let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
    let _incremented &#x3D; illegal_ptr2int + 1;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both of the latter two variants are rejected in stable Rust, and have been for
as long as Rust has accepted pointer-to-integer conversions in static
initializers (see e.g. Rust 1.52).&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#more-similar-than-different&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;more-similar-than-different&quot;&gt;&lt;/a&gt;More similar than different&lt;/h2&gt;
&lt;p&gt;In fact, &lt;em&gt;all&lt;/em&gt; of the examples provided above are exhibiting &lt;em&gt;undefined
behavior&lt;/em&gt; according to the semantics of Rust&#x27;s const-eval system.&lt;/p&gt;
&lt;p&gt;The first example with &lt;code&gt;_copy&lt;/code&gt; was accepted in Rust versions 1.46 through 1.63
because of CTFE implementation artifacts. The CTFE engine puts considerable effort into
detecting UB, but does not catch all instances of it. Furthermore, by default,
such detection can be delayed to a point far after where the actual
problematic expression is found.&lt;/p&gt;
&lt;p&gt;But with nightly Rust, we can opt into extra checks for UB that the engine provides,
by passing the unstable flag &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt;. If we do that, then for
&lt;em&gt;all&lt;/em&gt; of the above examples we get the same result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error[E0080]: could not evaluate static initializer
 --&amp;gt; demo.rs:2:34
  |
2 |     let illegal_ptr2int: usize &#x3D; std::mem::transmute(&amp;amp;());
  |                                  ^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes
  |
  &#x3D; help: this code performed an operation that depends on the underlying bytes representing a pointer
  &#x3D; help: the absolute address of a pointer is not known at compile-time, so such operations are not supported
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The earlier examples had diagnostic output that put the blame in a misleading
place. With the more precise checking &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt; enabled, the
compiler highlights the expression where we can first witness UB: the original
transmute itself! (Which was stated at the outset of this post; here we are just
pointing out that these tools can pinpoint the injection point more precisely.)&lt;/p&gt;
&lt;p&gt;Why not have these extra const-ub checks on by default? Well, the checks
introduce performance overhead upon Rust compilation time, and we do not know if
that overhead can be made acceptable. (However, &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bsteering.20meeting.5D.202022-09-02.20const-eval.20and.20future-compa.2E.2E.2E/near/296853344&quot;&gt;recent debate&lt;/a&gt;
among Miri developers indicates that the inherent cost here might not be as bad
as they had originally thought. Perhaps a future version of the compiler will
have these extra checks on by default.)&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#change-is-hard&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;change-is-hard&quot;&gt;&lt;/a&gt;Change is hard&lt;/h2&gt;
&lt;p&gt;You might well be wondering at this point: &amp;quot;Wait, when &lt;em&gt;is&lt;/em&gt; it okay to transmute
a pointer to a &lt;code&gt;usize&lt;/code&gt; during const evaluation?&amp;quot; And the answer is simple:
&amp;quot;Never.&amp;quot;&lt;/p&gt;
&lt;p&gt;Transmuting a pointer to a usize during const-eval has always been undefined behavior,
ever since const-eval added support for
&lt;code&gt;transmute&lt;/code&gt; and &lt;code&gt;union&lt;/code&gt;. You can read more about this in the
&lt;code&gt;const_fn_transmute&lt;/code&gt; / &lt;code&gt;const_fn_union&lt;/code&gt; &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/85769#issuecomment-854363720&quot;&gt;stabilization report&lt;/a&gt;,
specifically the subsection entitled &amp;quot;Pointer-integer-transmutes&amp;quot;.
(It is also mentioned in the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/mem/fn.transmute.html&quot;&gt;documentation&lt;/a&gt; for &lt;code&gt;transmute&lt;/code&gt;&lt;!--,
though with less discussion than what you see in the stabilization report --&gt;.)&lt;/p&gt;
&lt;p&gt;Thus, we can see that the classification of the above examples as UB during const evaluation
is not a new thing at all. The only change here was that the CTFE engine had some internal
changes that made it start detecting the UB rather than silently ignoring it.&lt;/p&gt;
&lt;p&gt;This means the Rust compiler has a shifting notion of what UB it will
explicitly catch. We anticipated this: RFC 3016, &amp;quot;const UB&amp;quot;, explicitly
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/3016-const-ub.md#guide-level-explanation&quot;&gt;says&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] there is no guarantee that UB is reliably detected during CTFE. This can
change from compiler version to compiler version: CTFE code that causes UB
could build fine with one compiler and fail to build with another. (This is in
accordance with the general policy that unsound code is not subject to
stability guarantees.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Having said that: So much of Rust&#x27;s success has been built around the trust that
we have earned with our community. Yes, the project has always reserved the
right to make breaking changes when resolving soundness bugs; but we have also
strived to mitigate such breakage &lt;em&gt;whenever feasible&lt;/em&gt;, via things like
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/rustc/lints/index.html#future-incompatible-lints&quot;&gt;future-incompatible lints&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Today, with our current const-eval architecture, it is not
feasible to ensure that changes such as the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/97684&quot;&gt;one that injected&lt;/a&gt; issue
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt; go through a future-incompat warning cycle.
The compiler team plans to keep our eye on issues in this space. If we see
evidence that these kinds of changes do cause breakage to a non-trivial number
of crates, then we will investigate further how we might smooth the transition
path between compiler releases. However, we need to balance any such goal
against the fact that Miri has very a limited set of developers: the researchers
determining how to define the semantics of unsafe languages like Rust. We do not
want to slow their work down!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-you-can-do-for-safetys-sake&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-you-can-do-for-safetys-sake&quot;&gt;&lt;/a&gt;What you can do for safety&#x27;s sake&lt;/h2&gt;
&lt;p&gt;If you observe the &lt;code&gt;could not evaluate static initializer&lt;/code&gt; message on your crate
atop Rust 1.64, and it was compiling with previous versions of Rust, we want you
to let us know: &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;file an issue&lt;/a&gt;!&lt;/p&gt;
&lt;!--

(Of course we always want to hear about such cases where a crate regresses
between Rust releases; this is just a case that was particularly subtle for us
to tease apart within the project community itself.)

--&gt;
&lt;p&gt;We have &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/100327#issuecomment-1214457275&quot;&gt;performed&lt;/a&gt; a &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/tests/crater.html&quot;&gt;crater run&lt;/a&gt; for the 1.64-beta and that did not find any other
instances of this particular problem.
If you can test compiling your crate atop the 1.64-beta before the stable
release goes out on September 22nd, all the better! One easy way to try the beta
is to use &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/overrides.html#toolchain-override-shorthand&quot;&gt;rustup&#x27;s override shortand&lt;/a&gt; for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-shell&quot;&gt;$ rustup update beta
$ cargo +beta build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As Rust&#x27;s const-eval evolves, we may see another case like this arise again. If
you want to defend against future instances of const-eval UB, we recommend that
you set up a continuous integration service to invoke the nightly &lt;code&gt;rustc&lt;/code&gt; with
the unstable &lt;code&gt;-Z extra-const-ub-checks&lt;/code&gt; flag on your code.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#want-to-help&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;want-to-help&quot;&gt;&lt;/a&gt;Want to help?&lt;/h2&gt;
&lt;p&gt;As you might imagine, a lot of us are pretty interested in questions such as
&amp;quot;what should be undefined behavior?&amp;quot;&lt;/p&gt;
&lt;p&gt;See for example Ralf Jung&#x27;s excellent blog series on why pointers are
complicated (parts &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html&quot;&gt;I&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2020/12/14/provenance.html&quot;&gt;II&lt;/a&gt;, &lt;a href&#x3D;&quot;https://www.ralfj.de/blog/2022/04/11/provenance-exposed.html&quot;&gt;III&lt;/a&gt;), which contain some of
the details elided above about the representation of pointer values, and spell out reasons why
you might want to be concerned about pointer-to-usize transmutes even &lt;em&gt;outside&lt;/em&gt;
of const-eval.&lt;/p&gt;
&lt;p&gt;If you are interested in trying to help us figure out answers to those kinds of
questions, please join us in the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines&quot;&gt;unsafe code guidelines zulip&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are interested in learning more about Miri, or contributing to it, you
can say Hello in the &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/#narrow/stream/269128-miri&quot;&gt;miri zulip&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#conclusion&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;To sum it all up: When you write safe Rust, then the compiler is responsible for
preventing undefined behavior. When you write any unsafe code, &lt;em&gt;you&lt;/em&gt; are
responsible for preventing undefined behavior. Rust&#x27;s const-eval system has a
stricter set of rules governing what unsafe code has defined behavior:
specifically, reinterpreting (aka &amp;quot;transmuting&amp;quot;) a pointer value as a &lt;code&gt;usize&lt;/code&gt; is
undefined behavior during const-eval. If you have undefined behavior at
const-eval time, there is no guarantee that your code will be accepted from one
compiler version to another.&lt;/p&gt;
&lt;p&gt;The compiler team is hoping that issue &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/99923&quot;&gt;#99923&lt;/a&gt; is an exceptional fluke and
that the 1.64 stable release will not encounter any other surprises related to
the aforementioned change to the const-eval machinery.&lt;/p&gt;
&lt;p&gt;But fluke or not, the issue provided excellent motivation to spend some time
exploring facets of Rust&#x27;s const-eval architecture and the interpreter
that underlies it.
We hope you enjoyed reading this as much as we did writing it.&lt;/p&gt;
</content>

        <author>
            <name>Felix Klock</name>
        </author>
    </entry>
    
    <entry>
        <title>Security advisories for Cargo (CVE-2022-36113, CVE-2022-36114)</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/09/14/cargo-cves.html" type="text/html" title="Security advisories for Cargo (CVE-2022-36113, CVE-2022-36114)" />
        <published>2022-09-14T00:00:00+00:00</published>
        <updated>2022-09-14T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/09/14/cargo-cves.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/09/14/cargo-cves.html">&lt;blockquote&gt;
&lt;p&gt;This is a cross-post of &lt;a href&#x3D;&quot;https://groups.google.com/g/rustlang-security-announcements/c/ldvsemwk_VY&quot;&gt;the official security advisory&lt;/a&gt;. The
official advisory contains a signed version with our PGP key, as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Rust Security Response WG was notified that Cargo did not prevent
extracting some malformed packages downloaded from alternate registries. An
attacker able to upload packages to an alternate registry could fill the
filesystem or corrupt arbitary files when Cargo downloaded the package.&lt;/p&gt;
&lt;p&gt;These issues have been assigned CVE-2022-36113 and CVE-2022-36114. The severity
of these vulnerabilities is &amp;quot;low&amp;quot; for users of alternate registries. Users
relying on crates.io are not affected.&lt;/p&gt;
&lt;p&gt;Note that &lt;strong&gt;by design&lt;/strong&gt; Cargo allows code execution at build time, due to build
scripts and procedural macros. The vulnerabilities in this advisory allow
performing a subset of the possible damage in a harder to track down way. Your
dependencies must still be trusted if you want to be protected from attacks, as
it&#x27;s possible to perform the same attacks with build scripts and procedural
macros.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#arbitrary-file-corruption-cve-2022-36113&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;arbitrary-file-corruption-cve-2022-36113&quot;&gt;&lt;/a&gt;Arbitrary file corruption (CVE-2022-36113)&lt;/h2&gt;
&lt;p&gt;After a package is downloaded, Cargo extracts its source code in the &lt;code&gt;~/.cargo&lt;/code&gt;
folder on disk, making it available to the Rust projects it builds. To record
when an extraction is successfull, Cargo writes &amp;quot;ok&amp;quot; to the &lt;code&gt;.cargo-ok&lt;/code&gt; file at
the root of the extracted source code once it extracted all the files.&lt;/p&gt;
&lt;p&gt;It was discovered that Cargo allowed packages to contain a &lt;code&gt;.cargo-ok&lt;/code&gt;
&lt;em&gt;symbolic link&lt;/em&gt;, which Cargo would extract. Then, when Cargo attempted to write
&amp;quot;ok&amp;quot; into &lt;code&gt;.cargo-ok&lt;/code&gt;, it would actually replace the first two bytes of the
file the symlink pointed to with &lt;code&gt;ok&lt;/code&gt;. This would allow an attacker to corrupt
one file on the machine using Cargo to extract the package.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#disk-space-exhaustion-cve-2022-36114&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;disk-space-exhaustion-cve-2022-36114&quot;&gt;&lt;/a&gt;Disk space exhaustion (CVE-2022-36114)&lt;/h2&gt;
&lt;p&gt;It was discovered that Cargo did not limit the amount of data extracted from
compressed archives. An attacker could upload to an alternate registry a
specially crafted package that extracts way more data than its size (also known
as a &amp;quot;zip bomb&amp;quot;), exhausting the disk space on the machine using Cargo to
download the package.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#affected-versions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-versions&quot;&gt;&lt;/a&gt;Affected versions&lt;/h2&gt;
&lt;p&gt;Both vulnerabilities are present in all versions of Cargo. Rust 1.64, to be
released on September 22nd, will include fixes for both of them.&lt;/p&gt;
&lt;p&gt;Since these vulnerabilities are just a more limited way to accomplish what a
malicious build scripts or procedural macros can do, we decided not to publish
Rust point releases backporting the security fix. Patch files for Rust 1.63.0
are available &lt;a href&#x3D;&quot;https://github.com/rust-lang/wg-security-response/tree/master/patches&quot;&gt;in the wg-security-response repository&lt;/a&gt; for people building
their own toolchains.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#mitigations&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;mitigations&quot;&gt;&lt;/a&gt;Mitigations&lt;/h2&gt;
&lt;p&gt;We recommend users of alternate registries to excercise care in which package
they download, by only including trusted dependencies in their projects. Please
note that even with these vulnerabilities fixed, by design Cargo allows
arbitrary code execution at build time thanks to build scripts and procedural
macros: a malicious dependency will be able to cause damage regardless of these
vulnerabilities.&lt;/p&gt;
&lt;p&gt;crates.io implemented server-side checks to reject these kinds of packages
years ago, and there are no packages on crates.io exploiting these
vulnerabilities. crates.io users still need to excercise care in choosing their
dependencies though, as the same concerns about build scripts and procedural
macros apply here.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#acknowledgements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;acknowledgements&quot;&gt;&lt;/a&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;We want to thank Ori Hollander from JFrog Security Research for responsibly
disclosing this to us according to the &lt;a href&#x3D;&quot;https://www.rust-lang.org/policies/security&quot;&gt;Rust security policy&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We also want to thank Josh Triplett for developing the fixes, Weihang Lo for
developing the tests, and Pietro Albini for writing this advisory. The
disclosure was coordinated by Pietro Albini and Josh Stone.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Security Response WG</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.63.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html" type="text/html" title="Announcing Rust 1.63.0" />
        <published>2022-08-11T00:00:00+00:00</published>
        <updated>2022-08-11T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/08/11/Rust-1.63.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.63.0. Rust is a programming language
empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.63.0 with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1630-2022-08-11&quot;&gt;detailed release notes for 1.63.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to help us out by testing future releases, you might consider updating locally to use
the beta channel (&lt;code&gt;rustup default beta&lt;/code&gt;) or the nightly channel (&lt;code&gt;rustup default nightly&lt;/code&gt;).
Please &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/new/choose&quot;&gt;report&lt;/a&gt; any bugs you might come across!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1630-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1630-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.63.0 stable&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#scoped-threads&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;scoped-threads&quot;&gt;&lt;/a&gt;Scoped threads&lt;/h3&gt;
&lt;p&gt;Rust code could launch new threads with &lt;code&gt;std::thread::spawn&lt;/code&gt; since 1.0, but this
function bounds its closure with &lt;code&gt;&#x27;static&lt;/code&gt;. Roughly, this means that threads
currently must have ownership of any arguments passed into their closure; you
can&#x27;t pass borrowed data into a thread. In cases where the threads are expected
to exit by the end of the function (by being &lt;code&gt;join()&lt;/code&gt;&#x27;d), this isn&#x27;t strictly
necessary and can require workarounds like placing the data in an &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Arc.html&quot;&gt;&lt;code&gt;Arc&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now, with 1.63.0, the standard library is adding &lt;em&gt;scoped&lt;/em&gt; threads, which allow
spawning a thread borrowing from the local stack frame. The
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/fn.scope.html&quot;&gt;&lt;code&gt;std::thread::scope&lt;/code&gt;&lt;/a&gt; API provides the necessary guarantee that any spawned threads
will have exited prior to itself returning, which allows for safely borrowing
data. Here&#x27;s an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let mut a &#x3D; vec![1, 2, 3];
let mut x &#x3D; 0;

std::thread::scope(|s| {
    s.spawn(|| {
        println!(&amp;quot;hello from the first scoped thread&amp;quot;);
        // We can borrow &#x60;a&#x60; here.
        dbg!(&amp;amp;a);
    });
    s.spawn(|| {
        println!(&amp;quot;hello from the second scoped thread&amp;quot;);
        // We can even mutably borrow &#x60;x&#x60; here,
        // because no other threads are using it.
        x +&#x3D; a[0] + a[2];
    });
    println!(&amp;quot;hello from the main thread&amp;quot;);
});

// After the scope, we can modify and access our variables again:
a.push(4);
assert_eq!(x, a.len());
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#rust-ownership-for-raw-file-descriptorshandles-io-safety&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-ownership-for-raw-file-descriptorshandles-io-safety&quot;&gt;&lt;/a&gt;Rust ownership for raw file descriptors/handles (I/O Safety)&lt;/h3&gt;
&lt;p&gt;Previously, Rust code working with platform APIs taking raw file descriptors (on
unix-style platforms) or handles (on Windows) would typically work directly with
a platform-specific representation of the descriptor (for example, a &lt;code&gt;c_int&lt;/code&gt;, or the alias &lt;code&gt;RawFd&lt;/code&gt;).
For Rust bindings to such native APIs, the type system then failed to encode
whether the API would take ownership of the file descriptor (e.g., &lt;code&gt;close&lt;/code&gt;) or
merely borrow it (e.g., &lt;code&gt;dup&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Now, Rust provides wrapper types such as &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/struct.BorrowedFd.html&quot;&gt;&lt;code&gt;BorrowedFd&lt;/code&gt;&lt;/a&gt; and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/struct.OwnedFd.html&quot;&gt;&lt;code&gt;OwnedFd&lt;/code&gt;&lt;/a&gt;, which are marked as
&lt;code&gt;#[repr(transparent)]&lt;/code&gt;, meaning that &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; bindings can directly take
these types to encode the ownership semantics. See the stabilized APIs section
for the full list of wrapper types stabilized in 1.63, currently, they are
available on cfg(unix) platforms, Windows, and WASI.&lt;/p&gt;
&lt;p&gt;We recommend that new APIs use these types instead of the previous type aliases
(like &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/type.RawFd.html&quot;&gt;&lt;code&gt;RawFd&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#const-mutex-rwlock-condvar-initialization&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;const-mutex-rwlock-condvar-initialization&quot;&gt;&lt;/a&gt;&lt;code&gt;const&lt;/code&gt; Mutex, RwLock, Condvar initialization&lt;/h3&gt;
&lt;p&gt;The &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.new&quot;&gt;&lt;code&gt;Condvar::new&lt;/code&gt;&lt;/a&gt;, &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#method.new&quot;&gt;&lt;code&gt;Mutex::new&lt;/code&gt;&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html#method.new&quot;&gt;&lt;code&gt;RwLock::new&lt;/code&gt;&lt;/a&gt; functions are now
callable in &lt;code&gt;const&lt;/code&gt; contexts, which allows avoiding the use of crates like
&lt;code&gt;lazy_static&lt;/code&gt; for creating global statics with &lt;code&gt;Mutex&lt;/code&gt;, &lt;code&gt;RwLock&lt;/code&gt;, or &lt;code&gt;Condvar&lt;/code&gt;
values. This builds on the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/06/30/Rust-1.62.0.html#thinner-faster-mutexes-on-linux&quot;&gt;work in 1.62&lt;/a&gt; to enable thinner and faster mutexes
on Linux.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#turbofish-for-generics-in-functions-with-impl-trait&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;turbofish-for-generics-in-functions-with-impl-trait&quot;&gt;&lt;/a&gt;Turbofish for generics in functions with &lt;code&gt;impl Trait&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;For a function signature like &lt;code&gt;fn foo&amp;lt;T&amp;gt;(value: T, f: impl Copy)&lt;/code&gt;, it was an
error to specify the concrete type of &lt;code&gt;T&lt;/code&gt; via turbofish: &lt;code&gt;foo::&amp;lt;u32&amp;gt;(3, 3)&lt;/code&gt;
would fail with:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;error[E0632]: cannot provide explicit generic arguments when &#x60;impl Trait&#x60; is used in argument position
 --&amp;gt; src/lib.rs:4:11
  |
4 |     foo::&amp;lt;u32&amp;gt;(3, 3);
  |           ^^^ explicit generic argument not allowed
  |
  &#x3D; note: see issue #83701 &amp;lt;https://github.com/rust-lang/rust/issues/83701&amp;gt; for more information
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In 1.63, this restriction is relaxed, and the explicit type of the generic can be specified.
However, the &lt;code&gt;impl Trait&lt;/code&gt; parameter, despite desugaring to a generic, remains
opaque and cannot be specified via turbofish.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#non-lexical-lifetimes-migration-complete&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;non-lexical-lifetimes-migration-complete&quot;&gt;&lt;/a&gt;Non-lexical lifetimes migration complete&lt;/h3&gt;
&lt;p&gt;As detailed in &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2022/08/05/nll-by-default.html&quot;&gt;this blog post&lt;/a&gt;, we&#x27;ve fully removed the previous lexical borrow checker
from rustc across all editions, fully enabling the non-lexical, new, version of the borrow
checker. Since the borrow checker doesn&#x27;t affect the output of rustc, this won&#x27;t change
the behavior of any programs, but it completes a long-running migration (started in the
initial stabilization of NLL for the 2018 edition) to deliver the full benefits of the new
borrow checker across all editions of Rust. For most users, this change will bring
slightly better diagnostics for some borrow checking errors, but will not otherwise impact
which code they can write.&lt;/p&gt;
&lt;p&gt;You can read more about non-lexical lifetimes in &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html#non-lexical-lifetimes&quot;&gt;this section of the 2018 edition announcement&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations are now stabilized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/array/fn.from_fn.html&quot;&gt;&lt;code&gt;array::from_fn&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/boxed/struct.Box.html#method.into_pin&quot;&gt;&lt;code&gt;Box::into_pin&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.try_reserve&quot;&gt;&lt;code&gt;BinaryHeap::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/alloc/collections/binary_heap/struct.BinaryHeap.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;BinaryHeap::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.try_reserve&quot;&gt;&lt;code&gt;OsString::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;OsString::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.try_reserve&quot;&gt;&lt;code&gt;PathBuf::try_reserve&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.PathBuf.html#method.try_reserve_exact&quot;&gt;&lt;code&gt;PathBuf::try_reserve_exact&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/path/struct.Path.html#method.try_exists&quot;&gt;&lt;code&gt;Path::try_exists&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cell/struct.Ref.html#method.filter_map&quot;&gt;&lt;code&gt;Ref::filter_map&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cell/struct.RefMut.html#method.filter_map&quot;&gt;&lt;code&gt;RefMut::filter_map&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.len&quot;&gt;&lt;code&gt;NonNull::&amp;lt;[T]&amp;gt;::len&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/borrow/trait.ToOwned.html#method.clone_into&quot;&gt;&lt;code&gt;ToOwned::clone_into&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/net/struct.Ipv6Addr.html#method.to_ipv4_mapped&quot;&gt;&lt;code&gt;Ipv6Addr::to_ipv4_mapped&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/trait.AsFd.html&quot;&gt;&lt;code&gt;unix::io::AsFd&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/struct.BorrowedFd.html&quot;&gt;&lt;code&gt;unix::io::BorrowedFd&amp;lt;&#x27;fd&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/unix/io/struct.OwnedFd.html&quot;&gt;&lt;code&gt;unix::io::OwnedFd&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/trait.AsHandle.html&quot;&gt;&lt;code&gt;windows::io::AsHandle&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.BorrowedHandle.html&quot;&gt;&lt;code&gt;windows::io::BorrowedHandle&amp;lt;&#x27;handle&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.OwnedHandle.html&quot;&gt;&lt;code&gt;windows::io::OwnedHandle&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.HandleOrInvalid.html&quot;&gt;&lt;code&gt;windows::io::HandleOrInvalid&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.HandleOrNull.html&quot;&gt;&lt;code&gt;windows::io::HandleOrNull&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.InvalidHandleError.html&quot;&gt;&lt;code&gt;windows::io::InvalidHandleError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.NullHandleError.html&quot;&gt;&lt;code&gt;windows::io::NullHandleError&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/trait.AsSocket.html&quot;&gt;&lt;code&gt;windows::io::AsSocket&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.BorrowedSocket.html&quot;&gt;&lt;code&gt;windows::io::BorrowedSocket&amp;lt;&#x27;handle&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/os/windows/io/struct.OwnedSocket.html&quot;&gt;&lt;code&gt;windows::io::OwnedSocket&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/fn.scope.html&quot;&gt;&lt;code&gt;thread::scope&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/fn.scope.html&quot;&gt;&lt;code&gt;thread::Scope&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/thread/struct.ScopedJoinHandle.html&quot;&gt;&lt;code&gt;thread::ScopedJoinHandle&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These APIs are now usable in const contexts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/array/fn.from_ref.html&quot;&gt;&lt;code&gt;array::from_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/slice/fn.from_ref.html&quot;&gt;&lt;code&gt;slice::from_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/intrinsics/fn.copy.html&quot;&gt;&lt;code&gt;intrinsics::copy&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/intrinsics/fn.copy_nonoverlapping.html&quot;&gt;&lt;code&gt;intrinsics::copy_nonoverlapping&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::copy_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to_nonoverlapping&quot;&gt;&lt;code&gt;&amp;lt;*const T&amp;gt;::copy_to_nonoverlapping&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::copy_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_to_nonoverlapping-1&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::copy_to_nonoverlapping&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_from&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::copy_from&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.copy_from_nonoverlapping&quot;&gt;&lt;code&gt;&amp;lt;*mut T&amp;gt;::copy_from_nonoverlapping&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/str/fn.from_utf8.html&quot;&gt;&lt;code&gt;str::from_utf8&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/str/struct.Utf8Error.html#method.error_len&quot;&gt;&lt;code&gt;Utf8Error::error_len&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/str/struct.Utf8Error.html#method.valid_up_to&quot;&gt;&lt;code&gt;Utf8Error::valid_up_to&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Condvar.html#method.new&quot;&gt;&lt;code&gt;Condvar::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#method.new&quot;&gt;&lt;code&gt;Mutex::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html#method.new&quot;&gt;&lt;code&gt;RwLock::new&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.63.0 release. Check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/stable/RELEASES.md#version-1630-2022-08-11&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-163-2022-08-11&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-163&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1630&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1630&quot;&gt;&lt;/a&gt;Contributors to 1.63.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.63.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.63.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Non-lexical lifetimes (NLL) fully stable</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/08/05/nll-by-default.html" type="text/html" title="Non-lexical lifetimes (NLL) fully stable" />
        <published>2022-08-05T00:00:00+00:00</published>
        <updated>2022-08-05T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/08/05/nll-by-default.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/08/05/nll-by-default.html">&lt;p&gt;As of Rust 1.63 (releasing next week), the &amp;quot;non-lexical lifetimes&amp;quot; (NLL) work will be enabled by default. NLL is the second iteration of Rust&#x27;s borrow checker. The &lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2094-nll.html&quot;&gt;RFC&lt;/a&gt; actually does quite a nice job of highlighting some of the motivating examples. &amp;quot;But,&amp;quot; I hear you saying, &amp;quot;wasn&#x27;t NLL included in &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html&quot;&gt;Rust 2018&lt;/a&gt;?&amp;quot; And yes, yes it was! But at that time, NLL was only enabled for Rust 2018 code, while Rust 2015 code ran in &amp;quot;migration mode&amp;quot;. When in &amp;quot;migration mode,&amp;quot; the compiler would run both the old &lt;em&gt;and&lt;/em&gt; the new borrow checker and compare the results. This way, we could give warnings for older code that should never have compiled in the first place; we could also limit the impact of any bugs in the new code. Over time, we have limited migration mode to be closer and closer to just running the new-style borrow checker: in the next release, that process completes, and all Rust code will be checked with NLL.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#how-does-removing-the-old-borrow-checker-affect-users&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-does-removing-the-old-borrow-checker-affect-users&quot;&gt;&lt;/a&gt;How does removing the old borrow checker affect users?&lt;/h2&gt;
&lt;p&gt;At this point, we have almost completely merged &amp;quot;migration mode&amp;quot; and &amp;quot;regular mode&amp;quot;, so switching to NLL will have very little impact on the user experience. A number of diagnostics changed, mostly for the better -- &lt;a href&#x3D;&quot;https://jackh726.github.io/rust/2022/06/10/nll-stabilization.html&quot;&gt;Jack Huey gives the full details in his blog post&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#credit-where-credit-is-due&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;credit-where-credit-is-due&quot;&gt;&lt;/a&gt;Credit where credit is due&lt;/h2&gt;
&lt;p&gt;The work to remove the old borrow checker has been going on for years. It&#x27;s been a long, tedious, and largely thankless process. We&#x27;d like to take a moment to highlight the various people involved and make sure they are recognized for their hard work:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/jackh726/&quot;&gt;Jack Huey&lt;/a&gt; (&lt;a href&#x3D;&quot;https://github.com/sponsors/jackh726&quot;&gt;sponsorship page&lt;/a&gt;), for driving the final details of stabilization (diagnostics, reconciling differences in behavior).&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/marmeladema&quot;&gt;Élie Roudninski&lt;/a&gt;, for refactoring the diagnostics code and doing the painstaking work (along with Jack) of checking each regressed case, one by one.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/Aaron1011&quot;&gt;Aaron Hill&lt;/a&gt;, for numerous improvements to bring NLL diagnostics up to par.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/matthewjasper&quot;&gt;Matthew Jasper&lt;/a&gt;, for reconciling errors around higher-ranked lifetimes and other core diagnostics improvements.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/lqd&quot;&gt;Rémy Rakic&lt;/a&gt;, for rebasing Matthew&#x27;s PR as well as doing other independent diagnostics work.&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/chrisvittal&quot;&gt;Christopher Vittal&lt;/a&gt;, for removing &amp;quot;compare&amp;quot; mode (don&#x27;t ask).&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/centril&quot;&gt;Centril&lt;/a&gt;, for doing a lot of early work reconciling migration mode and the regular mode.&lt;/li&gt;
&lt;li&gt;And of course the members of the NLL working group (myself, &lt;a href&#x3D;&quot;https://github.com/pnkfelix&quot;&gt;Felix Klock&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/spastorino&quot;&gt;Santiago Pastorino&lt;/a&gt; (&lt;a href&#x3D;&quot;https://github.com/sponsors/spastorino&quot;&gt;sponsorship page&lt;/a&gt;), &lt;a href&#x3D;&quot;https://github.com/matthewjasper&quot;&gt;Matthew Jasper&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/davidtwco&quot;&gt;David Wood&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/lqd&quot;&gt;Rémy Rakic&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/nashenas88&quot;&gt;Paul Daniel Faria&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/nnethercote&quot;&gt;Nick Nethercote&lt;/a&gt;) who delivered the feature in the first place.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Jack&#x27;s blog post includes a &lt;a href&#x3D;&quot;https://jackh726.github.io/rust/2022/06/10/nll-stabilization.html#how-did-we-get-here&quot;&gt;detailed narrative&lt;/a&gt; of all the work involved if you&#x27;d like more details! It&#x27;s a fun read.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#looking-forward-what-can-we-expect-for-the-borrow-checker-of-the-future&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;looking-forward-what-can-we-expect-for-the-borrow-checker-of-the-future&quot;&gt;&lt;/a&gt;Looking forward: what can we expect for the &amp;quot;borrow checker of the future&amp;quot;?&lt;/h2&gt;
&lt;p&gt;The next frontier for Rust borrow checking is taking the &lt;a href&#x3D;&quot;https://github.com/rust-lang/polonius&quot;&gt;polonius&lt;/a&gt; project and moving it from research experiment to production code. Polonius is a next-generation version of the borrow checker that was &amp;quot;spun off&amp;quot; from the main NLL effort in 2018, as we were getting NLL ready to ship in production. Its most important contribution is fixing a known limitation of the borrow checker, demonstrated by the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;fn last_or_push&amp;lt;&#x27;a&amp;gt;(vec: &amp;amp;&#x27;a mut Vec&amp;lt;String&amp;gt;) -&amp;gt; &amp;amp;&#x27;a String {
    if let Some(s) &#x3D; vec.last() { // borrows vec
        // returning s here forces vec to be borrowed
        // for the rest of the function, even though it
        // shouldn&#x27;t have to be
        return s; 
    }
    
    // Because vec is borrowed, this call to vec.push gives
    // an error!
    vec.push(&amp;quot;&amp;quot;.to_string()); // ERROR
    vec.last().unwrap()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example doesn&#x27;t compile today (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;517ac32f0aab076faa32b9065783bbb4&quot;&gt;try it for yourself&lt;/a&gt;), though there&#x27;s not a good reason for that. You can often workaround the problem by editing the code to introduce a redundant &lt;code&gt;let&lt;/code&gt; (&lt;a href&#x3D;&quot;https://play.rust-lang.org/?version&#x3D;stable&amp;amp;mode&#x3D;debug&amp;amp;edition&#x3D;2021&amp;amp;gist&#x3D;d9b25963e83201902ecf5c02d79cbc13&quot;&gt;as shown in this example&lt;/a&gt;), but with polonius, it will compile as is. If you&#x27;d like to learn more about how polonius (and the existing borrow checker) works&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, you can &lt;a href&#x3D;&quot;https://www.youtube.com/watch?v&#x3D;_agDeiWek8w&quot;&gt;watch my talk from Rust Belt Rust&lt;/a&gt;.&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;Or where the name &amp;quot;polonius&amp;quot; comes from! &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
    <entry>
        <title>Increasing the glibc and Linux kernel requirements</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/08/01/Increasing-glibc-kernel-requirements.html" type="text/html" title="Increasing the glibc and Linux kernel requirements" />
        <published>2022-08-01T00:00:00+00:00</published>
        <updated>2022-08-01T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/08/01/Increasing-glibc-kernel-requirements.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/08/01/Increasing-glibc-kernel-requirements.html">&lt;p&gt;The minimum requirements for Rust toolchains targeting Linux will &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/95026&quot;&gt;increase&lt;/a&gt; with the
Rust 1.64.0 release (slated for September 22nd, 2022). The new minimum requirements are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;glibc &amp;gt;&#x3D; 2.17 (previously glibc &amp;gt;&#x3D; 2.11)&lt;/li&gt;
&lt;li&gt;kernel &amp;gt;&#x3D; 3.2 (previously kernel &amp;gt;&#x3D; 2.6.32)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These requirements apply both to running the Rust compiler itself (and other Rust tooling like
Cargo or Rustup), and to running binaries produced by Rust, if they use the libstd.&lt;/p&gt;
&lt;p&gt;If you are not targeting an old long-term-support distribution, or embedded hardware running
an old Linux version, this change is unlikely to affect you. Otherwise, read on!&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#affected-targets&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-targets&quot;&gt;&lt;/a&gt;Affected targets&lt;/h1&gt;
&lt;p&gt;In principle, the new kernel requirements affect all &lt;code&gt;*-linux-*&lt;/code&gt; targets, while the glibc
requirements affect all &lt;code&gt;*-linux-gnu*&lt;/code&gt; targets. In practice, many targets were already requiring
newer kernel or glibc versions. The requirements for such targets do not change.&lt;/p&gt;
&lt;p&gt;Among targets for which a Rust host toolchain is distributed, the following &lt;em&gt;are&lt;/em&gt; affected:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i686-unknown-linux-gnu&lt;/code&gt; (Tier 1)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x86_64-unknown-linux-gnu&lt;/code&gt; (Tier 1)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x86_64-unknown-linux-musl&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;powerpc-unknown-linux-gnu&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;powerpc64-unknown-linux-gnu&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s390x-unknown-linux-gnu&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following are &lt;em&gt;not&lt;/em&gt; affected, because they already had higher glibc/kernel requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aarch64-unknown-linux-gnu&lt;/code&gt; (Tier 1)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aarch64-unknown-linux-musl&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arm-unknown-linux-gnueabi&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arm-unknown-linux-gnueabihf&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;armv7-unknown-linux-gnueabihf&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mips-unknown-linux-gnueabihf&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;powerpc64le-unknown-linux-gnueabihf&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;riscv64gc-unknown-linux-gnueabihf&lt;/code&gt; (Tier 2 with host tools)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For other tier 2 or tier 3 targets, for which no Rust toolchain is distributed, we do not
accurately track minimum requirements, and they may or may not be affected by this change.
&lt;code&gt;*-linux-musl*&lt;/code&gt; targets are only affected by the kernel requirements, not the glibc requirements.
Targets which only use libcore and not libstd are unaffected.&lt;/p&gt;
&lt;p&gt;A list of supported targets and their requirements can be found on the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/nightly/rustc/platform-support.html&quot;&gt;platform support page&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#affected-systems&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;affected-systems&quot;&gt;&lt;/a&gt;Affected systems&lt;/h1&gt;
&lt;p&gt;The glibc and kernel versions used for the new baseline requirements are already close to a decade
old. As such, this change should only affect users that either target old long-term-support Linux
distributions, or embedded hardware running old versions of Linux.&lt;/p&gt;
&lt;p&gt;The following Linux distributions &lt;em&gt;are&lt;/em&gt; still supported under the new requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL 7 (glibc 2.17, kernel 3.10)&lt;/li&gt;
&lt;li&gt;SLES 12-SP5 (glibc 2.22, kernel 4.12.14)&lt;/li&gt;
&lt;li&gt;Debian 8 (glibc 2.19, kernel 3.16.7)&lt;/li&gt;
&lt;li&gt;Ubuntu 14.04 (glibc 2.19, kernel 3.13)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following distributions are &lt;em&gt;not&lt;/em&gt; supported under the new requirements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RHEL 6 (glibc 2.12, kernel 2.6.32)&lt;/li&gt;
&lt;li&gt;SLES 11-SP4 (glibc 2.11.3, kernel 3.0.101)&lt;/li&gt;
&lt;li&gt;Debian 6 (glibc 2.11, kernel 2.6.32), Debian 7 (glibc 2.13, kernel 3.2.41)&lt;/li&gt;
&lt;li&gt;Ubuntu 12.04 (glibc 2.15, kernel 3.2)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Out of the distributions in the second list, only RHEL 6 still has limited vendor support (ELS).&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#why-increase-the-requirements&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;why-increase-the-requirements&quot;&gt;&lt;/a&gt;Why increase the requirements?&lt;/h1&gt;
&lt;p&gt;We want Rust, and binaries produced by Rust, to be as widely usable as possible. At the same time,
the Rust project only has limited resources to maintain compatibility with old environments.&lt;/p&gt;
&lt;p&gt;There are two parts to the toolchain requirements: The minimum requirements for running the Rust
compiler on a host system, and the minimum requirements for cross-compiled binaries.&lt;/p&gt;
&lt;p&gt;The minimum requirements for host toolchains affect our build system. Rust CI produces binary
artifacts for dozens of different targets. Creating binaries that support old glibc versions
requires either building on an operating system with old glibc (for native builds) or using a
buildroot with an old glibc version (for cross-compiled builds).&lt;/p&gt;
&lt;p&gt;At the same time, Rust relies on LLVM for optimization and code generation, which regularly
increases its toolchain requirements. LLVM 16 will require GCC 7.1 or newer (and LLVM 15 supports
GCC 5.1 in name only). Creating a build environment that has both a very old glibc and a recent
compiler becomes increasingly hard over time. crosstool-ng (which we use for most cross-compilation
needs) does not support targeting both glibc 2.11, and using a compiler that satisfies the new LLVM
requirements.&lt;/p&gt;
&lt;p&gt;The requirements for cross-compiled binaries have a different motivation: They affect which kernel
versions need to be supported by libstd. Increasing the kernel requirements allows libstd to use
newer syscalls, without having to maintain and test compatibility with kernels that do not support
them.&lt;/p&gt;
&lt;p&gt;The new baseline requirements were picked as the least common denominator among long-term-support
distributions that still have active support. This is currently RHEL 7 with glibc 2.17 and
kernel 3.10. The kernel requirement is picked as 3.2 instead, because this is the minimum
requirement of glibc itself, and there is little relevant API difference between these versions.&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#what-should-i-do&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-should-i-do&quot;&gt;&lt;/a&gt;What should I do?&lt;/h1&gt;
&lt;p&gt;If you or your organization are affected by this change, there are a number of viable options
depending on your situation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Upgrade your target system, or raise the minimum requirements of your software, to satisfy the
new constraints.&lt;/li&gt;
&lt;li&gt;If you are running the Rust compiler on an old host, consider cross-compiling from a newer host
instead.&lt;/li&gt;
&lt;li&gt;If you are targeting an old glibc version, consider targeting musl instead.&lt;/li&gt;
&lt;li&gt;If you are targeting an old kernel version and use libstd, you may be out of luck: In this case
you may have to either freeze your current Rust version, or maintain a fork of libstd that
supports older kernels.&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>Nikita Popov</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.62.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/07/19/Rust-1.62.1.html" type="text/html" title="Announcing Rust 1.62.1" />
        <published>2022-07-19T00:00:00+00:00</published>
        <updated>2022-07-19T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/07/19/Rust-1.62.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/07/19/Rust-1.62.1.html">&lt;p&gt;The Rust team has published a new point release of Rust, 1.62.1. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, you can get 1.62.1 with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1621-2022-07-19&quot;&gt;detailed release notes for 1.62.1&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1621-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1621-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.62.1 stable&lt;/h2&gt;
&lt;p&gt;Rust 1.62.1 addresses a few recent regressions in the compiler and standard
library, and also mitigates a CPU vulnerability on Intel SGX.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/98608&quot;&gt;The compiler fixed unsound function coercions involving &lt;code&gt;impl Trait&lt;/code&gt; return types.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/98890&quot;&gt;The compiler fixed an incremental compilation bug with &lt;code&gt;async fn&lt;/code&gt; lifetimes.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/98950&quot;&gt;Windows added a fallback for overlapped I/O in synchronous reads and writes.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/98126&quot;&gt;The &lt;code&gt;x86_64-fortanix-unknown-sgx&lt;/code&gt; target added a mitigation for the
MMIO stale data vulnerability&lt;/a&gt;, advisory &lt;a href&#x3D;&quot;https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00615.html&quot;&gt;INTEL-SA-00615&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1621&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1621&quot;&gt;&lt;/a&gt;Contributors to 1.62.1&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.62.1. We couldn&#x27;t have done it
without all of you. &lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.62.1/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Changes in the Core Team</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/07/12/changes-in-the-core-team.html" type="text/html" title="Changes in the Core Team" />
        <published>2022-07-12T00:00:00+00:00</published>
        <updated>2022-07-12T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/07/12/changes-in-the-core-team.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/07/12/changes-in-the-core-team.html">&lt;p&gt;We want to say farewell and thanks to a couple of people who are stepping back from the Core Team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Aidan Hobson Sayers is leaving the Core Team and other roles. Joining the Core Team in 2018, he started out on the project with fixing CI issues and has been a member of the Infrastructure Team since its inception (moving through lead and co-lead). Aidan wants to dedicate more time to working with the Rust community and growing Rust usage at his company, and is looking forward to doing so from the other side of the fence.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ashley Williams will be stepping down from the Core Team and other roles. She became a member of the Core Team in 2018 and has had impact on many parts of the project, from leading the Community team, to setting up PagerDuty for Infrastructure and Crates.io, to the Wasm working group, to Increasing Rust’s Reach and Rustbridge, to her instrumental work creating the Rust Foundation and serving as its first Executive Director. Ashley is leaving her role in the project to focus on her newly founded company.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Many thanks to both of them for their contributions and we look forward to seeing their future efforts with Rust!&lt;/p&gt;
</content>

        <author>
            <name>The Rust Core Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rustup 1.25.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/07/12/Rustup-1.25.1.html" type="text/html" title="Announcing Rustup 1.25.1" />
        <published>2022-07-12T00:00:00+00:00</published>
        <updated>2022-07-12T00:00:01+00:00</updated>
        <id>https://blog.rust-lang.org/2022/07/12/Rustup-1.25.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/07/12/Rustup-1.25.1.html">&lt;p&gt;The rustup working group is announcing the release of rustup version 1.25.1.
&lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;Rustup&lt;/a&gt; is the recommended tool to install &lt;a href&#x3D;&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;, a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of rustup installed, getting rustup 1.25.1 is as
easy as stopping any programs which may be using Rustup (e.g. closing your IDE)
and running:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rustup will also automatically update itself at the end of a normal toolchain
update:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;get rustup&lt;/a&gt; from the
appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-new-in-rustup-1251&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-new-in-rustup-1251&quot;&gt;&lt;/a&gt;What&#x27;s new in rustup 1.25.1&lt;/h2&gt;
&lt;p&gt;This version of rustup fixes a regression introduced in the previous release
(1.25.0), which caused some workflows to fail.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#regression-in-nested-cargo-invocations-with-different-toolchains&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;regression-in-nested-cargo-invocations-with-different-toolchains&quot;&gt;&lt;/a&gt;Regression in nested Cargo invocations with different toolchains&lt;/h3&gt;
&lt;p&gt;When you invoke Rust or Cargo installed by rustup, you&#x27;re not running them
directly. Instead, you run &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/concepts/proxies.html&quot;&gt;rustup &amp;quot;proxy&amp;quot; binaries&lt;/a&gt;, whose job is to
detect the right toolchain (parsing the &lt;code&gt;+channel&lt;/code&gt; CLI argument or using one of
the defaults) and run it.&lt;/p&gt;
&lt;p&gt;Running these proxies is not instantaneous though, and for example a &lt;code&gt;cargo build&lt;/code&gt; invocation might execute several of them (the initial &lt;code&gt;cargo&lt;/code&gt; invocation
plus one &lt;code&gt;rustc&lt;/code&gt; for every dependency), slowing down the build.&lt;/p&gt;
&lt;p&gt;To improve performance, rustup 1.25.0 changed the proxies code to set the
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-reads&quot;&gt;&lt;code&gt;RUSTC&lt;/code&gt; and &lt;code&gt;RUSTDOC&lt;/code&gt; environment variables&lt;/a&gt; when missing, which
instructed Cargo to skip the proxies and invoke the binaries defined in those
variables directly. This provided a performance gain when building crates with
lots of dependencies.&lt;/p&gt;
&lt;p&gt;Unfortunately this change broke some users of rustup, who did something like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The first Cargo invocation (for example an extension, an alias or an
integration test) uses toolchain &lt;code&gt;foo&lt;/code&gt;, setting the &lt;code&gt;RUSTC&lt;/code&gt; and &lt;code&gt;RUSTDOC&lt;/code&gt;
environment variables pointing to that toolchain.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The first invocation calls Cargo again, but this time using toolchain &lt;code&gt;bar&lt;/code&gt;
(for example &lt;code&gt;cargo +bar build&lt;/code&gt;). This does &lt;strong&gt;not&lt;/strong&gt; set the &lt;code&gt;RUSTC&lt;/code&gt; and
&lt;code&gt;RUSTDOC&lt;/code&gt; environment variables pointing to &lt;code&gt;bar&lt;/code&gt;, as those variables are
already present.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The second invocation of Cargo then invokes rustc by using the &lt;code&gt;RUSTC&lt;/code&gt;
environment variable and skipping the proxy, which results in the &lt;code&gt;foo&lt;/code&gt;
toolchain being invoked. Previous versions of rustup invoked the proxy
instead, which would correctly detect and use the &lt;code&gt;bar&lt;/code&gt; toolchain.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rustup 1.25.1 fixes this regression by reverting the change. The rustup working
group is discussing in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustup/issues/3035&quot;&gt;issue #3035&lt;/a&gt; plans to re-introduce the change in
a future release while avoiding breakage.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thanks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Thanks again to all the contributors who made rustup 1.25.1 possible!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Daniel Silverstone (kinnison)&lt;/li&gt;
&lt;li&gt;Robert Collins (rbtcollins)&lt;/li&gt;
&lt;li&gt;Joshua Nelson (jyn514)&lt;/li&gt;
&lt;li&gt;Pietro Albini (pietroalbini)&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>The Rustup Working Group</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rustup 1.25.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2022/07/11/Rustup-1.25.0.html" type="text/html" title="Announcing Rustup 1.25.0" />
        <published>2022-07-11T00:00:00+00:00</published>
        <updated>2022-07-11T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2022/07/11/Rustup-1.25.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2022/07/11/Rustup-1.25.0.html">&lt;p&gt;The rustup working group is happy to announce the release of rustup version 1.25.0. &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;Rustup&lt;/a&gt; is the recommended tool to install &lt;a href&#x3D;&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;, a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of rustup installed, getting rustup 1.25.0 is as easy as stopping any programs which may be using Rustup (e.g. closing your IDE) and running:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rustup will also automatically update itself at the end of a normal toolchain update:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;get rustup&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-new-in-rustup-1250&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-new-in-rustup-1250&quot;&gt;&lt;/a&gt;What&#x27;s new in rustup 1.25.0&lt;/h2&gt;
&lt;p&gt;This version of Rustup involves a significant number of internal cleanups, both in terms
of the Rustup code and its documentation. In addition to a lot of work on the codebase
itself, due to the length of time since the last release this one has a record number
of contributors and we thank you all for your efforts and time.&lt;/p&gt;
&lt;p&gt;One of the biggest changes in 1.25.0 is the new offer on Windows installs to auto-install
the Visual Studio 2022 compilers which should simplify the process of getting started for
people not used to developing on Windows with the MSVC-compatible toolchains.&lt;/p&gt;
&lt;p&gt;A second important change for 1.25.0 is a number of PRs focussed around startup performance
for Rustup. While it may not seem all that important to many, Rustup&#x27;s startup time is
a factor in the time it takes to do builds which involve large numbers of crates on systems
which do not have large numbers of CPU cores. Hopefully the people for whom this is a common
activity will notice an improvement; though there&#x27;s more opportunity to speed things up still available.&lt;/p&gt;
&lt;p&gt;Some, but by no means all, of the rest of this release&#x27;s highlights includes support for
&lt;code&gt;rustup default none&lt;/code&gt; to unset the default toolchain, support for Windows arm64, inclusion
of &lt;code&gt;rust-gdbgui&lt;/code&gt; as a proxy so that platforms which support it can use GDB&#x27;s gui mode with Rust,
and some improvements to &lt;code&gt;rustup-init.sh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Full details are available in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustup/blob/stable/CHANGELOG.md&quot;&gt;changelog&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Rustup&#x27;s documentation is also available in &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/&quot;&gt;the rustup book&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thanks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Thanks again to all the contributors who made rustup 1.25.0 possible!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二手掉包工程师 (hi-rustin)&lt;/li&gt;
&lt;li&gt;Brian Bowman (Seeker14491)&lt;/li&gt;
&lt;li&gt;Jon Gjengset (jonho)&lt;/li&gt;
&lt;li&gt;pierwill&lt;/li&gt;
&lt;li&gt;Daniel Silverstone (kinnison)&lt;/li&gt;
&lt;li&gt;Robert Collins (rbtcollins)&lt;/li&gt;
&lt;li&gt;Alan Somers (asomers)&lt;/li&gt;
&lt;li&gt;Brennan Vincent (umanwizard)&lt;/li&gt;
&lt;li&gt;Joshua Nelson (jyn514)&lt;/li&gt;
&lt;li&gt;Eric Huss (ehuss)&lt;/li&gt;
&lt;li&gt;Will Bush (willbush)&lt;/li&gt;
&lt;li&gt;Thad Guidry (thadguidry)&lt;/li&gt;
&lt;li&gt;Alexander Lovchin (alovchin91)&lt;/li&gt;
&lt;li&gt;zoodirector&lt;/li&gt;
&lt;li&gt;Takayuki Nakata (giraffate)&lt;/li&gt;
&lt;li&gt;Yusuke Abe (chansuke)&lt;/li&gt;
&lt;li&gt;Wyatt Carss (wcarss)&lt;/li&gt;
&lt;li&gt;Sondre Aasemoen (sondr3)&lt;/li&gt;
&lt;li&gt;facklambda&lt;/li&gt;
&lt;li&gt;Chad Dougherty (crd477)&lt;/li&gt;
&lt;li&gt;Noritada Kobayashi (noritada)&lt;/li&gt;
&lt;li&gt;Milan (mdaverde)&lt;/li&gt;
&lt;li&gt;Pat Sier (pjsier)&lt;/li&gt;
&lt;li&gt;Matt Keeter (mkeeter)&lt;/li&gt;
&lt;li&gt;Alex Macleod (alexendoo)&lt;/li&gt;
&lt;li&gt;Sathwik Matsa (sathwikmatsa)&lt;/li&gt;
&lt;li&gt;Kushal Das (kushaldas)&lt;/li&gt;
&lt;li&gt;Justus Winter (teythoon)&lt;/li&gt;
&lt;li&gt;k900&lt;/li&gt;
&lt;li&gt;Nicolas Ambram (nico-abram)&lt;/li&gt;
&lt;li&gt;Connor Slade (basicprogrammer10)&lt;/li&gt;
&lt;li&gt;Yerkebulan Tulibergenov (yerke)&lt;/li&gt;
&lt;li&gt;Caleb Cartwright (calebcartwright)&lt;/li&gt;
&lt;li&gt;Matthias Beyer (matthiasbeyer)&lt;/li&gt;
&lt;li&gt;spacemaniac&lt;/li&gt;
&lt;li&gt;Alex Touchet (atouchet)&lt;/li&gt;
&lt;li&gt;Guillaume Gomez (guillaumegomez)&lt;/li&gt;
&lt;li&gt;Chris Denton (chrisdenton)&lt;/li&gt;
&lt;li&gt;Thomas Orozco (krallin)&lt;/li&gt;
&lt;li&gt;cui fliter (cuishuang)&lt;/li&gt;
&lt;li&gt;Martin Nordholts (enselic)&lt;/li&gt;
&lt;li&gt;Emil Gardström (emilgardis)&lt;/li&gt;
&lt;li&gt;Arlo Siemsen (arlosi)&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>The Rustup Working Group</name>
        </author>
    </entry>
    
</feed>

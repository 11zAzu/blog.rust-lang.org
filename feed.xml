<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://blog.rust-lang.org/" version="0.1.0">Rust Blog</generator>
    <link href="https://blog.rust-lang.org/feed.xml" rel="self" type="application/atom+xml" />
    <link href="https://blog.rust-lang.org/" rel="alternate" type="text/html" />
    <id>https://blog.rust-lang.org/</id>
    <title>Rust Blog</title>
    <subtitle>Empowering everyone to build reliable and efficient software.</subtitle>
    <author>
        <name>Maintained by the Rust Team.</name>
        <uri>https://github.com/rust-lang/blog.rust-lang.org/</uri>
    </author>
    <updated>2021-07-13T01:18:50+00:00</updated>

    
    <entry>
        <title>Announcing Rust 1.53.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/06/17/Rust-1.53.0.html" type="text/html" title="Announcing Rust 1.53.0" />
        <published>2021-06-17T00:00:00+00:00</published>
        <updated>2021-06-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/06/17/Rust-1.53.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/06/17/Rust-1.53.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.53.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.53.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1530-2021-06-17&quot;&gt;detailed release notes for 1.53.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1530-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1530-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.53.0 stable&lt;/h2&gt;
&lt;p&gt;This release contains several new language features and many new library features,
including the long-awaited &lt;code&gt;IntoIterator&lt;/code&gt; implementation for arrays.
See the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1530-2021-06-17&quot;&gt;detailed release notes&lt;/a&gt;
to learn about other changes not covered by this post.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#intoiterator-for-arrays&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;intoiterator-for-arrays&quot;&gt;&lt;/a&gt;IntoIterator for arrays&lt;/h3&gt;
&lt;p&gt;This is the first Rust release in which arrays implement the &lt;code&gt;IntoIterator&lt;/code&gt; trait.
This means you can now iterate over arrays by value:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;for i in [1, 2, 3] {
    ..
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Previously, this was only possible by reference, using &lt;code&gt;&amp;amp;[1, 2, 3]&lt;/code&gt; or &lt;code&gt;[1, 2, 3].iter()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Similarly, you can now pass arrays to methods expecting a &lt;code&gt;T: IntoIterator&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let set &#x3D; BTreeSet::from_iter([1, 2, 3]);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;for (a, b) in some_iterator.chain([1]).zip([1, 2, 3]) {
    ..
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This was not implemented before, due to backwards compatibility problems.
Because &lt;code&gt;IntoIterator&lt;/code&gt; was already implemented for references to arrays,
&lt;code&gt;array.into_iter()&lt;/code&gt; already compiled in earlier versions,
resolving to &lt;code&gt;(&amp;amp;array).into_iter()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As of this release, arrays implement &lt;code&gt;IntoIterator&lt;/code&gt; with a small workaround to avoid breaking code.
The compiler will continue to resolve &lt;code&gt;array.into_iter()&lt;/code&gt; to &lt;code&gt;(&amp;amp;array).into_iter()&lt;/code&gt;,
as if the trait implementation does not exist.
This only applies to the &lt;code&gt;.into_iter()&lt;/code&gt; method call syntax, and does not
affect any other syntax such as &lt;code&gt;for e in [1, 2, 3]&lt;/code&gt;, &lt;code&gt;iter.zip([1, 2, 3])&lt;/code&gt; or
&lt;code&gt;IntoIterator::into_iter([1, 2, 3])&lt;/code&gt;, which all compile fine.&lt;/p&gt;
&lt;p&gt;Since this special case for &lt;code&gt;.into_iter()&lt;/code&gt; is only required to avoid breaking existing code,
it is removed in the new edition, Rust 2021, which will be released later this year.
See &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/05/11/edition-2021.html#intoiterator-for-arrays&quot;&gt;the edition announcement&lt;/a&gt;
for more information.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#or-patterns&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;or-patterns&quot;&gt;&lt;/a&gt;Or patterns&lt;/h3&gt;
&lt;p&gt;Pattern syntax has been extended to support &lt;code&gt;|&lt;/code&gt; nested anywhere in the pattern.
This enables you to write &lt;code&gt;Some(1 | 2)&lt;/code&gt; instead of &lt;code&gt;Some(1) | Some(2)&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;match result {
     Ok(Some(1 | 2)) &#x3D;&amp;gt; { .. }
     Err(MyError { kind: FileNotFound | PermissionDenied, .. }) &#x3D;&amp;gt; { .. }
     _ &#x3D;&amp;gt; { .. }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#unicode-identifiers&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;unicode-identifiers&quot;&gt;&lt;/a&gt;Unicode identifiers&lt;/h3&gt;
&lt;p&gt;Identifiers can now contain non-ascii characters.
All valid identifier characters in Unicode as defined in &lt;a href&#x3D;&quot;https://unicode.org/reports/tr31/&quot;&gt;UAX #31&lt;/a&gt; can now be used.
That includes characters from many different scripts and languages, but does not include emoji.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;const BL√ÖHAJ: &amp;amp;str &#x3D; &amp;quot;ü¶à&amp;quot;;

struct ‰∫∫ {
    ÂêçÂ≠ó: String,
}

let Œ± &#x3D; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The compiler will warn about potentially confusing situations involving different scripts.
For example, using identifiers that look very similar will result in a warning.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;warning: identifier pair considered confusable between &#x60;ÔΩì&#x60; and &#x60;s&#x60;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#head-branch-name-support-in-cargo&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;head-branch-name-support-in-cargo&quot;&gt;&lt;/a&gt;HEAD branch name support in Cargo&lt;/h3&gt;
&lt;p&gt;Cargo no longer assumes the default &lt;code&gt;HEAD&lt;/code&gt; of git repositories is named &lt;code&gt;master&lt;/code&gt;.
This means you no longer need to specify &lt;code&gt;branch &#x3D; &amp;quot;main&amp;quot;&lt;/code&gt; for git dependencies
from a repository where the default branch is called &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#incremental-compilation-remains-off-by-default&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;incremental-compilation-remains-off-by-default&quot;&gt;&lt;/a&gt;Incremental Compilation remains off by default&lt;/h3&gt;
&lt;p&gt;As previously discussed on the &lt;a href&#x3D;&quot;/2021/05/10/Rust-1.52.1.html&quot;&gt;blog post for version 1.52.1&lt;/a&gt;, incremental compilation has been turned off by default on the stable Rust release channel. The feature remains available on the beta and nightly release channels. For the 1.53.0 stable release, the method for reenabling incremental is unchanged from 1.52.1.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods and trait implementations were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/array/fn.from_ref.html&quot;&gt;&lt;code&gt;array::from_ref&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/array/fn.from_mut.html&quot;&gt;&lt;code&gt;array::from_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicBool.html#method.fetch_update&quot;&gt;&lt;code&gt;AtomicBool::fetch_update&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/sync/atomic/struct.AtomicPtr.html#method.fetch_update&quot;&gt;&lt;code&gt;AtomicPtr::fetch_update&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.retain&quot;&gt;&lt;code&gt;BTreeSet::retain&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html#method.retain&quot;&gt;&lt;code&gt;BTreeMap::retain&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/struct.BufReader.html#method.seek_relative&quot;&gt;&lt;code&gt;BufReader::seek_relative&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/fn.min_by.html&quot;&gt;&lt;code&gt;cmp::min_by&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/fn.min_by_key.html&quot;&gt;&lt;code&gt;cmp::min_by_key&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/fn.max_by.html&quot;&gt;&lt;code&gt;cmp::max_by&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/fn.max_by_key.html&quot;&gt;&lt;code&gt;cmp::max_by_key&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fmt/struct.DebugStruct.html#method.finish_non_exhaustive&quot;&gt;&lt;code&gt;DebugStruct::finish_non_exhaustive&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#associatedconstant.ZERO&quot;&gt;&lt;code&gt;Duration::ZERO&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#associatedconstant.MAX&quot;&gt;&lt;code&gt;Duration::MAX&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.is_zero&quot;&gt;&lt;code&gt;Duration::is_zero&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_add&quot;&gt;&lt;code&gt;Duration::saturating_add&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_sub&quot;&gt;&lt;code&gt;Duration::saturating_sub&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/time/struct.Duration.html#method.saturating_mul&quot;&gt;&lt;code&gt;Duration::saturating_mul&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.f32.html#method.is_subnormal&quot;&gt;&lt;code&gt;f32::is_subnormal&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.f64.html#method.is_subnormal&quot;&gt;&lt;code&gt;f64::is_subnormal&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.array.html#impl-IntoIterator&quot;&gt;&lt;code&gt;IntoIterator for array&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.usize.html#associatedconstant.BITS&quot;&gt;&lt;code&gt;{integer}::BITS&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/io/enum.ErrorKind.html#variant.Unsupported&quot;&gt;&lt;code&gt;io::Error::Unsupported&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroU32.html#method.leading_zeros&quot;&gt;&lt;code&gt;NonZero*::leading_zeros&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/num/struct.NonZeroU32.html#method.trailing_zeros&quot;&gt;&lt;code&gt;NonZero*::trailing_zeros&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/option/enum.Option.html#method.insert&quot;&gt;&lt;code&gt;Option::insert&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html#method.is_eq&quot;&gt;&lt;code&gt;Ordering::is_eq&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html#method.is_ne&quot;&gt;&lt;code&gt;Ordering::is_ne&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html#method.is_lt&quot;&gt;&lt;code&gt;Ordering::is_lt&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html#method.is_gt&quot;&gt;&lt;code&gt;Ordering::is_gt&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html#method.is_le&quot;&gt;&lt;code&gt;Ordering::is_le&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/cmp/enum.Ordering.html#method.is_ge&quot;&gt;&lt;code&gt;Ordering::is_ge&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsStr.html#method.make_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_lowercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsStr.html#method.make_ascii_uppercase&quot;&gt;&lt;code&gt;OsStr::make_ascii_uppercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsStr.html#method.to_ascii_lowercase&quot;&gt;&lt;code&gt;OsStr::to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsStr.html#method.to_ascii_uppercase&quot;&gt;&lt;code&gt;OsStr::to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsStr.html#method.is_ascii&quot;&gt;&lt;code&gt;OsStr::is_ascii&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/ffi/struct.OsStr.html#method.eq_ignore_ascii_case&quot;&gt;&lt;code&gt;OsStr::eq_ignore_ascii_case&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/iter/struct.Peekable.html#method.peek_mut&quot;&gt;&lt;code&gt;Peekable::peek_mut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/rc/struct.Rc.html#method.increment_strong_count&quot;&gt;&lt;code&gt;Rc::increment_strong_count&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/rc/struct.Rc.html#method.decrement_strong_count&quot;&gt;&lt;code&gt;Rc::decrement_strong_count&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/slice/struct.IterMut.html#method.as_slice&quot;&gt;&lt;code&gt;slice::IterMut::as_slice&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/slice/struct.IterMut.html#impl-AsRef%3C%5BT%5D%3E&quot;&gt;&lt;code&gt;AsRef&amp;lt;[T]&amp;gt; for slice::IterMut&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.tuple.html#impl-SliceIndex%3C%5BT%5D%3E&quot;&gt;&lt;code&gt;impl SliceIndex for (Bound&amp;lt;usize&amp;gt;, Bound&amp;lt;usize&amp;gt;)&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/vec/struct.Vec.html#method.extend_from_within&quot;&gt;&lt;code&gt;Vec::extend_from_within&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.53.0 release:
check out what changed in
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1530-2021-06-17&quot;&gt;Rust&lt;/a&gt;,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-153-2021-06-17&quot;&gt;Cargo&lt;/a&gt;,
and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-153&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1530&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1530&quot;&gt;&lt;/a&gt;Contributors to 1.53.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.53.0.
We couldn&#x27;t have done it without all of you.
&lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.53.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rustup 1.24.3</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/06/08/Rustup-1.24.3.html" type="text/html" title="Announcing Rustup 1.24.3" />
        <published>2021-06-08T00:00:00+00:00</published>
        <updated>2021-06-08T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/06/08/Rustup-1.24.3.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/06/08/Rustup-1.24.3.html">&lt;p&gt;The rustup working group is happy to announce the release of rustup version 1.24.3. &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;Rustup&lt;/a&gt; is the recommended tool to install &lt;a href&#x3D;&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;, a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of rustup installed, getting rustup 1.24.3 is as easy as closing your IDE and running:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rustup will also automatically update itself at the end of a normal toolchain update:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;get rustup&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-new-in-rustup-1243&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-new-in-rustup-1243&quot;&gt;&lt;/a&gt;What&#x27;s new in rustup 1.24.3&lt;/h2&gt;
&lt;p&gt;This patch release focusses around resolving some regressions in behaviour in
the 1.24.x series, in either low tier platforms, or unusual situations around
very old toolchains.&lt;/p&gt;
&lt;p&gt;Full details are available in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustup/blob/stable/CHANGELOG.md&quot;&gt;changelog&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Rustup&#x27;s documentation is also available in &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/&quot;&gt;the rustup book&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thanks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Thanks again to all the contributors who made rustup 1.24.3 possible!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alexander (asv7c2)&lt;/li&gt;
&lt;li&gt;Ian Jackson&lt;/li&gt;
&lt;li&gt;pierwill&lt;/li&gt;
&lt;li&gt;‰∫åÊâãÊéâÂåÖÂ∑•Á®ãÂ∏à (hi-rustin)&lt;/li&gt;
&lt;li&gt;Robert Collins&lt;/li&gt;
&lt;li&gt;Daniel Silverstone&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>The Rustup Working Group</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rustup 1.24.2</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/05/17/Rustup-1.24.2.html" type="text/html" title="Announcing Rustup 1.24.2" />
        <published>2021-05-17T00:00:00+00:00</published>
        <updated>2021-05-17T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/05/17/Rustup-1.24.2.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/05/17/Rustup-1.24.2.html">&lt;p&gt;The rustup working group is happy to announce the release of rustup version 1.24.2. &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;Rustup&lt;/a&gt; is the recommended tool to install &lt;a href&#x3D;&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;, a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of rustup installed, getting rustup 1.24.2 is as easy as closing your IDE and running:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rustup will also automatically update itself at the end of a normal toolchain update:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;get rustup&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-new-in-rustup-1242&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-new-in-rustup-1242&quot;&gt;&lt;/a&gt;What&#x27;s new in rustup 1.24.2&lt;/h2&gt;
&lt;p&gt;1.24.2 introduces pooled allocations to prevent memory fragmentation issues on
some platforms with 1.24.x. We&#x27;re not entirely sure what aspect of the streamed
unpacking logic caused allocator fragmentation, but memory pools are a well
known fix that should solve this for all platforms.&lt;/p&gt;
&lt;p&gt;Those who were encountering CI issues with 1.24.1 should find them resolved.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;You can check out all the changes to Rustup for 1.24.2 in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustup/blob/stable/CHANGELOG.md&quot;&gt;changelog&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Rustup&#x27;s documentation is also available in &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/&quot;&gt;the rustup book&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the Rustup working group are pleased to welcome a new member. Between
1.24.1 and 1.24.2 ‰∫åÊâãÊéâÂåÖÂ∑•Á®ãÂ∏à (hi-rustin) has joined, having already made some
excellent contributions.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thanks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Thanks again to all the contributors who made rustup 1.24.2 possible!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Carol (Nichols || Goulding)&lt;/li&gt;
&lt;li&gt;Daniel Silverstone&lt;/li&gt;
&lt;li&gt;Jo√£o Marcos Bezerra&lt;/li&gt;
&lt;li&gt;Josh Rotenberg&lt;/li&gt;
&lt;li&gt;Joshua Nelson&lt;/li&gt;
&lt;li&gt;Martijn Gribnau&lt;/li&gt;
&lt;li&gt;pierwill&lt;/li&gt;
&lt;li&gt;Robert Collins&lt;/li&gt;
&lt;li&gt;‰∫åÊâãÊéâÂåÖÂ∑•Á®ãÂ∏à (hi-rustin)&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>The Rustup Working Group</name>
        </author>
    </entry>
    
    <entry>
        <title>Six Years of Rust</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/05/15/six-years-of-rust.html" type="text/html" title="Six Years of Rust" />
        <published>2021-05-15T00:00:00+00:00</published>
        <updated>2021-05-15T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/05/15/six-years-of-rust.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/05/15/six-years-of-rust.html">&lt;p&gt;Today marks &lt;a href&#x3D;&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;&#x27;s sixth birthday since it went 1.0 in 2015. A lot has changed since then and especially over the past year, and Rust was no different. In 2020, there was no foundation yet, no const generics, and a lot of organisations were still wondering whether Rust was production ready.&lt;/p&gt;
&lt;p&gt;In the midst of the COVID-19 pandemic, hundreds of Rust&#x27;s global distributed set of team members and volunteers shipped over nine new stable releases of Rust, in addition to various bugfix releases. Today, &amp;quot;Rust in production&amp;quot; isn&#x27;t a question, but a statement. The newly founded Rust foundation has several members who value using Rust in production enough to help continue to support and contribute to its open development ecosystem.&lt;/p&gt;
&lt;p&gt;We wanted to take today to look back at some of the major improvements over the past year, how the community has been using Rust in production, and finally look ahead at some of the work that is currently ongoing to improve and use Rust for small and large scale projects over the next year. Let&#x27;s get started!&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#recent-additions&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;recent-additions&quot;&gt;&lt;/a&gt;Recent Additions&lt;/h2&gt;
&lt;p&gt;The Rust language has improved tremendously in the past year, gaining a lot of quality of life features, that while they don&#x27;t fundamentally change the language, they help make using and maintaining Rust in more places even easier.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;As of Rust 1.52.0 and the upgrade to LLVM 12, one of few cases of unsoundness around forward progress (such as handling infinite loops) has finally been resolved. This has been a long running collaboration between the Rust teams and the LLVM project, and is a great example of improvements to Rust also benefitting the wider ecosystem of programming languages.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On supporting an even wider ecosystem, the introduction of Tier 1 support for 64 bit ARM Linux, and Tier 2 support for ARM macOS &amp;amp; ARM Windows, has made Rust an even better place to easily build your projects across new and different architectures.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The most notable exception to the theme of polish has been the major improvements to Rust&#x27;s compile-time capabilities. The stabilisation of const generics for primitive types, the addition of control flow for &lt;code&gt;const fn&lt;/code&gt;s, and allowing procedural macros to be used in more places, have allowed completely powerful new types of APIs and crates to be created.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rustc wasn&#x27;t the only tool that had significant improvements.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Cargo just recently stabilised its new feature resolver, that makes it easier to use your dependencies across different targets.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rustdoc stabilised its &amp;quot;intra-doc links&amp;quot; feature, allowing you to easily and automatically cross reference Rust types and functions in your documentation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Clippy with Cargo now uses a separate build cache that provides much more consistent behaviour.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#rust-in-production&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;rust-in-production&quot;&gt;&lt;/a&gt;Rust In Production&lt;/h2&gt;
&lt;p&gt;Each year Rust&#x27;s growth and adoption in the community and industry has been unbelievable, and this past year has been no exception. Once again in 2020, Rust was voted StackOverflow&#x27;s &lt;a href&#x3D;&quot;https://stackoverflow.blog/2020/06/05/why-the-developers-who-use-rust-love-it-so-much/&quot;&gt;Most Loved Programming Language&lt;/a&gt;. Thank you to everyone in the community for your support, and help making Rust what it is today.&lt;/p&gt;
&lt;p&gt;With the formation of the &lt;a href&#x3D;&quot;https://foundation.rust-lang.org/posts/2021-02-08-hello-world/&quot;&gt;Rust foundation&lt;/a&gt;, Rust has been in a better position to build a sustainable open source ecosystem empowering everyone to build reliable and efficient software. A number of companies that use Rust have formed teams dedicated to maintaining and improving the Rust project, including &lt;a href&#x3D;&quot;https://aws.amazon.com/blogs/opensource/how-our-aws-rust-team-will-contribute-to-rusts-future-successes/&quot;&gt;AWS&lt;/a&gt;, &lt;a href&#x3D;&quot;https://engineering.fb.com/2021/04/29/developer-tools/rust/&quot;&gt;Facebook&lt;/a&gt;, and Microsoft.&lt;/p&gt;
&lt;p&gt;And it isn&#x27;t just Rust that has been getting bigger. Larger and larger companies have been adopting Rust in their projects and offering officially supported Rust APIs.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Both Microsoft and Amazon have just recently announced and released their new officially supported Rust libraries for interacting with &lt;a href&#x3D;&quot;https://github.com/microsoft/windows-rs&quot;&gt;Windows&lt;/a&gt; and &lt;a href&#x3D;&quot;https://github.com/awslabs/aws-sdk-rust&quot;&gt;AWS&lt;/a&gt;. Official first party support for these massive APIs helps make Rust people&#x27;s first choice when deciding what to use for their project.&lt;/li&gt;
&lt;li&gt;The cURL project has released new versions that offer opt-in support for using Rust libraries for handling &lt;a href&#x3D;&quot;https://daniel.haxx.se/blog/2020/10/09/rust-in-curl-with-hyper/&quot;&gt;HTTP/s&lt;/a&gt; and &lt;a href&#x3D;&quot;https://daniel.haxx.se/blog/2021/02/09/curl-supports-rustls/&quot;&gt;TLS&lt;/a&gt; communication. This has been a huge inter-community collaboration between the ISRG, the Hyper &amp;amp; Rustls teams, and the cURL project, and we&#x27;d like to thank everyone for their hard work in providing new memory safe backends for a project as massive and widely used as cURL!&lt;/li&gt;
&lt;li&gt;Tokio (an asynchronous runtime written in Rust), released its &lt;a href&#x3D;&quot;https://tokio.rs/blog/2020-12-tokio-1-0&quot;&gt;1.0 version&lt;/a&gt; and announced their three year stability guarantee, providing everyone with a solid, stable foundation for writing reliable network applications without compromising speed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#future-work&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;future-work&quot;&gt;&lt;/a&gt;Future Work&lt;/h2&gt;
&lt;p&gt;Of course, all that is just to start, we&#x27;re seeing more and more initiatives putting Rust in exciting new places;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Critical Section &amp;amp; Ferrous Systems have started &lt;a href&#x3D;&quot;https://ferrous-systems.com/ferrocene&quot;&gt;Ferrocene&lt;/a&gt;, a project to make Rust a viable programming language for safety and mission critical systems across the industry.&lt;/li&gt;
&lt;li&gt;Embark Studios have released an initial prototype of &lt;a href&#x3D;&quot;https://github.com/EmbarkStudios/rust-gpu&quot;&gt;&lt;code&gt;rust-gpu&lt;/code&gt;&lt;/a&gt;, a new compiler backend that allows writing graphics shaders using Rust for GPUs.&lt;/li&gt;
&lt;li&gt;The Linux project is currently &lt;a href&#x3D;&quot;https://lore.kernel.org/lkml/CANiq72khBa2GcB6-PHM3A44Y90d6vzYAS&#x3D;BVpk3nT4B6u+NVDw@mail.gmail.com/T/#mb5e524dae9d5a5815c6e68eb36b9bde4e87c861d&quot;&gt;considering a proposal to add Rust as the second language to the kernel&lt;/a&gt; to enable writing safer driver and kernel-space code.&lt;/li&gt;
&lt;li&gt;Google has announced that it &lt;a href&#x3D;&quot;https://security.googleblog.com/2021/04/rust-in-android-platform.html&quot;&gt;now supports building low level components of the Android OS in Rust&lt;/a&gt;, and have already begun an effort to rewrite their bluetooth stack with Rust!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Right now the Rust teams are planning and coordinating the 2021 edition of Rust. Much like this past year, a lot of themes of the changes are around improving quality of life. You can check out our recent post about &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/05/11/edition-2021.html&quot;&gt;&amp;quot;The Plan for the Rust 2021 Edition&amp;quot;&lt;/a&gt; to see what the changes the teams are planning.&lt;/p&gt;
&lt;p&gt;And that&#x27;s just the tip of the iceberg; there are a lot more changes being worked on, and exciting new open projects being started every day in Rust. We can&#x27;t wait to see what you all build in the year ahead!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Are there changes, or projects from the past year that you&#x27;re excited about? Are you looking to get started with Rust? Do you want to help contribute to the 2021 edition? Then come on over, introduce yourself, and join the discussion over on our &lt;a href&#x3D;&quot;https://users.rust-lang.org/&quot;&gt;Discourse&lt;/a&gt; forum and &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/&quot;&gt;Zulip&lt;/a&gt; chat! Everyone is welcome, we are committed to providing a friendly, safe and welcoming environment for all, regardless of gender, sexual orientation, disability, ethnicity, religion, or similar personal characteristic.&lt;/p&gt;
</content>

        <author>
            <name>The Rust Team</name>
        </author>
    </entry>
    
    <entry>
        <title>The Plan for the Rust 2021 Edition</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/05/11/edition-2021.html" type="text/html" title="The Plan for the Rust 2021 Edition" />
        <published>2021-05-11T00:00:00+00:00</published>
        <updated>2021-05-11T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/05/11/edition-2021.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/05/11/edition-2021.html">&lt;p&gt;We are happy to announce that the third edition of the Rust language, Rust 2021,
is scheduled for release in October.
Rust 2021 contains a number of small changes that are
nonetheless expected to make a significant improvement to how Rust feels in practice.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-an-edition&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-an-edition&quot;&gt;&lt;/a&gt;What is an Edition?&lt;/h2&gt;
&lt;p&gt;The release of Rust 1.0 established
&lt;a href&#x3D;&quot;https://blog.rust-lang.org/2014/10/30/Stability.html&quot;&gt;&amp;quot;stability without stagnation&amp;quot;&lt;/a&gt;
as a core Rust deliverable.
Ever since the 1.0 release,
the rule for Rust has been that once a feature has been released on stable,
we are committed to supporting that feature for all future releases.&lt;/p&gt;
&lt;p&gt;There are times, however, when it is useful to be able to make small changes
to the language that are not backwards compatible.
The most obvious example is introducing a new keyword,
which would invalidate variables with the same name.
For example, the first version of Rust did not have the &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; keywords.
Suddenly changing those words to keywords in a later version would&#x27;ve broken code like &lt;code&gt;let async &#x3D; 1;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Editions&lt;/strong&gt; are the mechanism we use to solve this problem.
When we want to release a feature that would otherwise be backwards incompatible,
we do so as part of a new Rust &lt;em&gt;edition&lt;/em&gt;.
Editions are opt-in, and so existing crates do
not see these changes until they explicitly migrate over to the new edition.
This means that even the latest version of Rust will still &lt;em&gt;not&lt;/em&gt; treat &lt;code&gt;async&lt;/code&gt; as a keyword,
unless edition 2018 or later is chosen.
This choice is made &lt;em&gt;per crate&lt;/em&gt; &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field&quot;&gt;as part of its &lt;code&gt;Cargo.toml&lt;/code&gt;&lt;/a&gt;.
New crates created by &lt;code&gt;cargo new&lt;/code&gt; are always configured to use the latest stable edition.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#editions-do-not-split-the-ecosystem&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;editions-do-not-split-the-ecosystem&quot;&gt;&lt;/a&gt;Editions do not split the ecosystem&lt;/h3&gt;
&lt;p&gt;The most important rule for editions is that crates in one edition can
interoperate seamlessly with crates compiled in other editions. This ensures
that the decision to migrate to a newer edition is a &amp;quot;private one&amp;quot; that the
crate can make without affecting others.&lt;/p&gt;
&lt;p&gt;The requirement for crate interoperability implies some limits on the kinds of
changes that we can make in an edition.
In general, changes that occur in an edition tend to be &amp;quot;skin deep&amp;quot;.
All Rust code, regardless of edition,
is ultimately compiled to the same internal representation within the compiler.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#edition-migration-is-easy-and-largely-automated&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;edition-migration-is-easy-and-largely-automated&quot;&gt;&lt;/a&gt;Edition migration is easy and largely automated&lt;/h3&gt;
&lt;p&gt;Our goal is to make it easy for crates to upgrade to a new edition.
When we release a new edition,
we also provide &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/commands/cargo-fix.html&quot;&gt;tooling to automate the migration&lt;/a&gt;.
It makes minor changes to your code necessary to make it compatible with the new edition.
For example, when migrating to Rust 2018, it changes anything named &lt;code&gt;async&lt;/code&gt; to use the equivalent
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html&quot;&gt;raw identifier syntax&lt;/a&gt;: &lt;code&gt;r#async&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The automated migrations are not necessarily perfect:
there might be some corner cases where manual changes are still required.
The tooling tries hard to avoid changes
to semantics that could affect the correctness or performance of the code.&lt;/p&gt;
&lt;p&gt;In addition to tooling, we also maintain an Edition Migration Guide that covers
the changes that are part of an edition.
This guide will describe the change and give pointers to where people can learn more about it.
It will also cover any corner cases or details that people should be aware of.
The guide serves both as an overview of the edition,
but also as a quick troubleshooting reference
if people encounter problems with the automated tooling.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-changes-are-planned-for-rust-2021&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-changes-are-planned-for-rust-2021&quot;&gt;&lt;/a&gt;What changes are planned for Rust 2021?&lt;/h2&gt;
&lt;p&gt;Over the last few months, the Rust 2021 Working Group has
gone through a number of proposals for what to include in the new edition.
We are happy to announce the final list of edition changes.
Each feature had to meet two criteria to make this list.
First, they had to be approved by the appropriate Rust team(s).
Second, their implementation had to be far enough along that we had
confidence that they would be completed in time for the planned milestones.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#additions-to-the-prelude&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;additions-to-the-prelude&quot;&gt;&lt;/a&gt;Additions to the prelude&lt;/h3&gt;
&lt;p&gt;The &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/prelude/index.html&quot;&gt;prelude of the standard library&lt;/a&gt;
is the module containing everything that is automatically imported in every module.
It contains commonly used items such as &lt;code&gt;Option&lt;/code&gt;, &lt;code&gt;Vec&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, and &lt;code&gt;Clone&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Rust compiler prioritizes any manually imported items over those
from the prelude, to make sure additions to the prelude will not break any existing code.
For example, if you have a crate or module called &lt;code&gt;example&lt;/code&gt; containing a &lt;code&gt;pub struct Option;&lt;/code&gt;,
then &lt;code&gt;use example::*;&lt;/code&gt; will make &lt;code&gt;Option&lt;/code&gt; unambiguously refer to the one from &lt;code&gt;example&lt;/code&gt;;
not the one from the standard library.&lt;/p&gt;
&lt;p&gt;However, adding a &lt;em&gt;trait&lt;/em&gt; to the prelude can break existing code in a subtle way.
A call to &lt;code&gt;x.try_into()&lt;/code&gt; using a &lt;code&gt;MyTryInto&lt;/code&gt; trait might become ambiguous and
fail to compile if &lt;code&gt;std&lt;/code&gt;&#x27;s &lt;code&gt;TryInto&lt;/code&gt; is also imported,
since it provides a method with the same name.
This is the reason we haven&#x27;t added &lt;code&gt;TryInto&lt;/code&gt; to the prelude yet,
since there is a lot of code that would break this way.&lt;/p&gt;
&lt;p&gt;As a solution, Rust 2021 will use a new prelude.
It&#x27;s identical to the current one, except for three new additions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html&quot;&gt;&lt;code&gt;std::convert::TryInto&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html&quot;&gt;&lt;code&gt;std::convert::TryFrom&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html&quot;&gt;&lt;code&gt;std::iter::FromIterator&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#default-cargo-feature-resolver&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;default-cargo-feature-resolver&quot;&gt;&lt;/a&gt;Default Cargo feature resolver&lt;/h3&gt;
&lt;p&gt;Since Rust 1.51.0, Cargo has opt-in support for a &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/resolver.html#feature-resolver-version-2&quot;&gt;new feature resolver&lt;/a&gt;
which can be activated with &lt;code&gt;resolver &#x3D; &amp;quot;2&amp;quot;&lt;/code&gt; in &lt;code&gt;Cargo.toml&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Starting in Rust 2021, this will be the default.
That is, writing &lt;code&gt;edition &#x3D; &amp;quot;2021&amp;quot;&lt;/code&gt; in &lt;code&gt;Cargo.toml&lt;/code&gt; will imply &lt;code&gt;resolver &#x3D; &amp;quot;2&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The new feature resolver no longer merges all requested features for
crates that are depended on in multiple ways.
See &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-resolver&quot;&gt;the announcement of Rust 1.51&lt;/a&gt; for details.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#intoiterator-for-arrays&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;intoiterator-for-arrays&quot;&gt;&lt;/a&gt;IntoIterator for arrays&lt;/h3&gt;
&lt;p&gt;Until Rust 1.53, only &lt;em&gt;references&lt;/em&gt; to arrays implement &lt;code&gt;IntoIterator&lt;/code&gt;.
This means you can iterate over &lt;code&gt;&amp;amp;[1, 2, 3]&lt;/code&gt; and &lt;code&gt;&amp;amp;mut [1, 2, 3]&lt;/code&gt;,
but not over &lt;code&gt;[1, 2, 3]&lt;/code&gt; directly.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;for &amp;amp;e in &amp;amp;[1, 2, 3] {} // Ok :)

for e in [1, 2, 3] {} // Error :(
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This has been &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/25725&quot;&gt;a long-standing issue&lt;/a&gt;, but the solution is not as simple as it seems.
Just &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/65819&quot;&gt;adding the trait implementation&lt;/a&gt; would break existing code.
&lt;code&gt;array.into_iter()&lt;/code&gt; already compiles today because that implicitly calls
&lt;code&gt;(&amp;amp;array).into_iter()&lt;/code&gt; due to &lt;a href&#x3D;&quot;https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator&quot;&gt;how method call syntax works&lt;/a&gt;.
Adding the trait implementation would change the meaning.&lt;/p&gt;
&lt;p&gt;Usually we categorize this type of breakage
(adding a trait implementation) &#x27;minor&#x27; and acceptable.
But in this case there is too much code that would be broken by it.&lt;/p&gt;
&lt;p&gt;It has been suggested many times to &amp;quot;only implement &lt;code&gt;IntoIterator&lt;/code&gt; for arrays in Rust 2021&amp;quot;.
However, this is simply not possible.
You can&#x27;t have a trait implementation exist in one edition and not in another,
since editions can be mixed.&lt;/p&gt;
&lt;p&gt;Instead, we decided to add the trait implementation in &lt;em&gt;all&lt;/em&gt; editions (starting in Rust 1.53.0),
but add a small hack to avoid breakage until Rust 2021.
In Rust 2015 and 2018 code, the compiler will still resolve &lt;code&gt;array.into_iter()&lt;/code&gt;
to &lt;code&gt;(&amp;amp;array).into_iter()&lt;/code&gt; like before, as if the trait implementation does not exist.
This &lt;em&gt;only&lt;/em&gt; applies to the &lt;code&gt;.into_iter()&lt;/code&gt; method call syntax.
It does not affect any other syntax such as &lt;code&gt;for e in [1, 2, 3]&lt;/code&gt;, &lt;code&gt;iter.zip([1, 2, 3])&lt;/code&gt; or
&lt;code&gt;IntoIterator::into_iter([1, 2, 3])&lt;/code&gt;.
Those will start to work in &lt;em&gt;all&lt;/em&gt; editions.&lt;/p&gt;
&lt;p&gt;While it&#x27;s a shame that this required a small hack to avoid breakage,
we&#x27;re very happy with how this solution keeps the difference between
the editions to an absolute minimum.
Since the hack is only present in the older editions,
there is no added complexity in the new edition.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#disjoint-capture-in-closures&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;disjoint-capture-in-closures&quot;&gt;&lt;/a&gt;Disjoint capture in closures&lt;/h3&gt;
&lt;p&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/book/ch13-01-closures.html&quot;&gt;Closures&lt;/a&gt;
automatically capture anything that you refer to from within their body.
For example, &lt;code&gt;|| a + 1&lt;/code&gt; automatically captures a reference to &lt;code&gt;a&lt;/code&gt; from the surrounding context.&lt;/p&gt;
&lt;p&gt;Currently, this applies to whole structs, even when only using one field.
For example, &lt;code&gt;|| a.x + 1&lt;/code&gt; captures a reference to &lt;code&gt;a&lt;/code&gt; and not just &lt;code&gt;a.x&lt;/code&gt;.
In some situations, this is a problem.
When a field of the struct is already borrowed (mutably) or moved out of,
the other fields can no longer be used in a closure,
since that would capture the whole struct, which is no longer available.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let a &#x3D; SomeStruct::new();

drop(a.x); // Move out of one field of the struct

println!(&amp;quot;{}&amp;quot;, a.y); // Ok: Still use another field of the struct

let c &#x3D; || println!(&amp;quot;{}&amp;quot;, a.y); // Error: Tries to capture all of &#x60;a&#x60;
c();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Starting in Rust 2021, closures will only capture the fields that they use.
So, the above example will compile fine in Rust 2021.&lt;/p&gt;
&lt;p&gt;This new behavior is only activated in the new edition,
since it can change the order in which fields are dropped.
As for all edition changes, an automatic migration is available,
which will update your closures for which this matters.
It can insert &lt;code&gt;let _ &#x3D; &amp;amp;a;&lt;/code&gt; inside the closure to force the entire
struct to be captured as before.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#panic-macro-consistency&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;panic-macro-consistency&quot;&gt;&lt;/a&gt;Panic macro consistency&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;panic!()&lt;/code&gt; macro is one of Rust&#x27;s most well known macros.
However, it has &lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/blob/master/text/3007-panic-plan.md&quot;&gt;some subtle surprises&lt;/a&gt;
that we can&#x27;t just change due to backwards compatibility.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;panic!(&amp;quot;{}&amp;quot;, 1); // Ok, panics with the message &amp;quot;1&amp;quot;
panic!(&amp;quot;{}&amp;quot;); // Ok, panics with the message &amp;quot;{}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;panic!()&lt;/code&gt; macro only uses string formatting when it&#x27;s invoked with more than one argument.
When invoked with a single argument, it doesn&#x27;t even look at that argument.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-rust&quot;&gt;let a &#x3D; &amp;quot;{&amp;quot;;
println!(a); // Error: First argument must be a format string literal
panic!(a); // Ok: The panic macro doesn&#x27;t care
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(It even accepts non-strings such as &lt;code&gt;panic!(123)&lt;/code&gt;, which is uncommon and rarely useful.)&lt;/p&gt;
&lt;p&gt;This will especially be a problem once
&lt;a href&#x3D;&quot;https://rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html&quot;&gt;implicit format arguments&lt;/a&gt;
are stabilized.
That feature will make &lt;code&gt;println!(&amp;quot;hello {name}&amp;quot;)&lt;/code&gt; a short-hand for &lt;code&gt;println!(&amp;quot;hello {}&amp;quot;, name)&lt;/code&gt;.
However, &lt;code&gt;panic!(&amp;quot;hello {name}&amp;quot;)&lt;/code&gt; would not work as expected,
since &lt;code&gt;panic!()&lt;/code&gt; doesn&#x27;t process a single argument as format string.&lt;/p&gt;
&lt;p&gt;To avoid that confusing situation, Rust 2021 features a more consistent &lt;code&gt;panic!()&lt;/code&gt; macro.
The new &lt;code&gt;panic!()&lt;/code&gt; macro will no longer accept arbitrary expressions as the only argument.
It will, just like &lt;code&gt;println!()&lt;/code&gt;, always process the first argument as format string.
Since &lt;code&gt;panic!()&lt;/code&gt; will no longer accept arbitrary payloads,
&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/panic/fn.panic_any.html&quot;&gt;&lt;code&gt;panic_any()&lt;/code&gt;&lt;/a&gt;
will be the only way to panic with something other than a formatted string.&lt;/p&gt;
&lt;p&gt;In addition, &lt;code&gt;core::panic!()&lt;/code&gt; and &lt;code&gt;std::panic!()&lt;/code&gt; will be identical in Rust 2021.
Currently, there are some historical differences between those two,
which can be noticable when switching &lt;code&gt;#![no_std]&lt;/code&gt; on or off.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#reserving-syntax&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;reserving-syntax&quot;&gt;&lt;/a&gt;Reserving syntax&lt;/h3&gt;
&lt;p&gt;To make space for some new syntax in the future,
we&#x27;ve decided to reserve syntax for prefixed identifiers and literals:
&lt;code&gt;prefix#identifier&lt;/code&gt;, &lt;code&gt;prefix&amp;quot;string&amp;quot;&lt;/code&gt;, &lt;code&gt;prefix&#x27;c&#x27;&lt;/code&gt;, and &lt;code&gt;prefix#123&lt;/code&gt;,
where &lt;code&gt;prefix&lt;/code&gt; can be any identifier.
(Except those that already have a meaning, such as &lt;code&gt;b&#x27;‚Ä¶&#x27;&lt;/code&gt; and &lt;code&gt;r&amp;quot;‚Ä¶&amp;quot;&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;This is a breaking change, since macros can currently accept &lt;code&gt;hello&amp;quot;world&amp;quot;&lt;/code&gt;,
which they will see as two separate tokens: &lt;code&gt;hello&lt;/code&gt; and &lt;code&gt;&amp;quot;world&amp;quot;&lt;/code&gt;.
The (automatic) fix is simple though. Just insert a space: &lt;code&gt;hello &amp;quot;world&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;!--
The original plan was to reserve only &#x60;k#&#x60; and &#x60;f&quot;&quot;&#x60; for future use,
but reserving *all* possible prefixes did not have many downsides.
It leaves more space for new syntax which would otherwise need to wait for another edition.
--&gt;
&lt;p&gt;Other than turning these into a tokenization error,
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rfcs/pull/3101&quot;&gt;the RFC&lt;/a&gt; does not attach a meaning to any prefix yet.
Assigning meaning to specific prefixes is left to future proposals,
which will‚Äîthanks to reserving these prefixes now‚Äînot be breaking changes.&lt;/p&gt;
&lt;p&gt;These are some new prefixes you might see in the future:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;f&amp;quot;&amp;quot;&lt;/code&gt; as a short-hand for a format string.
For example, &lt;code&gt;f&amp;quot;hello {name}&amp;quot;&lt;/code&gt; as a short-hand for the equivalent &lt;code&gt;format_args!()&lt;/code&gt; invocation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;c&amp;quot;&amp;quot;&lt;/code&gt; or &lt;code&gt;z&amp;quot;&amp;quot;&lt;/code&gt; for null-terminated C strings.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;k#keyword&lt;/code&gt; to allow writing keywords that don&#x27;t exist yet in the current edition.
For example, while &lt;code&gt;async&lt;/code&gt; is not a keyword in edition 2015,
this prefix would&#x27;ve allowed us to accept &lt;code&gt;k#async&lt;/code&gt; as an alternative in edition 2015
while we waited for edition 2018 to reserve &lt;code&gt;async&lt;/code&gt; as a keyword.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#promoting-two-warnings-to-hard-errors&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;promoting-two-warnings-to-hard-errors&quot;&gt;&lt;/a&gt;Promoting two warnings to hard errors&lt;/h3&gt;
&lt;p&gt;Two existing lints are becoming hard errors in Rust 2021.
These lints will remain warnings in older editions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bare-trait-objects&lt;/code&gt;:
The use of the &lt;code&gt;dyn&lt;/code&gt; keyword to identify &lt;a href&#x3D;&quot;https://doc.rust-lang.org/book/ch17-02-trait-objects.html&quot;&gt;trait objects&lt;/a&gt;
will be mandatory in Rust 2021.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ellipsis-inclusive-range-patterns&lt;/code&gt;:
The &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/reference/patterns.html#range-patterns&quot;&gt;deprecated &lt;code&gt;...&lt;/code&gt; syntax&lt;/a&gt;
for inclusive range patterns is no longer accepted in Rust 2021.
It has been superseded by &lt;code&gt;..&#x3D;&lt;/code&gt;, which is consistent with expressions.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#or-patterns-in-macro_rules&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;or-patterns-in-macro_rules&quot;&gt;&lt;/a&gt;Or patterns in macro_rules&lt;/h3&gt;
&lt;p&gt;Starting in Rust 1.53.0, &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/reference/patterns.html&quot;&gt;patterns&lt;/a&gt;
are extended to support &lt;code&gt;|&lt;/code&gt; nested anywhere in the pattern.
This enables you to write &lt;code&gt;Some(1 | 2)&lt;/code&gt; instead of &lt;code&gt;Some(1) | Some(2)&lt;/code&gt;.
Since this was simply not allowed before, this is not a breaking change.&lt;/p&gt;
&lt;p&gt;However, this change also affects &lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/reference/macros-by-example.html&quot;&gt;&lt;code&gt;macro_rules&lt;/code&gt; macros&lt;/a&gt;.
Such macros can accept patterns using the &lt;code&gt;:pat&lt;/code&gt; fragment specifier.
Currently, &lt;code&gt;:pat&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; match &lt;code&gt;|&lt;/code&gt;, since before Rust 1.53,
not all patterns (at all nested levels) could contain a &lt;code&gt;|&lt;/code&gt;.
Macros that accept patterns like &lt;code&gt;A | B&lt;/code&gt;,
such as &lt;a href&#x3D;&quot;https://doc.rust-lang.org/1.51.0/std/macro.matches.html&quot;&gt;&lt;code&gt;matches!()&lt;/code&gt;&lt;/a&gt;
use something like &lt;code&gt;$($_:pat)|+&lt;/code&gt;.
Because we don&#x27;t want to break any existing macros,
we did &lt;em&gt;not&lt;/em&gt; change the meaning of &lt;code&gt;:pat&lt;/code&gt; in Rust 1.53.0 to include &lt;code&gt;|&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Instead, we will make that change as part of Rust 2021.
In the new edition, the &lt;code&gt;:pat&lt;/code&gt; fragment specifier &lt;em&gt;will&lt;/em&gt; match &lt;code&gt;A | B&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since there are times that one still wishes to match a single pattern
variant without &lt;code&gt;|&lt;/code&gt;, the fragment specified &lt;code&gt;:pat_param&lt;/code&gt; has been added
to retain the older behavior.
The name refers to its main use case: a pattern in a closure parameter.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-comes-next&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-comes-next&quot;&gt;&lt;/a&gt;What comes next?&lt;/h2&gt;
&lt;p&gt;Our plan is to have these changes merged and fully tested by September,
to make sure the 2021 edition makes it into Rust 1.56.0.
Rust 1.56.0 will then be in beta for six weeks,
after which it is released as stable on October 21st.&lt;/p&gt;
&lt;p&gt;However, note that Rust is a project run by volunteers.
We prioritize the personal well-being of everyone working on Rust
over any deadlines and expectations we might have set.
This could mean delaying the edition a version if necessary,
or dropping a feature that turns out to be too difficult or stressful to finish in time.&lt;/p&gt;
&lt;p&gt;That said, we are on schedule and many of the difficult problems are already tackled,
thanks to all the people contributing to Rust 2021! üíõ&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;You can expect another announcement about the new edition in July.
At that point we expect all changes and automatic migrations to be implemented
and ready for public testing.&lt;/p&gt;
&lt;p&gt;We&#x27;ll be posting some more details about the process and rejected proposals on
the &amp;quot;Inside Rust&amp;quot; blog soon. (&lt;em&gt;Correction: This did not end up happening due
to lack of bandwidth&lt;/em&gt;)&lt;/p&gt;
&lt;!--
If you really can&#x27;t wait, many features are already available on
Rust [Nightly](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html)
with &#x60;-Zunstable-options --edition&#x3D;2021&#x60;.
--&gt;
</content>

        <author>
            <name>Mara Bos</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.52.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/05/10/Rust-1.52.1.html" type="text/html" title="Announcing Rust 1.52.1" />
        <published>2021-05-10T00:00:00+00:00</published>
        <updated>2021-05-10T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/05/10/Rust-1.52.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/05/10/Rust-1.52.1.html">&lt;p&gt;The Rust team has prepared a new release, 1.52.1, working around a bug in
incremental compilation which was made into a compiler error in 1.52.0. We
recommend all Rust users, including those currently using stable versions prior
to 1.52.0, upgrade to 1.52.1 or disable incremental compilation. Guidance on how
to do so is available below.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.52.1 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website.&lt;/p&gt;
&lt;h1&gt;&lt;a href&#x3D;&quot;#summary&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;summary&quot;&gt;&lt;/a&gt;Summary&lt;/h1&gt;
&lt;p&gt;This release works around broken builds on 1.52.0, which are caused by newly
added verification. The bugs this verification detects are present in all Rust
versions&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, and can trigger miscompilations in incremental builds, so downgrading
to a prior stable version is not a fix.&lt;/p&gt;
&lt;p&gt;Users are encouraged to upgrade to 1.52.1 or disable incremental in their local
environment if on a prior version: please see the &lt;a href&#x3D;&quot;#what-should-a-rust-programmer-do-in-response&quot;&gt;what you should do&lt;/a&gt;
section for details on how to do so.&lt;/p&gt;
&lt;p&gt;Incremental compilation is off by default for release builds, so few
production builds should be affected (only for users who have opted in).&lt;/p&gt;
&lt;p&gt;Miscompilations that can arise from the bugs in incremental compilation generate incorrect code in final
artifacts, essentially producing malformed binaries, which means that in theory
any behavior is possible. In practice we are currently only aware of one
particular known miscompilation, but bugs due to incremental are notoriously
hard to track down: users frequently simply rebuild after some light editing if
they see unexpected results from their binaries, and this often causes
sufficient recompilation to fix the bug(s).&lt;/p&gt;
&lt;p&gt;This post is going to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Explain &lt;a href&#x3D;&quot;#what-does-the-error-look-like&quot;&gt;what the errors look like&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;Explain &lt;a href&#x3D;&quot;#what-are-fingerprints-why-are-we-checking-them&quot;&gt;what the check does&lt;/a&gt;, at a high level,&lt;/li&gt;
&lt;li&gt;Explain &lt;a href&#x3D;&quot;#how-does-this-show-up&quot;&gt;how the check is presenting itself&lt;/a&gt; in the Rust 1.52.0 release,&lt;/li&gt;
&lt;li&gt;Tell you &lt;a href&#x3D;&quot;#what-should-a-rust-programmer-do-in-response&quot;&gt;what you should do&lt;/a&gt; if you see an unstable fingerprint on your project,&lt;/li&gt;
&lt;li&gt;Describe our plans for &lt;a href&#x3D;&quot;#what-is-the-rust-project-going-to-do-to-fix-this&quot;&gt;how the Rust project will address&lt;/a&gt; the problems discussed here.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-does-the-error-look-like&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-does-the-error-look-like&quot;&gt;&lt;/a&gt;What does the error look like?&lt;/h2&gt;
&lt;p&gt;The error message looks something like this, with the key piece being the &amp;quot;found
unstable fingerprints&amp;quot; text.&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;thread &#x27;rustc&#x27; panicked at &#x27;assertion failed: &#x60;(left &#x3D;&#x3D; right)&#x60;
  left: &#x60;Some(Fingerprint(4565771098143344972, 7869445775526300234))&#x60;,
  right: &#x60;Some(Fingerprint(14934403843752251060, 623484215826468126))&#x60;: found unstable fingerprints for &amp;lt;massive text describing rustc internals elided&amp;gt;

error: internal compiler error: unexpected panic

note: the compiler unexpectedly panicked. this is a bug.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the error caused by the internal consistency check, and as stated in the diagnostic, it yields an &amp;quot;Internal Compiler Error&amp;quot; (or ICE). In other words, it represents a bug in the internals of the Rust compiler itself. In &lt;em&gt;this&lt;/em&gt; case, the ICE is revealing a bug in incremental compilation that predates the 1.52.0 release and could result in miscompilation if it had not been caught.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-are-fingerprints-why-are-we-checking-them&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-are-fingerprints-why-are-we-checking-them&quot;&gt;&lt;/a&gt;What are fingerprints? Why are we checking them?&lt;/h2&gt;
&lt;p&gt;The Rust compiler has support for &amp;quot;incremental compilation&amp;quot;, which has been described in a &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2016/09/08/incremental.html&quot;&gt;2016 blog post&lt;/a&gt;. When incremental compilation is turned on, the compiler breaks the input source into pieces, and tracks how those input pieces influence the final build product. Then, when the inputs change, it detects this and reuses artifacts from previous builds, striving to expend effort solely on building the parts that need to respond to the changes to the input source code.&lt;/p&gt;
&lt;p&gt;Fingerprints are part of our architecture for detecting when inputs change. More specifically, a fingerprint (along with some other state to establish context) is a 128-bit value intended to uniquely identify internal values used within the compiler. Some compiler-internal results are stored on disk (&amp;quot;cached&amp;quot;) between runs. Fingerprints are used to validate that a newly computed result is unchanged from the cached result. (More details about this are available in the &lt;a href&#x3D;&quot;https://rustc-dev-guide.rust-lang.org/queries/incremental-compilation-in-detail.html#checking-query-results-for-changes-hashstable-and-fingerprints&quot;&gt;relevant chapter of the rustc dev guide&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;The fingerprint stability check is a safeguard asserting internal consistency of
the fingerprints. Sometimes the compiler is forced to rerun a query, and expects
that the output is the same as from a prior incremental compilation session. The
newly enabled verification checks that the value is indeed as expected, rather
than assuming so. In some cases, due to bugs in the compiler&#x27;s implementation,
this was not actually the case.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#history&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;history&quot;&gt;&lt;/a&gt;History&lt;/h2&gt;
&lt;p&gt;We &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/45867&quot;&gt;initially added&lt;/a&gt; these fingerprint checks as a tool to use when
developing rustc itself, back in 2017. It was solely provided via an unstable
&lt;code&gt;-Z&lt;/code&gt; flag, only available to nightly and development builds.&lt;/p&gt;
&lt;p&gt;More recently, in March, we encountered a &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/82920&quot;&gt;miscompilation&lt;/a&gt; that led us to &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/pull/83007&quot;&gt;turn on &lt;code&gt;verify-ich&lt;/code&gt; by default&lt;/a&gt;. The Rust compiler team decided it was better to catch fingerprint problems and abort compilation, rather than allow for potential miscompilations (and subsequent misbehavior) to sneak into Rust programmer&#x27;s binaries.&lt;/p&gt;
&lt;p&gt;When we first turned on the fingerprint checks by default, there was a steady
stream of issues filed by users of the nightly (and beta) toolchains, and steady
progress has been made on identifying fixes, a number of which have already
landed.&lt;/p&gt;
&lt;p&gt;In the past week, we had started &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/84970&quot;&gt;making plans&lt;/a&gt; to improve the
user-experience, so that the diagnostic issued by the check would do a better
job of telling the programmer what to do in response. Unfortunately, this was
done under the assumption that the new verification would ship in 1.53, not
1.52.&lt;/p&gt;
&lt;p&gt;It turns out &lt;code&gt;verify-ich&lt;/code&gt; was turned on in version 1.52.0, which was &lt;a href&#x3D;&quot;/2021/05/06/Rust-1.52.0.html&quot;&gt;released recently&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Today&#x27;s new release, 1.52.1, works around the breakage caused by the newly added
verification by temporarily changing the defaults in the Rust compiler to disable
incremental unless the user knowingly opts in.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#how-does-this-show-up&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;how-does-this-show-up&quot;&gt;&lt;/a&gt;How does this show up&lt;/h2&gt;
&lt;p&gt;Essentially, for some crates, certain sequences of edit-compile cycles will cause &lt;code&gt;rustc&lt;/code&gt; to hit the &amp;quot;unstable fingerprints&amp;quot; ICE. I showed one example at the start of this blog post.&lt;/p&gt;
&lt;p&gt;Another recent example looks &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/85039&quot;&gt;like this&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-text&quot;&gt;thread &#x27;rustc&#x27; panicked at &#x27;found unstable fingerprints for predicates_of(&amp;lt;massive text describing rustc internals elided&amp;gt;)&#x27;, /rustc/.../compiler/rustc_query_system/src/query/plumbing.rs:593:5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;They all arise from inconsistencies when comparing the incremental-compilation cache stored on disk against the values computed during a current &lt;code&gt;rustc&lt;/code&gt; invocation, which means they all arise from using incremental compilation.&lt;/p&gt;
&lt;p&gt;There are several ways that you may have incremental compilation turned on:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;You may be building with the &lt;code&gt;dev&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/profiles.html&quot;&gt;profiles&lt;/a&gt; which default to having incremental compilation enabled.&lt;/li&gt;
&lt;li&gt;You may have set the &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-reads&quot;&gt;environment variable&lt;/a&gt; &lt;code&gt;CARGO_INCREMENTAL&#x3D;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;You may have enabled the &lt;code&gt;build.incremental&lt;/code&gt; &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/config.html#buildincremental&quot;&gt;setting in your Cargo config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;You may have enabled the &lt;code&gt;incremental&lt;/code&gt; &lt;a href&#x3D;&quot;https://doc.rust-lang.org/cargo/reference/profiles.html#incremental&quot;&gt;setting in your Cargo.toml&lt;/a&gt; for a given profile&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If your project has not adjusted the defaults, then when running &lt;code&gt;cargo build --release&lt;/code&gt; or otherwise in the &lt;code&gt;release&lt;/code&gt; profile configuration incremental is
disabled on all Rust versions&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, and these issues should not affect your release
builds.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-should-a-rust-programmer-do-in-response&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-should-a-rust-programmer-do-in-response&quot;&gt;&lt;/a&gt;What should a Rust programmer do in response&lt;/h2&gt;
&lt;p&gt;The Internal Compiler Error asks you to report a bug, and if you can do so, we still want that information. We &lt;em&gt;want&lt;/em&gt; to know about the cases that are failing.&lt;/p&gt;
&lt;p&gt;But regardless of whether or not you file a bug, the problem can be worked around on your end by either:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;upgrading to 1.52.1, if you have not yet done so (which will disable
incremental for you), or&lt;/li&gt;
&lt;li&gt;deleting your incremental compilation cache (e.g. by running &lt;code&gt;cargo clean&lt;/code&gt;), or&lt;/li&gt;
&lt;li&gt;forcing incremental compilation to be disabled, by setting &lt;code&gt;CARGO_INCREMENTAL&#x3D;0&lt;/code&gt; in your environment or &lt;code&gt;build.incremental&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in the &lt;code&gt;config.toml&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We recommend that users of 1.52.0 upgrade to 1.52.1, which disables incremental
compilation.&lt;/p&gt;
&lt;p&gt;We do &lt;em&gt;not&lt;/em&gt; recommend that users of 1.52.0 downgrade to an earlier version of Rust in response to this problem. As noted above, there is at least one instance of a silent &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues/82920&quot;&gt;miscompilation&lt;/a&gt; caused by incremental compilation that was not caught until we added the fingerprint checking.&lt;/p&gt;
&lt;p&gt;If a user is willing to deal with the incremental verification ICE&#x27;s, and wishes
to opt back into the 1.52.0 behavior, they may set &lt;code&gt;RUSTC_FORCE_INCREMENTAL&lt;/code&gt; to
&lt;code&gt;1&lt;/code&gt; in their environment. The Rust compiler will then respect the
&lt;code&gt;-Cincremental&lt;/code&gt; option passed by Cargo, and things will work as before, though
with the added verification. Note that this flag does not enable incremental if
it has not already been separately enabled (whether by Cargo or otherwise).&lt;/p&gt;
&lt;p&gt;If you are currently using a toolchain prior to 1.52.0, and wish to continue
doing so, we recommend that you disable incremental compilation to avoid hitting
silent miscompilations.&lt;/p&gt;
&lt;p&gt;On all Rust builds since incremental has landed, it has been a major
improvement to compile times for many users, and has only improved over time. We
acknowledge that the workarounds presented here and recommendations are painful,
and will be working hard to ensure the situation is as temporary as possible.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#what-is-the-rust-project-going-to-do-to-fix-this&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-the-rust-project-going-to-do-to-fix-this&quot;&gt;&lt;/a&gt;What is the Rust project going to do to fix this&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#short-term-plan&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;short-term-plan&quot;&gt;&lt;/a&gt;Short-term plan&lt;/h3&gt;
&lt;p&gt;We have issued 1.52.1 today which:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disables incremental compilation in the Rust compiler (unless asked for by a
new environment variable, &lt;code&gt;RUSTC_FORCE_INCREMENTAL&#x3D;1&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Improves diagnostic output for the new verification if incremental compilation is enabled,
indicating how to work around the bugs by purging incremental state or
disabling incremental.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is intended to be a mitigation that helps the majority of Rust users have
an upgrade path to a safe Rust compiler which does not have the risk of
miscompiling their code, but also provide the option for users willing to deal
with the errors to do so.&lt;/p&gt;
&lt;p&gt;We expect to continue to actively invest in fixing the bugs, and depending on
our confidence in the fixes, may issue a 1.52.2 point release which backports
those fixes to the stable channel. Users wishing to help us test can use the
nightly channel, and report bugs to rust-lang/rust with any ICEs they
are seeing.&lt;/p&gt;
&lt;p&gt;We are also currently not planning to disable incremental on the beta channel,
but this decision has not been firmly committed to. A number of fixes are
available on 1.53 beta today, so users who wish to continue using incremental
may want to switch to that. Nightly will always have the latest in fixes, of
course.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#long-term-plan&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;long-term-plan&quot;&gt;&lt;/a&gt;Long-term plan&lt;/h3&gt;
&lt;p&gt;The long-term plan is to fix the bugs! Incremental compilation is the only realistic way for the Rust compiler to be able to provide a fast edit-compile-run cycle for all of its programmers, and so we need to address &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/issues?q&#x3D;is%3Aissue+is%3Aopen+unstable+fingerprints&quot;&gt;all of the issues&lt;/a&gt; that have been identified thus far via &lt;code&gt;verify-ich&lt;/code&gt;. (There are 32 such issues as of this writing, though many are duplicates.)&lt;/p&gt;
&lt;p&gt;We are actively investing in this, and a number of bugs have already been
identified and fixed. Depending on the state of the fixes, future stable
releases (1.53 and onwards) will likely re-enable incremental compilation.&lt;/p&gt;
&lt;p&gt;The Rust teams will also be developing plans to ensure we have better tracking
systems in place in the future for bugs, both to prevent situations like this
from arising again, but also to further increase the stability of our releases
by tracking bugs more accurately as they propagate across channels.&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;Since incremental was first enabled, which was in Rust 1.24. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Felix Klock, Mark Rousskov</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rust 1.52.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/05/06/Rust-1.52.0.html" type="text/html" title="Announcing Rust 1.52.0" />
        <published>2021-05-06T00:00:00+00:00</published>
        <updated>2021-05-06T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/05/06/Rust-1.52.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/05/06/Rust-1.52.0.html">&lt;p&gt;The Rust team is happy to announce a new version of Rust, 1.52.0. Rust is a
programming language that is empowering everyone to build reliable and
efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of Rust installed via rustup, getting Rust
1.52.0 is as easy as:&lt;/p&gt;
&lt;pre&gt;&lt;code class&#x3D;&quot;language-console&quot;&gt;rustup update stable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://www.rust-lang.org/install.html&quot;&gt;get &lt;code&gt;rustup&lt;/code&gt;&lt;/a&gt;
from the appropriate page on our website, and check out the
&lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1520-2021-05-06&quot;&gt;detailed release notes for 1.52.0&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-in-1520-stable&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-in-1520-stable&quot;&gt;&lt;/a&gt;What&#x27;s in 1.52.0 stable&lt;/h2&gt;
&lt;p&gt;The most significant change in this release is not to the language or standard
libraries, but rather an enhancement to tooling support for Clippy.&lt;/p&gt;
&lt;p&gt;Previously, running &lt;code&gt;cargo check&lt;/code&gt; followed by &lt;code&gt;cargo clippy&lt;/code&gt; wouldn&#x27;t actually
run Clippy: the build caching in Cargo didn&#x27;t differentiate between the two. In
1.52, however, this has been fixed, which means that users will get the expected
behavior independent of the order in which they run the two commands.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#stabilized-apis&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;stabilized-apis&quot;&gt;&lt;/a&gt;Stabilized APIs&lt;/h3&gt;
&lt;p&gt;The following methods were stabilized.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/fmt/struct.Arguments.html#method.as_str&quot;&gt;&lt;code&gt;Arguments::as_str&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.char.html#associatedconstant.MAX&quot;&gt;&lt;code&gt;char::MAX&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.char.html#associatedconstant.REPLACEMENT_CHARACTER&quot;&gt;&lt;code&gt;char::REPLACEMENT_CHARACTER&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.char.html#associatedconstant.UNICODE_VERSION&quot;&gt;&lt;code&gt;char::UNICODE_VERSION&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.char.html#method.decode_utf16&quot;&gt;&lt;code&gt;char::decode_utf16&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.char.html#method.from_digit&quot;&gt;&lt;code&gt;char::from_digit&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.char.html#method.from_u32_unchecked&quot;&gt;&lt;code&gt;char::from_u32_unchecked&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/std/primitive.char.html#method.from_u32&quot;&gt;&lt;code&gt;char::from_u32&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.slice.html#method.partition_point&quot;&gt;&lt;code&gt;slice::partition_point&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.str.html#method.rsplit_once&quot;&gt;&lt;code&gt;str::rsplit_once&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.str.html#method.split_once&quot;&gt;&lt;code&gt;str::split_once&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following previously stable APIs are now &lt;code&gt;const&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.char.html#method.len_utf8&quot;&gt;&lt;code&gt;char::len_utf8&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.char.html#method.len_utf16&quot;&gt;&lt;code&gt;char::len_utf16&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.char.html#method.to_ascii_uppercase&quot;&gt;&lt;code&gt;char::to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.char.html#method.to_ascii_lowercase&quot;&gt;&lt;code&gt;char::to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.char.html#method.eq_ignore_ascii_case&quot;&gt;&lt;code&gt;char::eq_ignore_ascii_case&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.to_ascii_uppercase&quot;&gt;&lt;code&gt;u8::to_ascii_uppercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.to_ascii_lowercase&quot;&gt;&lt;code&gt;u8::to_ascii_lowercase&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://doc.rust-lang.org/stable/std/primitive.u8.html#method.eq_ignore_ascii_case&quot;&gt;&lt;code&gt;u8::eq_ignore_ascii_case&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are other changes in the Rust 1.52.0 release: check out what changed in &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1520-2021-05-06&quot;&gt;Rust&lt;/a&gt;, &lt;a href&#x3D;&quot;https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-152-2021-05-06&quot;&gt;Cargo&lt;/a&gt;, and &lt;a href&#x3D;&quot;https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-152&quot;&gt;Clippy&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#contributors-to-1520&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;contributors-to-1520&quot;&gt;&lt;/a&gt;Contributors to 1.52.0&lt;/h3&gt;
&lt;p&gt;Many people came together to create Rust 1.52.0. We couldn&#x27;t have done it without all of you. &lt;a href&#x3D;&quot;https://thanks.rust-lang.org/rust/1.52.0/&quot;&gt;Thanks!&lt;/a&gt;&lt;/p&gt;
</content>

        <author>
            <name>The Rust Release Team</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rustup 1.24.1</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/04/29/Rustup-1.24.1.html" type="text/html" title="Announcing Rustup 1.24.1" />
        <published>2021-04-29T00:00:00+00:00</published>
        <updated>2021-04-29T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/04/29/Rustup-1.24.1.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/04/29/Rustup-1.24.1.html">&lt;p&gt;The rustup working group is happy to announce the release of rustup version 1.24.1. &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;Rustup&lt;/a&gt; is the recommended tool to install &lt;a href&#x3D;&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;, a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of rustup installed, getting rustup 1.24.1 is as easy as closing your IDE and running:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rustup will also automatically update itself at the end of a normal toolchain update:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;get rustup&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-new-in-rustup-1241&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-new-in-rustup-1241&quot;&gt;&lt;/a&gt;What&#x27;s new in rustup 1.24.1&lt;/h2&gt;
&lt;p&gt;Firstly, if you have not read the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/04/27/Rustup-1.24.0.html&quot;&gt;previous announcement&lt;/a&gt; then in brief, 1.24
introduces better support for low memory systems, installs itself into the Add/Remove programs
list on Windows, and now supports using &lt;code&gt;rust-toolchain.toml&lt;/code&gt; files.&lt;/p&gt;
&lt;p&gt;Shortly after publishing the 1.24.0 release of Rustup, we got reports of &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustup/issues/2737&quot;&gt;a regression&lt;/a&gt;
preventing users from running &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;cargo fmt&lt;/code&gt; after upgrading to
Rustup 1.24.0. To limit the damage we &lt;strong&gt;reverted&lt;/strong&gt; the release to version
1.23.1. The only substantive change between 1.24.0 and 1.24.1 is to correct this regression.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;You can check out all the changes to Rustup for 1.24.0 and 1.24.1 in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustup/blob/stable/CHANGELOG.md&quot;&gt;changelog&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Rustup&#x27;s documentation is also available in &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/&quot;&gt;the rustup book&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thanks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Thanks again to all the contributors who made rustup 1.24.0 and 1.24.1 possible!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alex Chan&lt;/li&gt;
&lt;li&gt;Alo√Øs Micard&lt;/li&gt;
&lt;li&gt;Andrew Norton&lt;/li&gt;
&lt;li&gt;Avery Harnish&lt;/li&gt;
&lt;li&gt;chansuke&lt;/li&gt;
&lt;li&gt;Daniel Alley&lt;/li&gt;
&lt;li&gt;Daniel Silverstone&lt;/li&gt;
&lt;li&gt;Eduard Miller&lt;/li&gt;
&lt;li&gt;Eric Huss&lt;/li&gt;
&lt;li&gt;est31&lt;/li&gt;
&lt;li&gt;Gareth Hubball&lt;/li&gt;
&lt;li&gt;Gurkenglas&lt;/li&gt;
&lt;li&gt;Jakub Stasiak&lt;/li&gt;
&lt;li&gt;Joshua Nelson&lt;/li&gt;
&lt;li&gt;Jubilee (workingjubilee)&lt;/li&gt;
&lt;li&gt;kellda&lt;/li&gt;
&lt;li&gt;Michael Cooper&lt;/li&gt;
&lt;li&gt;Philipp Oppermann&lt;/li&gt;
&lt;li&gt;Robert Collins&lt;/li&gt;
&lt;li&gt;SHA Miao&lt;/li&gt;
&lt;li&gt;skim (sl4m)&lt;/li&gt;
&lt;li&gt;Tudor Brindus&lt;/li&gt;
&lt;li&gt;Vasili (3point2)&lt;/li&gt;
&lt;li&gt;–Ω–∞–± (nabijaczleweli)&lt;/li&gt;
&lt;li&gt;‰∫åÊâãÊéâÂåÖÂ∑•Á®ãÂ∏à (hi-rustin)&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>The Rustup Working Group</name>
        </author>
    </entry>
    
    <entry>
        <title>Announcing Rustup 1.24.0</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/04/27/Rustup-1.24.0.html" type="text/html" title="Announcing Rustup 1.24.0" />
        <published>2021-04-27T00:00:00+00:00</published>
        <updated>2021-04-27T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/04/27/Rustup-1.24.0.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/04/27/Rustup-1.24.0.html">&lt;blockquote&gt;
&lt;p&gt;Shortly after publishing the release we got reports of &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustup/issues/2737&quot;&gt;a regression&lt;/a&gt;
preventing users from running &lt;code&gt;rustfmt&lt;/code&gt; and &lt;code&gt;cargo fmt&lt;/code&gt; after upgrading to
Rustup 1.24.0. To limit the damage we &lt;strong&gt;reverted&lt;/strong&gt; the release to version
1.23.1.&lt;/p&gt;
&lt;p&gt;If you have been affected by this issue you can revert to version 1.23.1 by
running the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup self update
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;The rustup working group is happy to announce the release of rustup version 1.24.0. &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;Rustup&lt;/a&gt; is the recommended tool to install &lt;a href&#x3D;&quot;https://www.rust-lang.org&quot;&gt;Rust&lt;/a&gt;, a programming language that is empowering everyone to build reliable and efficient software.&lt;/p&gt;
&lt;p&gt;If you have a previous version of rustup installed, getting rustup 1.24.0 is as easy as closing your IDE and running:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup self update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rustup will also automatically update itself at the end of a normal toolchain update:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rustup update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&#x27;t have it already, you can &lt;a href&#x3D;&quot;https://rustup.rs&quot;&gt;get rustup&lt;/a&gt; from the appropriate page on our website.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#whats-new-in-rustup-1240&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;whats-new-in-rustup-1240&quot;&gt;&lt;/a&gt;What&#x27;s new in rustup 1.24.0&lt;/h2&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#support-of-rust-toolchaintoml-as-a-filename-for-specifying-toolchains&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;support-of-rust-toolchaintoml-as-a-filename-for-specifying-toolchains&quot;&gt;&lt;/a&gt;Support of &lt;code&gt;rust-toolchain.toml&lt;/code&gt; as a filename for specifying toolchains.&lt;/h3&gt;
&lt;p&gt;Last year we released a new &lt;code&gt;toml&lt;/code&gt; format for the &lt;code&gt;rust-toolchain&lt;/code&gt; file. In order to bring Rustup closer into line with Cargo&#x27;s behaviour around &lt;code&gt;.cargo/config&lt;/code&gt; we now support the &lt;code&gt;.toml&lt;/code&gt; extension for that file. If you call the toolchain file &lt;code&gt;rust-toolchain.toml&lt;/code&gt; then you &lt;em&gt;must&lt;/em&gt; use the &lt;code&gt;toml&lt;/code&gt; format, rather than the legacy one-line format.&lt;/p&gt;
&lt;p&gt;If both &lt;code&gt;rust-toolchain&lt;/code&gt; and &lt;code&gt;rust-toolchain.toml&lt;/code&gt; are present, then the former will win out over the latter to ensure compatibility between Rustup versions.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#better-support-for-low-memory-systems&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;better-support-for-low-memory-systems&quot;&gt;&lt;/a&gt;Better support for low-memory systems&lt;/h3&gt;
&lt;p&gt;Rustup&#x27;s component unpacker has been changed to have a smaller memory footprint when unpacking large components. This should permit users of memory-constrained systems such as some Raspberry Pi systems to install newer Rust toolchains which contain particularly large files.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#better-support-for-windows-addremove-programs&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;better-support-for-windows-addremove-programs&quot;&gt;&lt;/a&gt;Better support for Windows Add/Remove programs&lt;/h3&gt;
&lt;p&gt;Fresh installations of Rustup on Windows will now install themselves into the program list so that you can trigger the uninstallation of Rustup via the Add/Remove programs dialogs similar to any other Windows program.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;This will only take effect on installation, so you will need to rerun &lt;code&gt;rustup-init.exe&lt;/code&gt; if you want this on your PC.&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#other-changes&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;other-changes&quot;&gt;&lt;/a&gt;Other changes&lt;/h3&gt;
&lt;p&gt;There are more changes in rustup 1.24.0: check them out in the &lt;a href&#x3D;&quot;https://github.com/rust-lang/rustup/blob/stable/CHANGELOG.md&quot;&gt;changelog&lt;/a&gt;!&lt;/p&gt;
&lt;p&gt;Rustup&#x27;s documentation is also available in &lt;a href&#x3D;&quot;https://rust-lang.github.io/rustup/&quot;&gt;the rustup book&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a href&#x3D;&quot;#thanks&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;thanks&quot;&gt;&lt;/a&gt;Thanks&lt;/h2&gt;
&lt;p&gt;Thanks to all the contributors who made rustup 1.24.0 possible!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alex Chan&lt;/li&gt;
&lt;li&gt;Alo√Øs Micard&lt;/li&gt;
&lt;li&gt;Andrew Norton&lt;/li&gt;
&lt;li&gt;Avery Harnish&lt;/li&gt;
&lt;li&gt;chansuke&lt;/li&gt;
&lt;li&gt;Daniel Alley&lt;/li&gt;
&lt;li&gt;Daniel Silverstone&lt;/li&gt;
&lt;li&gt;Eduard Miller&lt;/li&gt;
&lt;li&gt;Eric Huss&lt;/li&gt;
&lt;li&gt;est31&lt;/li&gt;
&lt;li&gt;Gareth Hubball&lt;/li&gt;
&lt;li&gt;Gurkenglas&lt;/li&gt;
&lt;li&gt;Jakub Stasiak&lt;/li&gt;
&lt;li&gt;Joshua Nelson&lt;/li&gt;
&lt;li&gt;Jubilee (workingjubilee)&lt;/li&gt;
&lt;li&gt;kellda&lt;/li&gt;
&lt;li&gt;Michael Cooper&lt;/li&gt;
&lt;li&gt;Philipp Oppermann&lt;/li&gt;
&lt;li&gt;Robert Collins&lt;/li&gt;
&lt;li&gt;SHA Miao&lt;/li&gt;
&lt;li&gt;skim (sl4m)&lt;/li&gt;
&lt;li&gt;Tudor Brindus&lt;/li&gt;
&lt;li&gt;Vasili (3point2)&lt;/li&gt;
&lt;li&gt;–Ω–∞–± (nabijaczleweli)&lt;/li&gt;
&lt;li&gt;‰∫åÊâãÊéâÂåÖÂ∑•Á®ãÂ∏à (hi-rustin)&lt;/li&gt;
&lt;/ul&gt;
</content>

        <author>
            <name>The Rustup Working Group</name>
        </author>
    </entry>
    
    <entry>
        <title>Brainstorming Async Rust&#x27;s Shiny Future</title>
        <link rel="alternate" href="https://blog.rust-lang.org/2021/04/14/async-vision-doc-shiny-future.html" type="text/html" title="Brainstorming Async Rust&#x27;s Shiny Future" />
        <published>2021-04-14T00:00:00+00:00</published>
        <updated>2021-04-14T00:00:00+00:00</updated>
        <id>https://blog.rust-lang.org/2021/04/14/async-vision-doc-shiny-future.html</id>
        <content type="html" xml:base="https://blog.rust-lang.org/2021/04/14/async-vision-doc-shiny-future.html">&lt;p&gt;On March 18th, we &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/03/18/async-vision-doc.html&quot;&gt;announced the start of the Async Vision Doc&lt;/a&gt; process. Since then, we&#x27;ve landed &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/status_quo.html&quot;&gt;24 &amp;quot;status quo&amp;quot; stories&lt;/a&gt; and we have &lt;a href&#x3D;&quot;https://github.com/rust-lang/wg-async-foundations/pulls&quot;&gt;4 more stories in open PRs&lt;/a&gt;; &lt;a href&#x3D;&quot;https://twitter.com/ryan_levick/&quot;&gt;Ryan Levick&lt;/a&gt; and &lt;a href&#x3D;&quot;https://twitter.com/nikomatsakis/&quot;&gt;I&lt;/a&gt; have also hosted more than ten collaborative writing sessions over the course of the last few weeks, and we have &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2021/04/12/async-vision-doc-writing-sessions-v/&quot;&gt;more scheduled for this week&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now that we have a good base of &amp;quot;status quo&amp;quot; stories, we are starting to imagine what the &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/shiny_future.html&quot;&gt;‚ú® &amp;quot;shiny future&amp;quot; ‚ú®&lt;/a&gt; might look like. &lt;strong&gt;We want your help!&lt;/strong&gt; If you have a great idea for Async Rust&lt;sup class&#x3D;&quot;footnote-ref&quot;&gt;&lt;a href&#x3D;&quot;#fn1&quot; id&#x3D;&quot;fnref1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, then &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/shiny_future/template.html&quot;&gt;take a look at the template and open a PR&lt;/a&gt;! Alternatively, if you have an idea for a story but would like to discuss it before writing, you can &lt;a href&#x3D;&quot;https://github.com/rust-lang/wg-async-foundations/issues/new/choose&quot;&gt;open a &amp;quot;shiny future&amp;quot; issue&lt;/a&gt;. Also, we would still love to get more &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/status_quo.html&quot;&gt;&amp;quot;status quo&amp;quot; stories&lt;/a&gt;, so please continue to share those.&lt;/p&gt;
&lt;p&gt;When writing &amp;quot;shiny future&amp;quot; stories, the goal is to focus on the &lt;strong&gt;experience&lt;/strong&gt; of Rust&#x27;s users first and foremost, and not so much on the specific technical details. In fact, you don&#x27;t even have to know exactly how the experience will be achieved. We have a few years to figure that out, after all. üöÄ&lt;/p&gt;
&lt;p&gt;Every &amp;quot;shiny future&amp;quot; story is a &amp;quot;retelling&amp;quot; of one or more &amp;quot;status quo&amp;quot; stories. The idea is to replay the same scenario but hopefully with a happier ending, as a result of the improvements we&#x27;ve made. If you don&#x27;t see a &amp;quot;status quo&amp;quot; story that is right for telling your &amp;quot;shiny future&amp;quot; story, though, that&#x27;s no problem! Write up your story and we&#x27;ll figure out the &amp;quot;status quo&amp;quot; story it addresses. There is always the option of writing a new &amp;quot;status quo&amp;quot; story, too; we are still requesting &amp;quot;status quo&amp;quot; and &amp;quot;shiny future&amp;quot; stories, and we will do so right up until the end.&lt;/p&gt;
&lt;p&gt;If you&#x27;d like to see what a &amp;quot;shiny future&amp;quot; story looks like, we have merged one example, &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/shiny_future/barbara_makes_a_wish.html&quot;&gt;Barbara Makes a Wish&lt;/a&gt;. This story describes Barbara&#x27;s experiences using a nifty new tool that gives her lots of information about the state of her async executor. It is a &amp;quot;retelling&amp;quot; of the &amp;quot;status quo&amp;quot; story &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/status_quo/barbara_wants_async_insights.html&quot;&gt;Barbara Wants Async Insights&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a href&#x3D;&quot;#what-is-the-async-vision-doc-and-how-does-it-work&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;what-is-the-async-vision-doc-and-how-does-it-work&quot;&gt;&lt;/a&gt;What is the async vision doc and how does it work?&lt;/h4&gt;
&lt;p&gt;Here is the idea in a nutshell:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We are launching a collaborative effort to build a shared &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision.html#-the-vision&quot;&gt;vision document&lt;/a&gt; for Async Rust. &lt;strong&gt;Our goal is to engage the entire community in a collective act of the imagination:&lt;/strong&gt; how can we make the end-to-end experience of using Async I/O not only a pragmatic choice, but a &lt;em&gt;joyful&lt;/em&gt; one?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As described in the &lt;a href&#x3D;&quot;https://blog.rust-lang.org/2021/03/18/async-vision-doc.html&quot;&gt;original announcement&lt;/a&gt;, the &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision.html#-the-vision&quot;&gt;vision document&lt;/a&gt; is structured as a series of &amp;quot;status quo&amp;quot; and &amp;quot;shiny future&amp;quot; stories. Each story describes the experiences of one or more of our four &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/characters.html&quot;&gt;characters&lt;/a&gt; as they go about achieving their goals using Async Rust.&lt;/p&gt;
&lt;p&gt;The &amp;quot;status quo&amp;quot; stories describe the experiences that users have today. They are an amalgamation of the real experiences of people using Async Rust, as reported to us by interviews, blog posts, and tweets. The goal with these stories is to help us understand and gauge the cumulative impact that problems can have on our users.&lt;/p&gt;
&lt;p&gt;The &amp;quot;shiny future&amp;quot; stories describe those some characters achieving those same goals, but looking forward a few years into the future. They are meant to illustrate the experience we are aiming towards, and to give the overall context for the RFCs and other kinds of changes we want to pursue.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#the-brainstorming-period-and-what-comes-next&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;the-brainstorming-period-and-what-comes-next&quot;&gt;&lt;/a&gt;The brainstorming period and what comes next&lt;/h3&gt;
&lt;p&gt;We are currently in the midst of the &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/how_to_vision.html#brainstorming&quot;&gt;brainstorming period&lt;/a&gt;. This means that we are seeking to collect as many stories -- both about the &amp;quot;status quo&amp;quot; and the &amp;quot;shiny future&amp;quot; -- as we can. The brainstorming period lasts until the end of April. After that, the &lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/#leads&quot;&gt;working group leads&lt;/a&gt; are going to merge the remaining stories and get to work drafting a synthesized vision document that incorporates elements of the various stories that have been submitted.&lt;/p&gt;
&lt;p&gt;Going forward, we plan to revisit the vision document regularly. We fully expect that some aspects of the &amp;quot;shiny future&amp;quot; stories we write are going to be wrong, sometimes very wrong. We will be regularly returning to the vision document to check how things are going and adjust our trajectory appropriately.&lt;/p&gt;
&lt;h3&gt;&lt;a href&#x3D;&quot;#this-sounds-cool-how-can-i-get-involved&quot; aria-hidden&#x3D;&quot;true&quot; class&#x3D;&quot;anchor&quot; id&#x3D;&quot;this-sounds-cool-how-can-i-get-involved&quot;&gt;&lt;/a&gt;This sounds cool, how can I get involved?&lt;/h3&gt;
&lt;p&gt;If you&#x27;d like to help, we&#x27;d love to have you! If you&#x27;ve got an idea for a story, then feel free to create a PR to the wg-async-foundations repository based on one of the following templates:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/status_quo/template.html&quot;&gt;Template for &amp;quot;status quo&amp;quot; stories&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&#x3D;&quot;https://rust-lang.github.io/wg-async-foundations/vision/shiny_future/template.html&quot;&gt;Template for &amp;quot;shiny future&amp;quot; stories&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you&#x27;d like a bit more inspiration, then you can join &lt;a href&#x3D;&quot;https://twitter.com/ryan_levick/&quot;&gt;Ryan Levick&lt;/a&gt; and &lt;a href&#x3D;&quot;https://twitter.com/nikomatsakis/&quot;&gt;I&lt;/a&gt; at one of our vision doc writing sessions. We have &lt;a href&#x3D;&quot;https://smallcultfollowing.com/babysteps/blog/2021/04/12/async-vision-doc-writing-sessions-v/&quot;&gt;more sessions scheduled this week&lt;/a&gt; and you can look for announcements from us on twitter or check the &lt;code&gt;#wg-async-foundations&lt;/code&gt; stream on &lt;a href&#x3D;&quot;https://rust-lang.zulipchat.com/&quot;&gt;the rust-lang Zulip&lt;/a&gt;.&lt;/p&gt;
&lt;section class&#x3D;&quot;footnotes&quot;&gt;
&lt;ol&gt;
&lt;li id&#x3D;&quot;fn1&quot;&gt;
&lt;p&gt;Don&#x27;t be modest. You know you do. &lt;a href&#x3D;&quot;#fnref1&quot; class&#x3D;&quot;footnote-backref&quot;&gt;‚Ü©&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>

        <author>
            <name>Niko Matsakis</name>
        </author>
    </entry>
    
</feed>

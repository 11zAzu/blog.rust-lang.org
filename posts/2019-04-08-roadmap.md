---
layout: post
title: "Rust's 2019 roadmap"
author: The Rust Core Team
---

Each year the Rust community [comes together][roadmap-process] to set out a
roadmap. This year, in addition to the [survey], we put out a [call for blog
posts][blog-2019] in December, which resulted in [73 blog posts][read-rust]
written over the span of a few weeks. The end result is the recently-merged
[2019 roadmap RFC][rfc]. To get all of the details, please give it a read,
but this post lays out some of the highlights.

[roadmap-process]: https://github.com/rust-lang/rfcs/pull/1728
[survey]: https://blog.rust-lang.org/2018/11/27/Rust-survey-2018.html
[blog-2019]: https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html
[read-rust]: https://readrust.net/rust-2019/
[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md

In short, 2019 will be a year of *rejuvenation* and *maturation* for the Rust
project. Much of the focus is on strengthening our foundations and paying
down debt, both technical and organizational.

2018 was a fantastic year for production usage of Rust. Some of the largest
names in tech have started relying on Rust as a key part of their stack.
Smaller companies have started to build great things with our technology as
well.

Shipping the 2018 edition was both a herculean task and a great success. But
it also created a lot of debt, both technical and organizational. When
reading the Rust 2019 blog posts, and when having conversations with team
members at the Rust All Hands, a general theme developed: 2019 should still
be a year of shipping, but a certain kind of shipping. Words like confidence,
maturity, practicality, productivity, sustainability, and stability were
often used. This should be a year of reflection, one of polish, one of
finishing plans that were started long ago.

In some ways, it's easier to describe what this year should not be, rather
than what it should be. This should not be a year of dreaming up large new
features, one of drastic change, or one that makes your old code feel
obsolete.

With this general theme in mind, here are the high-level plans from each of
the teams for the upcoming year, in alphabetical order. The summaries are
meant to show plans in broad strokes and how they fit together for the
project.

[The Cargo team plans to](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#cargo):

* Better support cross-compilation
* Better support plugins, aka "custom cargo commands"
* Finish up some "almost done" features like custom registries


[The community team plans to](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#community):

* Invest in projects like RustBridge, event support, the YouTube channel and
  modernizing the community calendar
* Work on internationalization
* Help the teams communicate better with the wider community

[The compiler team plans to](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#compiler):

* Continue to reduce compile times, as much as possible
* Improve IDE integrations
* Improve compiler-internal documentation and organization

[The crates.io team plans to](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#cratesio):

* Grow the team
* Pay down techincal debt

[The dev tools team plans to](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#dev-tools):

* Be a bit of a "commons" space for cross-cutting tools concerns
* Finding out what needs are yet to be addressed by tooling and filling them
* Providing some kind of quorum helping smaller tool subteams make decisions

[The documentation team plans to](https://internals.rust-lang.org/t/the-new-docs-team-charter/9732):

* Setup easy editorial pipeline and plan to make it easier to contribute docs
* Establish an easy to understand and digest plan for remaining work for the standard library docs.
* Create a plan for non-traditional media creation such as audio and video.

[The language team plans to](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#language):

* Finish long-standing features, like async/await, const generics, Generic Associated Types, and specialization
* Work with the documentation team on the Rust reference.
* Produce "unsafe code guidelines" that describe what unsafe code can and cannot do.

[The library team plans to](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#library):

* Oversee and review ports of the standard library to new platforms
* Develop a plan of attack for custom allocators associated with instances of collections

Beyond the teams, [the various Working Groups also have plans for this year](https://github.com/rust-lang/rfcs/blob/master/text/2657-roadmap-2019.md#working-groups).

The "Networking Services" WG from 2018 has split in two: The "Async
Foundations" effort, which is being led by the language design team, will
focus on building the 'core building blocks' that belong to the language
itself, such as the Future trait and async-await syntax. The "Async
Ecosystem" working group, meanwhile, will focus on nurturing the budding
ecosystem built on top of those layers. The plan for 2019 is to focus on the
Tide web framework, and help expand the ecosystem around async/await.

The CLI WG is planning:

* The design and maintenance of `clap` v3.0
* Working on the testing crates, such as `assert_cli`, `assert_fs`, and `assert_cmd`
* Improving the organizational structure of the WG through meetings, organization, and branding

The WebAssembly WG is planning:

* Bring multithreading to Rust-generated Wasm.
* Integrate best-in-class debugging support into our toolchain.
* Polish our toolchain and developer workflow, culminating in a 1.0 version of wasm-pack.

The embedded WG is planning:

* Documentation improvements, specially intermediate level docs covering API design patterns and coding guidelines
* Maturing the ecosystem: growing existing libraries and highlighting projects to serve as examples

The Secure Code WG is a new working group. It's planning to:

* Improve the Distribution of security patches
* Improving code authentication
* Reduce the need for unsafe code
* Better verification of the standard library